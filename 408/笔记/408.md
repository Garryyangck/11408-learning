# 数据结构

## 第1章：绪论

### 1.数据结构

#### 数据

- **定义**：就是信息的原始素材，可以是数字、文字、符号等。
- **例子**：`3, "苹果", 3.14, 'A'` 这些都是数据，但它们是零散的、无意义的。

#### 数据元素

- **定义**：数据的基本单位（就像组成表格的"一行"）。
- **例子**：一个学生的信息（`学号:101，姓名:张三，年龄:20`）就是一个数据元素。

#### 数据对象

- **定义**：同一类数据元素的集合（类似"`全班花名册`"）。
- **例子**：全班50个学生的信息合起来就是一个数据对象。

#### 数据类型

- **定义**：数据的种类，决定了能对它做什么操作（比如数字能加减，文字不能）。
- 例子：
	- `int`（整数类型）：可以加减乘除。
	- `string`（字符串类型）：可以拼接、截取。

#### 数据结构

- **定义**：数据元素之间的组织方式，目的是高效存取或操作。
- 例子：
	- **数组**：像一排连续盒子，快速按编号找东西。
	- **链表**：像手拉手的小朋友，插入删除灵活但查找慢。
	- **树**：像家族家谱，适合表达层级关系。

> - **数据**：`"张三", 20, "李四", 19`（零散信息）
> - **数据元素**：`{"姓名":"张三", "年龄":20}`（一个学生的完整信息）
> - **数据对象**：全班学生的信息集合（所有数据元素放一起）
> - **数据类型**：年龄是`int`，姓名是`string`（规定怎么存、怎么算）
> - **数据结构**：用**数组**存学生（快速查第n个），或用**链表**存（方便插班生）

> **数据**和**数据元素**是原材料，**数据结构**是包装盒

#### 数据结构三要素

1. **逻辑结构**：数据元素之间**一对一、一对多、多对多**的关系（比如**有序表**）
2. **存储结构**：**物理空间**中的存储方法（比如**顺序、链式、索引、散列存储**）
3. 数据的运算

### 2.算法

#### 五个特征

1. 有穷性
2. 确定性
3. 可行性：算法的每条操作都可以实现的
4. 输入
5. 输出

#### 时间复杂度

一般考虑最坏情况

#### 空间复杂度

额外空间



## 第2章：线性表

### 1.线性表

线性表是**逻辑结构**，可**顺序或链式存储**

有前驱和后继

### 2.顺序表

逻辑顺序和物理顺序相同

**空间固定，满了需要扩容**

**随机访问**

结点只存储数据，**不存储数据之间的关系**

### 3.链表

**注意链表的头结点不存储数据，只为方便遍历和插入**

**插入删除的时间复杂度是$O(n)$，因为要找前一个结点**

#### 双链表

**可以在$O(1)$复杂度内完成插入删除**（不用遍历找前一个结点）

#### 循环链表

**尾结点的next是头结点，而不是$a_1$**

#### 静态链表

用**表格**的形式表示链表，以`next=-1`作为结束标志



## 第3章：栈与队列

### 1.卡特兰数

$$
n个元素进栈，有\frac{1}{n+1}C^n_{2n}种出栈排列 \\\\
C_0=1\\\\
C_1=1\\\\
C_2=2\\\\
C_3=5\\\\
C_4=14
$$

> 注意：这里的n个元素进栈是有顺序的，比如以`123`的顺序进栈，但是出栈的顺序有`123，132，213，231，321`五种

### 2.顺序栈

逻辑结构是线性表

初始时设置`S.top=-1`

### 3.共享栈

<img src="408.assets/image-20250723160242276.png" alt="image-20250723160242276" style="zoom:80%;" />

**降低上溢风险**，因为共享栈更大，只有整个空间被占满才会上溢

**栈满条件**：

1. 起始指针为`-1和MaxSize`，表示**已被占用的位置**，`top1-top0=1`
2. 起始指针为`0和MaxSize-1`，表示**下一个将被占用的位置**，两指针以“`top0top1`”相遇时并不会栈满，而是以“`top1top0`”形式相遇时才会栈满，因此栈满条件为`top0-top1=1`

### 4.链栈

<img src="408.assets/image-20250723160823174.png" alt="image-20250723160823174" style="zoom:80%;" />

链栈**不会上溢**

**没有头结点**

**所有操作在表头完成**

### 5.队列

逻辑结构是线性表

**尾进头出**

**front指向队头，rear指向队尾的下一个元素**

初始时`front=rear=0`

<img src="408.assets/image-20250723161207003.png" alt="image-20250723161207003" style="zoom:80%;" />

### 6.循环队列

<img src="408.assets/image-20250723161918601.png" alt="image-20250723161918601" style="zoom:80%;" />

循环队列**以数组的形式存储**

循环队列是**物理结构**

由于判断队满和队空的条件均为`front=rear`，因此采取下面三种方式区分栈满和栈空

1. 牺牲一个存储单元`(rear+1)%MaxSize=front`栈满
2. 引入`size`
3. 引入`tag`，`tag=1`栈满

### 7.链队列

单链表，头指针指向**头结点**，尾指针指向最后一个结点

注意，出队时，如果只剩最后一个结点，则要额外把`rear`移动到头结点和`front`重合，以便通过`front=rear`判断队空

<img src="408.assets/image-20250723163055554.png" alt="image-20250723163055554" style="zoom:80%;" />

### 8.双端队列

<img src="408.assets/image-20250723165305433.png" alt="image-20250723165305433" style="zoom:80%;" />

输出受限的双端队列：

<img src="408.assets/image-20250723165420971.png" alt="image-20250723165420971" style="zoom:80%;" />

输入受限的双端队列：

<img src="408.assets/image-20250723165451458.png" alt="image-20250723165451458" style="zoom:80%;" />

> 输入序列1234
>
> 对于输出受限，预得到4213，先从左右插入得到4213：`1->21->213->4213`，全部左出
>
> 对于输入受限，预得到4132，先从一端插入1234，然后从两端取出：`1234->123->23->3`

### 9.栈与队列的应用

#### 括号匹配

遍历，左括号入栈，右括号则去匹配栈顶

#### 后缀表达式和表达式求值

也称**逆波兰式**

**中缀转后缀**：有一个`op`栈暂存符号

<img src="408.assets/image-20250723171613252.png" alt="image-20250723171613252" style="zoom:80%;" />

**计算中缀表达式**，比如`A+B*(C-D)-E/F`：

1. `num`和`op`两个栈
2. 数字直接入栈
3. 若**栈顶的优先级$\geq$自己，则一直出栈**，直到栈顶优先级$<$自己或栈空为止
4. **右括号一直出栈，直到找到左括号**

#### 栈与递归

#### 队列与层次遍历

```java
while(!Q.isEmpty()) {
    int n = Q.size();
    for (int i = 0; i < n; i++) {
        TreeNode node = Q.pop();
        if (node.left != NULL) {
            Q.push(node.left);
        }
        if (node.right != NULL) {
            Q.push(node.right);
        }
    }
}
```

#### 缓冲区与消息队列

缓冲区：解决快慢匹配问题（如CPU与打印机）

消息队列：异步、削峰（多个外设同时请求CPU）、解耦

### 10.数组和特殊矩阵

#### 对称矩阵

上下三角半区的元素相同，因此**存储在一维数组$[n(n+1)/2]$中**，在一维数组中的下标k与矩阵的坐标关系：

<img src="408.assets/image-20250723211437118.png" alt="image-20250723211437118" style="zoom:80%;" />

#### 三角矩阵

和对称矩阵类似，不过**最后要存储对角线另一侧的常数（三角矩阵对角线另一侧全为常数）**：

<img src="408.assets/image-20250723211446997.png" alt="image-20250723211446997" style="zoom:80%;" />

<img src="408.assets/image-20250723211501436.png" alt="image-20250723211501436" style="zoom:80%;" />

#### 三对角矩阵

存放到**一维数组**：

<img src="408.assets/image-20250723211652983.png" alt="image-20250723211652983" style="zoom:80%;" />

#### 稀疏矩阵

**三元组**$(i,j,a_{ij})$，可用**数组或十字链表存储三元组**



## 第4章：串

### 1.KMP算法

书写得依托答辩，看下面的图即可：

**主串的指针i永远不回退**：

<img src="408.assets/image-20250723214214663.png" alt="image-20250723214214663" style="zoom: 50%;" />

<img src="408.assets/image-20250723214313073.png" alt="image-20250723214313073" style="zoom: 50%;" />

<img src="408.assets/image-20250723214425379.png" alt="image-20250723214425379" style="zoom: 50%;" />

<img src="408.assets/image-20250723214448681.png" alt="image-20250723214448681" style="zoom: 50%;" />

<img src="408.assets/image-20250723214519945.png" alt="image-20250723214519945" style="zoom:50%;" />

<img src="408.assets/image-20250723214530570.png" alt="image-20250723214530570" style="zoom:50%;" />

<img src="408.assets/image-20250723214554955.png" alt="image-20250723214554955" style="zoom:50%;" />

当匹配失败时，找**最后一个匹配位置的next的值**。新一轮匹配时，**模式串直接跳过next的值个字符**，将当前的字符和主串匹配失败的位置继续匹配

现在，所有的问题在于如何寻找next数组

### 2.next数组

next数组的本质就是**寻找子串中相同前后缀的长度**：

<img src="408.assets/image-20250723215237025.png" alt="image-20250723215237025" style="zoom: 67%;" />

计算方法见下图：

<img src="408.assets/image-20250723215342965.png" alt="image-20250723215342965" style="zoom: 80%;" />

<img src="408.assets/image-20250723215402022.png" alt="image-20250723215402022" style="zoom:80%;" />

<img src="408.assets/image-20250723215422402.png" alt="image-20250723215422402" style="zoom:80%;" />

<img src="408.assets/image-20250723215439615.png" alt="image-20250723215439615" style="zoom:80%;" />

<img src="408.assets/image-20250723215450456.png" alt="image-20250723215450456" style="zoom:75%;" />

### 3.递推求解next数组

核心思想：没必要每次都寻找最长前后缀，可以根据**动态规划**的思想，**利用前面掌握的信息递推下一项**

<img src="408.assets/image-20250723220327020.png" alt="image-20250723220327020" style="zoom: 67%;" />

<img src="408.assets/image-20250723220416758.png" alt="image-20250723220416758" style="zoom:67%;" />

<img src="408.assets/image-20250723220431782.png" alt="image-20250723220431782" style="zoom:67%;" />

下面可能有点绕，解释一下：下一位不匹配，但是子串`ABACABA`已经匹配过了，它存在最长前后缀`ABA`，那么后面那个`A`在左边已经求得跳跃长度为1(next[2]=1)，因此只需子串`ABACABA`跳过第一个`A`，然后第二个`B`匹配，因此这里的`B`的最长前后缀为`next[2]+1=2`

<img src="408.assets/image-20250723220604737.png" alt="image-20250723220604737" style="zoom:67%;" />

<img src="408.assets/image-20250723221057705.png" alt="image-20250723221057705" style="zoom:67%;" />



## 第5章：树与二叉树

