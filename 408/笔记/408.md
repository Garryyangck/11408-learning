数据结构

## 第1章：绪论

### 1.数据结构

#### 数据

- **定义**：就是信息的原始素材，可以是数字、文字、符号等。
- **例子**：`3, "苹果", 3.14, 'A'` 这些都是数据，但它们是零散的、无意义的。

#### 数据元素

- **定义**：数据的基本单位（就像组成表格的"一行"）。
- **例子**：一个学生的信息（`学号:101，姓名:张三，年龄:20`）就是一个数据元素。

#### 数据对象

- **定义**：同一类数据元素的集合（类似"`全班花名册`"）。
- **例子**：全班50个学生的信息合起来就是一个数据对象。

#### 数据类型

- **定义**：数据的种类，决定了能对它做什么操作（比如数字能加减，文字不能）。
- 例子：
	- `int`（整数类型）：可以加减乘除。
	- `string`（字符串类型）：可以拼接、截取。

#### 数据结构

- **定义**：数据元素之间的组织方式，目的是高效存取或操作。
- 例子：
	- **数组**：像一排连续盒子，快速按编号找东西。
	- **链表**：像手拉手的小朋友，插入删除灵活但查找慢。
	- **树**：像家族家谱，适合表达层级关系。

> - **数据**：`"张三", 20, "李四", 19`（零散信息）
> - **数据元素**：`{"姓名":"张三", "年龄":20}`（一个学生的完整信息）
> - **数据对象**：全班学生的信息集合（所有数据元素放一起）
> - **数据类型**：年龄是`int`，姓名是`string`（规定怎么存、怎么算）
> - **数据结构**：用**数组**存学生（快速查第n个），或用**链表**存（方便插班生）

> **数据**和**数据元素**是原材料，**数据结构**是包装盒

#### 数据结构三要素

1. **逻辑结构**：数据元素之间**一对一、一对多、多对多**的关系（比如**有序表**）
2. **存储结构**：**物理空间**中的存储方法（比如**顺序、链式、索引、散列存储**）
3. 数据的运算

> 区别逻辑结构和物理结构：从名字里无法得出物理存储方式，则为逻辑结构，否则是存储结构
>
> 比如线性表可以顺序或链式存储，为逻辑结构
>
> 而顺序表的物理空间连续，为存储结构

### 2.算法

#### 五个特征

1. 有穷性
2. 确定性
3. 可行性：算法的每条操作都可以实现的
4. 输入
5. 输出

#### 时间复杂度

一般考虑最坏情况

#### 空间复杂度

额外空间



## 第2章：线性表

### 1.线性表

线性表是**逻辑结构**，可**顺序或链式存储**

有前驱和后继

### 2.顺序表

逻辑顺序和物理顺序相同

**空间固定，满了需要扩容**

**随机访问**

结点只存储数据，**不存储数据之间的关系**

### 3.链表

**注意链表的头结点不存储数据，只为方便遍历和插入**

**插入删除的时间复杂度是$O(n)$，因为要找前一个结点**

#### 双链表

**可以在$O(1)$复杂度内完成插入删除**（不用遍历找前一个结点）

#### 循环链表

**尾结点的next是头结点，而不是$a_1$**

#### 静态链表

用**表格**的形式表示链表，以`next=-1`作为结束标志



## 第3章：栈与队列

### 1.卡特兰数

$$
n个元素进栈，有\frac{1}{n+1}C^n_{2n}种出栈排列 \\\\
C_0=1\\\\
C_1=1\\\\
C_2=2\\\\
C_3=5\\\\
C_4=14
$$

> 注意：这里的n个元素进栈是有顺序的，比如以`123`的顺序进栈，但是出栈的顺序有`123，132，213，231，321`五种

### 2.顺序栈

逻辑结构是线性表

初始时设置`S.top=-1`

### 3.共享栈

<img src="408.assets/image-20250723160242276.png" alt="image-20250723160242276" style="zoom:80%;" />

**降低上溢风险**，因为共享栈更大，只有整个空间被占满才会上溢

**栈满条件**：

1. 起始指针为`-1和MaxSize`，表示**已被占用的位置**，`top1-top0=1`
2. 起始指针为`0和MaxSize-1`，表示**下一个将被占用的位置**，两指针以“`top0top1`”相遇时并不会栈满，而是以“`top1top0`”形式相遇时才会栈满，因此栈满条件为`top0-top1=1`

### 4.链栈

<img src="408.assets/image-20250723160823174.png" alt="image-20250723160823174" style="zoom:80%;" />

链栈**不会上溢**

**没有头结点**

**所有操作在表头完成**

### 5.队列

逻辑结构是线性表

**尾进头出**

**front指向队头，rear指向队尾的下一个元素**

初始时`front=rear=0`

<img src="408.assets/image-20250723161207003.png" alt="image-20250723161207003" style="zoom:80%;" />

### 6.循环队列

<img src="408.assets/image-20250723161918601.png" alt="image-20250723161918601" style="zoom:80%;" />

循环队列**以数组的形式存储**

循环队列是**物理结构**

由于判断队满和队空的条件均为`front=rear`，因此采取下面三种方式区分栈满和栈空

1. 牺牲一个存储单元`(rear+1)%MaxSize=front`栈满
2. 引入`size`
3. 引入`tag`，`tag=1`栈满

### 7.链队列

单链表，头指针指向**头结点**，尾指针指向最后一个结点

注意，出队时，如果只剩最后一个结点，则要额外把`rear`移动到头结点和`front`重合，以便通过`front=rear`判断队空

<img src="408.assets/image-20250723163055554.png" alt="image-20250723163055554" style="zoom:80%;" />

### 8.双端队列

<img src="408.assets/image-20250723165305433.png" alt="image-20250723165305433" style="zoom:80%;" />

输出受限的双端队列：

<img src="408.assets/image-20250723165420971.png" alt="image-20250723165420971" style="zoom:80%;" />

输入受限的双端队列：

<img src="408.assets/image-20250723165451458.png" alt="image-20250723165451458" style="zoom:80%;" />

> 输入序列1234
>
> 对于输出受限，预得到4213，先从左右插入得到4213：`1->21->213->4213`，全部左出
>
> 对于输入受限，预得到4132，先从一端插入1234，然后从两端取出：`1234->123->23->3`

### 9.栈与队列的应用

#### 括号匹配

遍历，左括号入栈，右括号则去匹配栈顶

#### 后缀表达式和表达式求值

也称**逆波兰式**

**中缀转后缀**：有一个`op`栈暂存符号

<img src="408.assets/image-20250723171613252.png" alt="image-20250723171613252" style="zoom:80%;" />

**计算中缀表达式**，比如`A+B*(C-D)-E/F`：

1. `num`和`op`两个栈
2. 数字直接入栈
3. 若**栈顶的优先级$\geq$自己，则一直出栈**，直到栈顶优先级$<$自己或栈空为止
4. **右括号一直出栈，直到找到左括号**

#### 栈与递归

#### 队列与层次遍历

```java
while(!Q.isEmpty()) {
    int n = Q.size();
    for (int i = 0; i < n; i++) {
        TreeNode node = Q.pop();
        if (node.left != NULL) {
            Q.push(node.left);
        }
        if (node.right != NULL) {
            Q.push(node.right);
        }
    }
}
```

#### 缓冲区与消息队列

缓冲区：解决快慢匹配问题（如CPU与打印机）

消息队列：异步、削峰（多个外设同时请求CPU）、解耦

### 10.数组和特殊矩阵

#### 对称矩阵

上下三角半区的元素相同，因此**存储在一维数组$[n(n+1)/2]$中**，在一维数组中的下标k与矩阵的坐标关系：

<img src="408.assets/image-20250723211437118.png" alt="image-20250723211437118" style="zoom:80%;" />

#### 三角矩阵

和对称矩阵类似，不过**最后要存储对角线另一侧的常数（三角矩阵对角线另一侧全为常数）**：

<img src="408.assets/image-20250723211446997.png" alt="image-20250723211446997" style="zoom:80%;" />

<img src="408.assets/image-20250723211501436.png" alt="image-20250723211501436" style="zoom:80%;" />

#### 三对角矩阵

存放到**一维数组**：

<img src="408.assets/image-20250723211652983.png" alt="image-20250723211652983" style="zoom:80%;" />

#### 稀疏矩阵

**三元组**$(i,j,a_{ij})$，可用**数组或十字链表存储三元组**



## 第4章：串

### 1.KMP算法

书写得依托答辩，看下面的图即可：

**主串的指针i永远不回退**：

<img src="408.assets/image-20250723214214663.png" alt="image-20250723214214663" style="zoom: 50%;" />

<img src="408.assets/image-20250723214313073.png" alt="image-20250723214313073" style="zoom: 50%;" />

<img src="408.assets/image-20250723214425379.png" alt="image-20250723214425379" style="zoom: 50%;" />

<img src="408.assets/image-20250723214448681.png" alt="image-20250723214448681" style="zoom: 50%;" />

<img src="408.assets/image-20250723214519945.png" alt="image-20250723214519945" style="zoom:50%;" />

<img src="408.assets/image-20250723214530570.png" alt="image-20250723214530570" style="zoom:50%;" />

<img src="408.assets/image-20250723214554955.png" alt="image-20250723214554955" style="zoom:50%;" />

当匹配失败时，找**最后一个匹配位置的next的值**。新一轮匹配时，**模式串直接跳过next的值个字符**，将当前的字符和主串匹配失败的位置继续匹配

现在，所有的问题在于如何寻找next数组

### 2.next数组

next数组的本质就是**寻找子串中相同前后缀的长度**：

<img src="408.assets/image-20250723215237025.png" alt="image-20250723215237025" style="zoom: 67%;" />

计算方法见下图：

<img src="408.assets/image-20250723215342965.png" alt="image-20250723215342965" style="zoom: 80%;" />

<img src="408.assets/image-20250723215402022.png" alt="image-20250723215402022" style="zoom:80%;" />

<img src="408.assets/image-20250723215422402.png" alt="image-20250723215422402" style="zoom:80%;" />

<img src="408.assets/image-20250723215439615.png" alt="image-20250723215439615" style="zoom:80%;" />

<img src="408.assets/image-20250723215450456.png" alt="image-20250723215450456" style="zoom:75%;" />

### 3.递推求解next数组

核心思想：没必要每次都寻找最长前后缀，可以根据**动态规划**的思想，**利用前面掌握的信息递推下一项**

<img src="408.assets/image-20250723220327020.png" alt="image-20250723220327020" style="zoom: 67%;" />

<img src="408.assets/image-20250723220416758.png" alt="image-20250723220416758" style="zoom:67%;" />

<img src="408.assets/image-20250723220431782.png" alt="image-20250723220431782" style="zoom:67%;" />

下面可能有点绕，解释一下：下一位不匹配，但是子串`ABACABA`已经匹配过了，它存在最长前后缀`ABA`，那么后面那个`A`在左边已经求得跳跃长度为1(`next[2]=1`)，因此只需子串`ABACABA`跳过第一个`A`，然后第二个`B`匹配，因此这里的`B`的最长前后缀为`next[2]+1=2`

<img src="408.assets/image-20250723220604737.png" alt="image-20250723220604737" style="zoom:67%;" />

<img src="408.assets/image-20250723221057705.png" alt="image-20250723221057705" style="zoom:67%;" />



## 第5章：树与二叉树

### 1.树的概念

**结点的度=出度**；**树的度=最大度数**

**结点的路径长度=两结点之间的边数**；**树的路径长度=根到所有结点的路径长度总和**

### 2.二叉树

**二叉树是有序树**
$$
n个结点最多形成\frac{(2n)!}{(n+1)!n!}个二叉树
$$
**二叉树**和**度为2的树**的区别：

1. 二叉树可以为空；度为2的树至少要有3个结点
2. 二叉树有序；度为2的树不一定有序

#### 满二叉树

**每一层都填满**

#### 完全二叉树

可以**用一维数组存储**

<img src="408.assets/image-20250724114942660.png" alt="image-20250724114942660" style="zoom:80%;" />

**完全二叉树度为1的结点最多1个**（非常重要）

注意：完全二叉树的**叶子节点最后一层和倒数第二层都可能有**，**不能忽略倒数第二层**

#### 正则二叉树

只有度为0或2的结点

#### 性质

$$
&n_0+n_1+n_2=n_1+2 \times n_2+1 \\\\
&n_0=n_2+1
$$

### 3.二叉树的遍历和线索二叉树

#### 二叉树的遍历

先序遍历：一根线围一圈

中序遍历：竖着看

后序遍历：从左到右摘葡萄

#### 由遍历构造二叉树

核心思路：**分治**

**先序+中序**：

```java
TreeNode findTreeByPreorderInorder(String preorder, String inorder) {
    if (preorder.isEmpty() || inorder.isEmpty()) {
        return null;
    }
    if (preorder.length() == 1 || inorder.length() == 1) {
        return new TreeNode(preorder.charAt(0) - '0');
    }
    
    char root = preorder.charAt(0);
    int rootIndex = inorder.indexOf(root); // 左子树的大小
    
    String leftPreorder = preorder.substring(1, rootIndex + 1);
    String rightPreorder = preorder.substring(rootIndex + 1);
    String leftInorder = inorder.substring(0, rootIndex);
    String rightInorder = inorder.substring(rootIndex + 1);
    
    TreeNode left = findTreeByPreorderInorder(leftPreorder, leftInorder);
    TreeNode right = findTreeByPreorderInorder(rightPreorder, rightInorder);
    
    return new TreeNode(root - '0', left, right);
}
```

**后序+中序**：

基本同理，不再赘述

**层次+中序**：

```java
TreeNode findTreeByLevelorderInorder(String levelorder, String inorder) {
    if (levelorder.isEmpty() || inorder.isEmpty()) {
        return null;
    }
    if (levelorder.length() == 1 || inorder.length() == 1) {
        return new TreeNode(levelorder.charAt(0) - '0');
    }
    
    char rootVal = levelorder.charAt(0);
    int rootIndex = inorder.indexOf(rootVal); // 左子树的大小
    
    String leftInorder = inorder.substring(0, rootIndex);
    String rightInorder = inorder.substring(rootIndex + 1);
    
    StringBuilder leftLevelorder = new StringBuilder();
    StringBuilder rightLevelorder = new StringBuilder();
    
    // 整体的层次遍历，包含了左右子树的层次遍历
    // 如果元素来自左子树，则加入leftInorder，加入顺序符合左子树层次遍历的顺序
    for (int i = 1; i < levelorder.length(); i++) {
        char c = levelorder.charAt(i);
        if (leftInorder.indexOf(c) != -1) {
            leftLevelorder.append(c);
        } else if (rightInorder.indexOf(c) != -1) {
            rightLevelorder.append(c);
        }
    }
    
    TreeNode left = 
        findTreeByLevelorderInorder(leftLevelorder.toString(), leftInorder);
    TreeNode right = 
        findTreeByLevelorderInorder(rightLevelorder.toString(), rightInorder);
    
    return new TreeNode(rootVal - '0', left, right);
}
```

#### 线索二叉树

**总空间：`2n`**

**使用：`n-1`**

**空余：`n+1`**

线索二叉树就是要**把空余的`n+1`个空间利用起来**，用它们**指示结点的先\中\后序遍历的前驱和后继**

增加`ltag`和`rtag`，标识左右子树是指向孩子还是前驱后继：

<img src="408.assets/image-20250724130611335.png" alt="image-20250724130611335" style="zoom:80%;" />

<img src="408.assets/image-20250724130644489.png" alt="image-20250724130644489" style="zoom:80%;" />

遍历**中序**线索二叉树：

```java
TreeNode nextNode(TreeNode root) {
    if (root.rtag == 0) { // 右子树的最左结点
        return firstNode(root.right);
    }
    return root.right; // 直接返回后继
}

TreeNode firstNode(TreeNode root) { // 树的最左结点
    if (root == null || root.left == null) {
        return null;
    }
    return firstNode(root.left);
}
```

### 4.树和森林

#### 树的表示法

**双亲表示法**：

<img src="408.assets/image-20250724162921312.png" alt="image-20250724162921312" style="zoom:80%;" />

**孩子表示法**：

<img src="408.assets/image-20250724162952527.png" alt="image-20250724162952527" style="zoom:80%;" />

**孩子兄弟表示法**：

```c
typedef struct TreeNode {
    ElemType* data;
    struct TreeNode *firstChild, *nextBrother;
} TreeNode, *Tree;
```

有第一个孩子和下一个兄弟，可以轻易**将森林化为二叉树**

#### 树、森林、二叉树转换

**树->二叉树**：

`left`指向**第一个孩子**，`right`指向**右兄弟**：

<img src="408.assets/image-20250724163739566.png" alt="image-20250724163739566" style="zoom:80%;" />

**森林->二叉树**：

同理

**二叉树->森林**：

1. **根结点和左子树是一棵树**，**断开右子树**；
2. 右子树重复上述操作

<img src="408.assets/image-20250724164522857.png" alt="image-20250724164522857" style="zoom:80%;" />

#### 树和森林的遍历

树的**先根遍历**

树的**后根遍历**

**森林的先序遍历**：依次**先根遍历**每一棵树

**森林的中序遍历**：依次**后根遍历**每一棵树

<img src="408.assets/image-20250724165037411.png" alt="image-20250724165037411" style="zoom:80%;" />

### 5.树与二叉树的应用

#### 哈夫曼树

树的带权路径长度(只算叶子结点)最小

<img src="408.assets/image-20250724165527549.png" alt="image-20250724165527549" style="zoom:80%;" />

#### 并查集

作用：**查找两个元素是否属于同一集合，合并两个集合**

`Initial`，`Union`，`Find`

<img src="408.assets/image-20250724170929262.png" alt="image-20250724170929262" style="zoom:80%;" />

**用数组表示并查集**

**数组的index是编号，数组的值是index的父结点**

构造并查集的步骤如下图（**也可初始化为-1或其它负数**）：

<img src="408.assets/image-20250724171606025.png" alt="image-20250724171606025" style="zoom: 50%;" />

<img src="408.assets/image-20250724171726499.png" alt="image-20250724171726499" style="zoom:50%;" />

<img src="408.assets/image-20250724171831385.png" alt="image-20250724171831385" style="zoom:50%;" />

```java
void init(int[] parent) {
    for (int i = 0; i < parent.length; i++)
        parent[i] = i; // 所有元素的父节点初始化为自己
}

int find(int[] parent, int index) {
    return parent[index] == index ? index : find(parent, parent[index]);
}

void union(int[] parent, int index1, int index2) {
    parent[find[index2]] = find[index1];
}
```

**路径压缩**：为了**避免让树过高**，可以在**find的过程中，让树的每一个元素的parent直接指向根节点**

<img src="408.assets/image-20250724173853501.png" alt="image-20250724173853501" style="zoom:50%;" />

```java
int find(int[] parent, int index) {
    if (parent[index] != index) {
        parent[index] = find(parent, parent[index]); // 路径压缩
    }
    return parent[index];
}
```



## 第6讲：图

### 1.图的概念

**顶点集非空，边集可为空**

#### 简单图

1. 无重复边
2. 无指向自己的边

#### 多重图

非简单图

#### 简单路径

顶点不重复的路径

#### 简单回路

顶点不重复的回路

#### 距离

距离=最短路径

#### 连通、连通分量

**无向图**的概念

<img src="408.assets/image-20250724210853147.png" alt="image-20250724210853147" style="zoom:80%;" />

#### 强连通、强连通分量

**有向图**的概念

任意两点相互有弧

#### 生成树

性质：**边数=顶点数-1**（重要）

<img src="408.assets/image-20250724211634711.png" alt="image-20250724211634711" style="zoom:80%;" />

#### 网

网=带权的图

#### 完全图

边全满

### 2.图的存储

#### 邻接矩阵

适合**稠密图**

空间：$V^2$

#### 邻接链表

分为**顶点表**和**边表**

**顶点表竖着，边表横着**

<img src="408.assets/image-20250724212427198.png" alt="image-20250724212427198" style="zoom:80%;" />

空间：$V+E$

#### 十字链表

只适用于**有向图**

<img src="408.assets/image-20250724213114537.png" alt="image-20250724213114537" style="zoom:80%;" />

**顶点结点**：`firstin`以该点作为弧头的第一个弧；`firstout`以该点作为弧尾的第一个弧

**弧结点**：前两个分别是弧的尾头，后面两个是竖着和横着的`next`

<img src="408.assets/image-20250724213315705.png" alt="image-20250724213315705" style="zoom:80%;" />

#### 邻接多重表

只适用于**无向图**

<img src="408.assets/image-20250724214047836.png" alt="image-20250724214047836" style="zoom:80%;" />

`ivex`域和`jvex`域=**两个顶点的编号**

`ilink`域指向ivex的**下一条边**；`jlink`域指向**jvex的下一条边**

<img src="408.assets/image-20250724214243686.png" alt="image-20250724214243686" style="zoom:80%;" />

`firstedge`=该节点的**第一条边**

<img src="408.assets/image-20250724214425849.png" alt="image-20250724214425849" style="zoom:80%;" />

### 3.图的遍历

#### BFS

辅助队列`Q`，且有`visit[]`，类似层次遍历

```java
boolean visited[] = new boolean[V];

void BFSTraverse(Graph G) {
    for (int i = 0; i < V; i++) {
        visited = false;
    }
    Queue Q = new Deque<Integer>();
    for (int i = 0; i < V; i++) {
        if (!visited[i]) {
            BFS(G, i);
        }
    }
}

void BFS(Graph G, int i) {
    visited[i] = true;
    Q.offer(i);
    while (Q.isNotEmpty()) {
        int peek = Q.poll();
        for (int j = 0; j < V; j++) {
            if (G.edge[peek][j] == 1 && !visited[j]) {
                visited[j] = true;
                Q.offer(j);
            }
        }
    }
}
```

适合走迷宫类问题

**空间复杂度**：**$O(V)$**，辅助队列`Q`

**时间复杂度**：**$O(V+E)(邻接链表)$、$O(V^2)(邻接矩阵)$**

#### DFS

类似先序遍历

**空间复杂度**：**$O(V)$**，递归栈

**时间复杂度**：**$O(V+E)(邻接链表)$、$O(V^2)(邻接矩阵)$**

> 连通图/强连通图，一次调用BFS/DFS即可访问所有点
>
> 非连通图/非强连通图，一次调用BFS/DFS不能访问所有点

### 4.图的应用

#### 最小生成树

最小生成树，**边数=顶点数-1**

---

**Prim算法**：

1. 先选一个点，然后选**离它最近的一个点**
2. 更新其它点到这个新整体的距离
3. 在选一个离新整体最近的点

**时间复杂度**：**$O(V^2)$**，只和顶点有关

---

**Kruskal算法**：

1. 选**最短的一条边**
2. 如果不构成回路，则加入，否则丢弃
3. 直到有n-1条边

**时间复杂度**：**$O(E\log_2E)$**，只和变有关

#### 最短路径

**Dijkstra算法**：单源最短路径

每次**选离源点最短的点**，更新其它点到新整体的距离

<img src="408.assets/image-20250725153241678.png" alt="image-20250725153241678" style="zoom:80%;" />

**时间复杂度**：**$O(V^2)$**，只和顶点有关

**边上有负值时，Dijkstra算法不适用**

---

**Floyd算法**：

```java
dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])
```

**时间复杂度**：**$O(V^3)$**，只和顶点有关

**允许负权的边，不允许总权值为负的回路**

<img src="408.assets/image-20250725153847564.png" alt="image-20250725153847564" style="zoom:80%;" />

#### 有向无环图

DAG图，编译原理里有讲过

<img src="408.assets/image-20250725154536028.png" alt="image-20250725154536028" style="zoom:80%;" />

<img src="408.assets/image-20250725154545753.png" alt="image-20250725154545753" style="zoom:80%;" />

#### 拓扑排序

AOV网无权值

不断找**入度为0**的点输出；找不到则说明有回路

<img src="408.assets/image-20250725154941497.png" alt="image-20250725154941497" style="zoom:80%;" />

**时间复杂度**：**$O(V+E)(邻接链表)$、$O(V^2)(邻接矩阵)$**

拓扑排列的结果不一定唯一

#### 关键路径

AOE网有权值

人话：**一个点只有等所有指向它的点都完成才能开始，因此最早开始时间是指向它的所有点中的最晚时间**，求出所有点的最早开始时间后，选一条**时间最长的路径**就是关键路径

<img src="408.assets/image-20250725161303145.png" alt="image-20250725161303145" style="zoom:80%;" />

1. `v_e`就是每个点的最早开始时间

	<img src="408.assets/image-20250725161313042.png" alt="image-20250725161313042" style="zoom:80%;" />

2. `v_l`是每个点的最晚开始时间，从`v_6`开始反着来减，找最大值

	<img src="408.assets/image-20250725161457788.png" alt="image-20250725161457788" style="zoom:80%;" />

3. `e`是弧的最早开始时间，等于弧尾的最早开始时间`v_e`

4. `l`是弧的最晚开始时间，等于弧头的最晚开始时间减`weight`：`v_l-weight`

5. 最后`l-e=0`的就是关键路径

**关键路径不唯一**



## 第7讲：查找

### 1.查找的概念

静态查找表：只查不改，适用于顺序、折半、散列

动态查找表：CRUD，适用于二叉排序树、散列

平均查找长度**ASL**：**被查找概率\*比较次数**

### 2.顺序查找和折半查找

#### 顺序查找

**一般顺序查找**：
$$
\mathrm{ASL}_\text{战功}=\sum_{i=1}^nP_i(n-i+1)=\frac{n+1}{2} \\\\
\mathrm{ASL}_\text{ 不成功 }=n+1
$$

---

**有序线性查找**：

<img src="408.assets/image-20250725211234016.png" alt="image-20250725211234016" style="zoom:80%;" />

有**n+1个空隙**，到达**最后两个空隙都需要比较n次**
$$
\text{ASL}{\text{不成功}} = \sum{j=1}^{n} q_j (l_j - 1) = \frac{1 + 2 + \cdots + n + n}{n+1} = \frac{n}{2} + \frac{n}{n+1}
$$

#### 折半查找

<img src="408.assets/image-20250725211550693.png" alt="image-20250725211550693" style="zoom:80%;" />
$$
\text{ASL} = \frac{1}{n}\sum_{i=1}^{n} l_i = \frac{n+1}{n}\log_2(n+1) - 1 \approx \log_2(n+1) - 1 \\\\
查找成功（圆形结点）：ASL=(1×1+2×2+3×4+4×4)/11=3\\\\
查找失败（方形结点）：ASL=(3×4+4×8)/12=11/3
$$

#### 分块查找

块内无序，块间有序

块内顺序，块间折半

### 3.树形查找

#### 二叉排序树

**不能有重复元素**

CRUD复杂度均为`O(logn)`

**二叉排序树的删除**：

1. 叶子结点直接删除

2. 被删除结点**只有一个子树**，则将子树直接连到父结点

3. 被删除结点有**两个子树**，则用其直接后继(**右子树的最左结点**)代替

	<img src="408.assets/image-20250725213254909.png" alt="image-20250725213254909" style="zoom:80%;" />

#### 平衡二叉树

注意：平衡二叉树是**所有的子树都平衡**，**并不只有根节点所在的树平衡**

```Java
boolean isAVL = true;

int treeLevel(TreeNode root) { // 在求树的高度中顺带判断是否平衡
    if (root == null)
        return 0;
    int leftLevel = treeLevel(root.left);
    int rightLevel = treeLevel(root.right);
    if (Math::abs(leftLevel - rightLevel) > 1)
        isAVL = false;
    return Math::abs(leftLevel, rightLevel) + 1;
}
```

<img src="408.assets/image-20250725220613375.png" alt="image-20250725220613375" style="zoom:80%;" />

**LL**：右旋

<img src="408.assets/image-20250725220755768.png" alt="image-20250725220755768" style="zoom:80%;" />

**RR**：左旋

<img src="408.assets/image-20250725220848648.png" alt="image-20250725220848648" style="zoom:80%;" />

**LR**：C先左旋到B，再右旋到A

<img src="408.assets/image-20250725221515766.png" alt="image-20250725221515766" style="zoom:80%;" />

**RL**：C先右旋到B，再左旋到A

<img src="408.assets/image-20250725221535241.png" alt="image-20250725221535241" style="zoom:80%;" />

**深度为n的平衡二叉树最少结点数**：
$$
n_h=n_{h-2}+n_{h-1}+1
$$
<img src="408.assets/image-20250725222647299.png" alt="image-20250725222647299" style="zoom:80%;" />

#### 红黑树

<img src="408.assets/image-20250725223043283.png" alt="image-20250725223043283" style="zoom:80%;" />

**null是黑色的**

**最长路径不会超过最短路径的两倍**，比如上图中，最短为左子树三黑，最后为右子树的黑红黑红黑

红黑树不平衡，搜索效率率低于AVL树，但插入和删除效率高于AVL树

红黑树的插入和构造不想记

### 4.B树和B+树

> 二叉搜索树、AVL树、红黑树都是将全部数据读到内存中，数据量不大
>
> 而B树适用于数据量很大，无法一次性读入内存，只能一次读一个结点进行比较，然后再比较下一个结点
>
> 硬盘访问次数和树的高度成正比，**B树可以降低硬盘访问次数**（Mysql使用B+树存储数据）

#### B树

**最下面查找失败的外部结点叫叶子结点**

<img src="408.assets/image-20250726111841087.png" alt="image-20250726111841087" style="zoom:80%;" />
$$
m阶B树最多m个子树，m-1个元素 \\\\

m阶B树至少 \left\lceil \frac{m}{2} \right\rceil个子树，\left\lceil \frac{m}{2} \right\rceil -1个元素
$$
**根结点最少还是1个元素**

> 上图中每个结点最多5个子树，4个元素；最少3个子树，2个元素

**访问结点在硬盘上进行**；**结点内查找是在内存中进行**

---

**插入**：出现上溢出，则**中间左偏结点向上提**

> **4阶**B树：最多3个元素，最少1个元素
>
> <img src="408.assets/image-20250726113554135.png" alt="image-20250726113554135" style="zoom:80%;" />
>
> <img src="408.assets/image-20250726113613168.png" alt="image-20250726113613168" style="zoom:80%;" />
>
> <img src="408.assets/image-20250726113638106.png" alt="image-20250726113638106" style="zoom:80%;" />
>
> <img src="408.assets/image-20250726113656062.png" alt="image-20250726113656062" style="zoom:80%;" />
>
> <img src="408.assets/image-20250726113711445.png" alt="image-20250726113711445" style="zoom:80%;" />
>
> <img src="408.assets/image-20250726113805609.png" alt="image-20250726113805609" style="zoom:80%;" />
>
> <img src="408.assets/image-20250726113818971.png" alt="image-20250726113818971" style="zoom:80%;" />
>
> <img src="408.assets/image-20250726113739470.png" alt="image-20250726113739470" style="zoom:80%;" />
>
> <img src="408.assets/image-20250726113847557.png" alt="image-20250726113847557" style="zoom:80%;" />
>
> <img src="408.assets/image-20250726113856309.png" alt="image-20250726113856309" style="zoom:80%;" />

---

**删除**：

1. **删除非最后一层的元素，都用其直接前驱或后继代替**

	<img src="408.assets/image-20250726114522390.png" alt="image-20250726114522390" style="zoom: 80%;" />

	![image-20250726114607174](408.assets/image-20250726114607174.png)

2. **出现下溢出，向左右兄弟借**

	<img src="408.assets/image-20250726115105991.png" alt="image-20250726115105991" style="zoom:80%;" />

	**把父节点元素下移，兄弟元素上移**

	<img src="408.assets/image-20250726115406363.png" alt="image-20250726115406363" style="zoom:80%;" />

	<img src="408.assets/image-20250726115437738.png" alt="image-20250726115437738" style="zoom:80%;" />

3. **左右兄弟都不够借，和其中一个合并**

	**父节点先下移再合并**

	<img src="408.assets/image-20250726115708278.png" alt="image-20250726115708278" style="zoom:80%;" />

	<img src="408.assets/image-20250726115821853.png" alt="image-20250726115821853" style="zoom:80%;" />

	<img src="408.assets/image-20250726115850794.png" alt="image-20250726115850794" style="zoom:80%;" />

4. **父节点下溢出的情况**

	<img src="408.assets/image-20250726120330011.png" alt="image-20250726120330011" style="zoom:80%;" />

	<img src="408.assets/image-20250726120351578.png" alt="image-20250726120351578" style="zoom:80%;" />

	![image-20250726120405422](408.assets/image-20250726120405422.png)

#### B+树

<img src="408.assets/image-20250726121228878.png" alt="image-20250726121228878" style="zoom:80%;" />

每个结点**元素和子树个数相同**

**每个元素对应子树的元素最大值**

---

**最后一层不存储数据，而是指向数据的地址**

<img src="408.assets/image-20250726121550537.png" alt="image-20250726121550537" style="zoom:80%;" />

### 5.散列表

#### 散列函数

1. 直接定址法
2. 除留余数法
3. 数字分析法
4. 平方取中法

#### 哈希冲突

**开放定址法**：放到现有的其它空间，**不开辟新的空间**

1. 线性探测法：向后递推
2. 平方探测法：$d_i=1^2,-1^2,2^2,-2^2,\cdots,k^2,-k^2$
3. 双散列法：$d_i=i\mathrm{xHash}_2(\mathrm{key})$，利用第二个散列函数$Hash_2(key)$计算该关键字的地址增量
4. 伪随机数法

---

**拉链法**：**开辟新的空间**

<img src="408.assets/image-20250726122237024.png" alt="image-20250726122237024" style="zoom:80%;" />

#### 装填因子

$$
\alpha=\frac{\text{表中记录数}n}{\text{散列表长度}m}
$$



## 第8讲：排序

### 1.排序的概念

**稳定排序**：**不改变相同元素的相对位置**

**不稳定排序**：**改变相同元素的相对位置**

**内部排序**：所有数据加载到内存中排序，**速度取决于时间复杂度**

**外部排序**：排序的数据不断在内存、外存中移动，**速度取决于内、外存移动次数**

### 2.插入排序

#### 直接插入排序

前面部分有序

#### 折半插入排序

时间复杂度仍为$O(n^2)$，因为每次循环需要把后面的元素向后移一位

#### 希尔排序

把间隔为 $d$ 的元素分为一组，每一组内部直接插入排序，不断减小 $d$ 直至为 1

<img src="408.assets/image-20250726162537323.png" alt="image-20250726162537323" style="zoom:80%;" />

### 3.交换排序

#### 冒泡排序

如果已经有序，则break，最好时间复杂度为 $O(n)$

#### 快速排序

分治思想，选一个 `pivot`，每一趟左边小于等于 `pivot`，右边大于等于 `pivot`

```Java
void quickSort(int[] arr, int low, int high) {
    if (arr == null || arr.length <= 1 || low >= high)
        return;
    
    int pivotIndex = partition(arr, low, high);
    quickSort(arr, low, pivotIndex - 1);
    quickSort(arr, pivotIndex + 1, high);
}

int partition(int[] arr, int low, int high) {
    int pivot = arr[low];
    while(low < high) {
        while(low < high && arr[high] >= pivot)
            high--;
        arr[low] = arr[high];
        while(low < high && arr[low] <= pivot)
            low++;
        arr[high] = arr[low];
    }
    arr[low] = pivot;
    return low;
}
```

```
[5, 3, 8, 6, 2, 7, 1, 4] 初始
[4, 3, 1, 2, 5, 7, 6, 8] 第1轮后（基准5归位）
[2, 3, 1, 4]             第2轮左子数组（基准4）
[1, 2, 3]                第3轮左子数组（基准2）
[6, 7, 8]                第4轮右子数组（基准7）
[1, 2, 3, 4, 5, 6, 7, 8] 最终结果
```

### 4.选择排序

#### 简单选择排序

每次选一个最小的

#### 堆排序

**堆=完全二叉树**，用**一维数组存储**

<img src="408.assets/image-20250726165706488.png" alt="image-20250726165706488" style="zoom:80%;" />

**从最后一个子树开始，逐步向上调整为大根堆**

<img src="408.assets/image-20250726165937705.png" alt="image-20250726165937705" style="zoom:80%;" />

堆排序就是建立完堆后，**逐步输出并删除堆顶元素**

---

**删除**：

<img src="408.assets/image-20250726170148187.png" alt="image-20250726170148187" style="zoom:80%;" />

1. **堆顶和最后一个元素交换**
2. 然后**逐步向下调整**

<img src="408.assets/image-20250726170237672.png" alt="image-20250726170237672" style="zoom:80%;" />

---

**插入**：

1. 新结点放在末端
2. 然后**逐步向上调整**

<img src="408.assets/image-20250726170434363.png" alt="image-20250726170434363" style="zoom:80%;" />

---

<img src="408.assets/image-20250726170609664.png" alt="image-20250726170609664" style="zoom:80%;" />

适用于从海量数据中找最大的几个数

**建堆时间复杂度 $O(n)$**

**删除和插入只和树高度有关**，**时间复杂度 $O(\log_2n)$**

### 5.归并排序

需要辅助空间，**空间复杂度 $O(n)$**

```Java
void mergeSort(int[] arr, int low, int high) {
    if (arr.legnth == 0 || arr.length == 1)
        return;
    int mid = (low + right) / 2;
    mergeSort(arr, low, mid);
    mergeSort(arr, mid + 1, high);
    int[] temp = new int[arr.length]; // 辅助空间
    int i = 0, j = mid + 1, index = 0;
    while(i <= mid && j <= high) {
        if (arr[i] <= arr[j])
            temp[index++] = arr[i++];
        else
            temp[index++] = arr[j++];
    }
    while(i <= mid)
        temp[index++] = arr[i++];
    while(j <= high)
        temp[index++] = arr[j++];
    for (index = 0; index < arr.length; index++)
        arr[index] = temp[index];
}
```

### 6.基数排序和计数排序

#### 基数排序

就是**桶排序**

```
[329, 457, 657, 839, 436, 720, 355]
按个位排序
[720, 355, 436, 457, 657, 329, 839]
再按十位排序
[720, 329, 436, 839, 355, 457, 657]
再按百位排序
[329, 355, 436, 457, 657, 720, 839]
```

**按每次排序完成的顺序放入下一个桶中**

**时间复杂度**：**$O(d(n+r))$**，其中 **d=3, r=10**

#### 计数排序

给定数的范围，先构造数组，然后一次遍历，**统计每个数出现的次数**

### 7.内部排序比较

| 算法种类     | 最好情况  | 平均情况      | 最坏情况  | 空间复杂度   | 是否稳定 |
| ------------ | --------- | ------------- | --------- | ------------ | -------- |
| 直接插入排序 | **O(n)**  | O(n²)         | O(n²)     | O(1)         | 是       |
| 冒泡排序     | **O(n)**  | O(n²)         | O(n²)     | O(1)         | 是       |
| 简单选择排序 | O(n²)     | O(n²)         | O(n²)     | O(1)         | **否**   |
| 希尔排序     | -         | -             | -         | O(1)         | **否**   |
| 快速排序     | O(nlog₂n) | O(nlog₂n)     | **O(n²)** | **O(log₂n)** | **否**   |
| 堆排序       | O(nlog₂n) | O(nlog₂n)     | O(nlog₂n) | O(1)         | **否**   |
| 二路归并排序 | O(nlog₂n) | O(nlog₂n)     | O(nlog₂n) | **O(n)**     | 是       |
| 基数排序     | O(d(n+r)) | **O(d(n+r))** | O(d(n+r)) | **O(r)**     | 是       |

### 8.外部排序

外部排序指的是大文件的排序，即待**排序的记录存储在外存中**，待排序的文件**无法一次性装入内存**，需要在**内存和外存之间进行多次数据交换**，以达到排序整个文件的目的。

**时间取决于IO次数**

<img src="408.assets/image-20250726175939478.png" alt="image-20250726175939478" style="zoom:80%;" />

**上图进行了3趟归并(树高为3)**

#### 多路平衡归并与败者树

**增加归并路数，降低归并趟数**，但是**归并算法复杂度会增加**；为了**避免归并算法复杂度增加，引入败者树**

1. **叶子节点**：多路归并的各路当前元素
2. **非叶子节点**：比较中的**失败者**的**索引**
3. **根节点**：**全局败者**（最终**胜者不保存在树中，直接输出**）
4. 在**根节点上加一个结点表示最终胜者**

<img src="408.assets/image-20250726212751769.png" alt="image-20250726212751769" style="zoom: 67%;" />

<img src="408.assets/image-20250726212809443.png" alt="image-20250726212809443" style="zoom:67%;" />

#### 置换-选择排序

**作用**：将大量数据分成若干个**有序的块**（而不是完全排序），为后续多路归并排序做准备

**核心思想**：利用有限内存，边读数据边排序，输出一组**相对有序的子序列**，减少后续归并次数

<img src="408.assets/image-20250726213854604.png" alt="image-20250726213854604" style="zoom:80%;" />

<img src="408.assets/image-20250726213902514.png" alt="image-20250726213902514" style="zoom:80%;" />

<img src="408.assets/image-20250726213945756.png" alt="image-20250726213945756" style="zoom:80%;" />

<img src="408.assets/image-20250726213957650.png" alt="image-20250726213957650" style="zoom:80%;" />

#### 最佳归并树

**作用**：在**多路归并排序**中，**用最少的读写次数**将多个有序小文件（归并段）合并成一个大文件

**核心思想**：像“合并快递包裹”一样，**优先合并小的文件**，减少总搬运（IO）次数

**本质**：**多路哈夫曼树**

<img src="408.assets/image-20250726221341283.png" alt="image-20250726221341283" style="zoom:80%;" />

上述方法并不是最佳

若**初始归并段不足以构成一颗完整的k叉树**，则添加长度为0的**虚段**

<img src="408.assets/image-20250726221717066.png" alt="image-20250726221717066" style="zoom:80%;" />

---

**计算虚段个数**：
$$
\text{设度为 }0\text{ 的结点有 }n_0\text{ 个,度为 }k\text{ 的结点有 }n_k\text{ 个,归并树的结点总数为 }n \\\\
\begin{aligned}n&=n_k+n_0\\\\n&=kn_k+1\end{aligned} \\\\
n_k=(n_0-1)/(k-1) \\\\
(n_0-1)\%(k-1)=0，正好可以构造k叉归并树 \\\\
(n_0-1)\%(k-1)=u\neq0，有u个多余，补上k-u-1个虚段
$$
<img src="408.assets/image-20250726222511219.png" alt="image-20250726222511219" style="zoom:80%;" />

<img src="408.assets/image-20250726222451294.png" alt="image-20250726222451294" style="zoom:80%;" />





# 计算机组成原理

## 第1章：计算机系统概述

### 1.冯诺依曼机

1. “存储程序”的工作方式，即把**程序和数据放到存储器，顺序取出执行**
2. **存储器、运算器、控制器、输入输出设备**
3. **指令和数据**以**二进制**表示，同等地位，**形式上没有区别**
4. 指令=**操作码+地址码**

### 2.输入设备

键盘、鼠标、扫描仪等

### 3.输出设备

显示器、打印机

### 4.存储器

分为主存(内存)和外存(辅存)

**CPU能直接访问的是主存**

#### MAR

存储器地址寄存器(Memory Address Register)，在CPU和内存之间传递地址

**MAR的位数=地址线宽度**

#### MDR

存储器数据寄存器(Memory Data Register)，在CPU和内存之间传递读写数据

**MDR的位数=数据线宽度**，**通常=存储字长**，但也可以是**存储字长的倍数**(**一次传输多个存储字**)

| 寄存器  |          作用          | 位于 |    连接方式     |
| :-----: | :--------------------: | :--: | :-------------: |
| **MAR** |  存储要访问的内存地址  | CPU  | 地址总线 → 内存 |
| **MDR** | 临时存储读写内存的数据 | CPU  | 数据总线 ↔ 内存 |

**MAR和MDR均位于CPU内部，参与内存读写**

#### 存储字长

**存储单元**，存储的最小单元

**存储字长**，存储单元的长度，按字节存储，存储字长就是$1B$，**$$1B 或 2^nB$$**

### 5.运算器

**运算器的核心是ALU**(Arithmetic Logic Unit，算数逻辑单元)

**运算器的寄存器**：**通用寄存器组(GPRs)**，**标志寄存器(PSW，如ZF、SF、CF、OF)**

### 6.控制器

**控制器=程序计数器(PC)+指令寄存器(IR)+控制单元(CU)**

#### PC

**PC位数=地址线宽度**

**PC->MAR->地址总线->内存**

#### IR

**IR存放正在执行的指令**

指令=操作码+地址码

**操作码->CU**

**地址码->MAR->地址总线->内存**

### 7.CPU

**中央处理器(CPU)=运算器+控制器**

<img src="408.assets/image-20250727163429603.png" alt="image-20250727163429603" style="zoom:80%;" />

### 8.总线

总线位于**CPU和内存之间**

**地址总线**：CPU**单向**传输到内存，用于寻址(**MAR将地址信息送到地址总线上**)

**控制总线**：控制读\写

**数据总线**：(**MDR将数据送到数据总线，或从数据总线接受数据**)

### 9.软件

系统软件：大家都有

应用软件：特定功能

### 10.语言

机器语言：机器唯一识别和可执行的语言

汇编语言

高级语言：编译型语言(通过编译器生成中间代码)，解释型语言(通过解释器直接翻译成机器语言)

### 11.计算机层次结构

<img src="408.assets/image-20250727164654971.png" alt="image-20250727164654971" style="zoom:80%;" />

软硬件交界面=ISA(指令体系结构)，即所有指令的集合

<img src="408.assets/image-20250727164936033.png" alt="image-20250727164936033" style="zoom:80%;" />

预处理将`#include...`插入过来

### 12.指令执行过程

```
从内存取指令：
PC->MAR->地址总线->Mem->数据总线->MDR->IR
操作码送CU分析指令：
OP(IR)->CU
地址码送内存取数据：
AD(IR)->MAR->地址总线->Mem->数据总线->MDR->ACC
```

### 13.机器字长

机器字长简称字长

**32位机、64位机指的是机器字长**

字长=**定点整数运算**所需的位数

字长通常=**寄存器位数**和**ALU宽度**

字长**影响最大寻址空间**

### 14.性能计算

$$
CPU时钟周期=\frac{1}{主频} \\\\
CPI：一条指令需要的时钟周期数 \\\\
IPS：每秒执行的指令数=\frac{主频}{CPI} \\\\
CPU执行时间=\frac{总周期数}{主频}=\frac{指令数\times CPI}{主频} \\\\
MIPS=\frac{指令条数}{执行时间\times 10^6}=\frac{主频}{CPI\times 10^6}
$$

### 15.透明性

对程序员**可见**：**GPRs、PSW、PC**（可通过汇编指令查看）

对程序员**透明**：**IR、MAR、MDR**（编程时无法获取）



## 第2章：数据的表示和运算

### 1.数制转换

<img src="408.assets/image-20250727202905179.png" alt="image-20250727202905179" style="zoom:80%;" />

<img src="408.assets/image-20250727202922282.png" alt="image-20250727202922282" style="zoom:80%;" />

<img src="408.assets/image-20250727202932409.png" alt="image-20250727202932409" style="zoom:80%;" />

### 2.原码、补码、反码、移码

#### 原码

**只变符号位**

关于原点对称，有正零和负零

#### 补码

$$
-n=\sim n+1
$$

**符号位的权**：**$2^{n-1}$**

**负数补码转真值时，可以直接把符号位当作 $-1\times 2^{n-1}$ 去和后面的相加**

> **原码和补码**表示**8位定点整数和小数**：
>
> **8位定点整数**：
>
> | 表示方式 | 符号 |    范围    |  最小值（二进制）  |  最大值（二进制）  |
> | :------: | :--: | :--------: | :----------------: | :----------------: |
> | **原码** | 正数 | +0 到 +127 |  `0000 0000` (+0)  | `0111 1111` (+127) |
> |          | 负数 | -127 到 -0 | `1111 1111` (-127) |  `1000 0000` (-0)  |
> | **补码** | 正数 | 0 到 +127  |  `0000 0000` (0)   | `0111 1111` (+127) |
> |          | 负数 | -128 到 -1 | `1000 0000` (-128) |  `1111 1111` (-1)  |
>
> **8位定点小数**：
>
> | 表示方式 | 符号 |      范围      |    最小值（二进制）     |    最大值（二进制）    |
> | :------: | :--: | :------------: | :---------------------: | :--------------------: |
> | **原码** | 正数 | +0 到 1−$2^7$  |    `0.000 0000` (+0)    | `0.111 1111` (1−$2^7$) |
> |          | 负数 | -1+$2^7$ 到 -0 | `1.111 1111` (-1+$2^7$) |   `1.000 0000` (-0)    |
> | **补码** | 正数 |  0 到 1−$2^7$  |    `0.000 0000` (0)     | `0.111 1111` (1−$2^7$) |
> |          | 负数 |  -1 到 -$2^7$  |    `1.000 0000` (-1)    | `1.111 1111` (-$2^7$)  |

#### 变形补码

00表示正，11表示负，01正溢出，10负溢出

#### 反码

**除符号位以外取反**

负数的原码符号位取反，反码在此基础上数值位又取反，因此负数的补码等于~n

负数的补码=反码+1

#### 移码

**移码是无符号数**

**移码等于原码+偏置$2^{n-1}$**

### 3.C语言类型转换

隐式类型转换：**小类型->大类型**：

1. `int` → `unsigned int` → `long` → `unsigned long` → `long long` → `unsigned long long`
2. `float` → `double` → `long double`

隐式类型转换：**有符号->无符号**

强制类型转换：**大字节->小字节，高位截断**

强制类型转换：**小字节->大字节，零扩展(无符号整数)\符号扩展(有符号整数)**

---

`int`->`float`，舍入

`int`、`float`->`double`，精确

`double`->`float`，舍入

`float`、`double`->`int`，`int`没有小数，**只保留整数部分**

### 4.运算电路

#### 一位全加器

<img src="408.assets/image-20250727213019925.png" alt="image-20250727213019925" style="zoom:80%;" />

<img src="408.assets/image-20250727213109603.png" alt="image-20250727213109603" style="zoom:80%;" />

#### 串行进位加法器

<img src="408.assets/image-20250727213055769.png" alt="image-20250727213055769" style="zoom:80%;" />

两个$n$位二进制数 $A = A*_{n}A_*{n-1}\cdots A*_{1}$ 和 $B = B_*{n}B*_{n-1}\cdots B_*{1}$ 逐位相加

#### 并行进位加法器

### 5.移位运算

#### 逻辑移位

**全补零**

#### 算数移位

**右移补符号位**

### 6.加法运算

直接加

**溢出判断，采用变补**：**01正溢出，10负溢出**
$$
A-B=A+\sim B+1
$$
**CF**判断**无符号数**是否溢出，**加法进位或减法借位，CF=1**

**OF**判断**有符号数**是否溢出，**正+正得负，或负+负得正，OF=1**

### 7.乘法运算

**原码**乘法，就是列竖式

<img src="408.assets/image-20250727215256064.png" alt="image-20250727215256064" style="zoom:80%;" />

如果乘积用到了**高32位**，则**溢出**

### 8.除法运算

**原码**除法，需要把**被除数补充到2n长度**

<img src="408.assets/image-20250727215534010.png" alt="image-20250727215534010" style="zoom:80%;" />

**商n+1位，则溢出；n位则不溢出**

### 9.浮点数

**阶码用移码表示**(加上偏置$2^{n-1}$)

**尾数用原码表示**

<img src="408.assets/image-20250727220519376.png" alt="image-20250727220519376" style="zoom:80%;" />

偏置为$2^{7-1}=64$，阶码最大为$127-64=63$，最小为$0-64=-64$

> 移码是加上偏置后的结果，因此真值需要减去偏置

<img src="408.assets/image-20250727220503890.png" alt="image-20250727220503890" style="zoom:80%;" />

**浮点数关于原点对称**

#### 规格化浮点数

**尾数最高位为1，且小数点前面不能是1**

> 补码表示尾数，则看符号位和第二位是否相反

**左规**

**右规**：最多一次，因为小数点前面最多为1

#### IEEE标准

<img src="408.assets/image-20250727221313715.png" alt="image-20250727221313715" style="zoom:80%;" />

**注意**：IEEE阶码的**偏置为$2^{n-1}-1$而不是$2^{n-1}$**，比如32位浮点偏置值为127

**小数点前有一个隐藏的1**
$$
(-1)^s\times1.f\times2^{e-127}
$$

|    特殊情况    | 符号位（S） | 阶码（E）  |         尾数（M）         |
| :------------: | :---------: | :--------: | :-----------------------: |
|     **+0**     |     `0`     | `00000000` | `00000000000000000000000` |
|     **-0**     |     `1`     | `00000000` | `00000000000000000000000` |
|     **+∞**     |     `0`     | `11111111` | `00000000000000000000000` |
|     **-∞**     |     `1`     | `11111111` | `00000000000000000000000` |
|    **NaN**     |     `0`     | `11111111` | `10000001000010000010001` |
| **非规格化数** |     `0`     | `00000000` | `10100001000001000000001` |

### 10.浮点数加法

**小阶向大阶看齐，尾数右移**

尾数加完后规格化，最多右规一次

> **舍入法**：
>
> 1. 就近舍入(如果距离两侧相等，则舍入到偶数)
> 2. 正向舍入(取右侧最接近的数)
> 3. 负向舍入(取左侧最接近的数)
> 4. 截断法(直接截取到所需位数)

**阶码无法表示，才会上溢或下溢**

### 11.大小端法和对齐

1. 大端法：低地址高字节

2. 小端法：低地址低字节

3. 半字地址是2的整数倍，字的地址是4的整数倍

	<img src="408.assets/image-20250728110906521.png" alt="image-20250728110906521" style="zoom:80%;" />

4. 结构体对齐：找最大的元素，以它为基准对齐



## 第3章：存储系统

### 1.存储器概述

#### 存储器分类

1. 主存储器：**CPU运行所需的程序和数据**
2. 辅助存储器：**调入主存才能被CPU访问**
3. 高速缓冲存储器：**主存和CPU之间**，存放CPU常用数据

---

1. 随机存储器(RAM)：随机存取，用于**主存和缓存**

2. 只读存储器(ROM)：**只读不写**，数据不会更改和丢失，用于**主存**

	> ROM派生的存储器也可写，随机读写，速度慢

3. 串行访问存储器：**按物理位置顺序寻址**

	- 顺序存取存储器：**磁带**，只能按物理顺序，慢
	- 直接存取存储器：**磁盘、光盘**，先寻找某个小区域，在小区域内部顺序查找

---

1. 易失性存储器，**RAM(SRAM+DRAM)**
2. 非易失性存储器，**ROM**

---

1. 破坏性读出，**DRAM**，读出后原信息被破坏，需**再生**
2. 非破坏性读出，**SRAM，ROM**

#### 存储器性能指标

1. 存储容量

2. 单位成本

3. 存储速度

	- 存取时间

	- **存取周期=存取时间+复原时间(破坏性读出)**

		<img src="408.assets/image-20250728114402662.png" alt="image-20250728114402662" style="zoom:80%;" />

	- 主存带宽

#### 存储系统层次结构

<img src="408.assets/image-20250728114541969.png" alt="image-20250728114541969" style="zoom:80%;" />

<img src="408.assets/image-20250728114550001.png" alt="image-20250728114550001" style="zoom:80%;" />

主存和Cache的数据交换由硬件控制，对程序员透明；

主存和辅存的数据交换由硬件和操作系统共同控制，对应用程序员透明

### 2.主存储器

#### SRAM

静态随机存储器(Static Random Access Memory)

**非破坏性读出**

用于**Cache**

#### DRAM

动态随机存储器(Dynamic Random Access Memory)

用于**主存**

**破坏性读出**，需要**刷新和再生**

> **刷新的单位是行**
>
> **同一行两次刷新的间隔通常为2ms**
>
> 刷新方式：
>
> 1. **集中刷新**：集中刷新期间不能访问存储器
> 2. **分散刷新**：前半部分读写，**后半部分刷新**
> 3. **异步刷新**：刷新周期/行数，**均匀间隔**刷新每一行

|       特性       |       刷新（Refresh）        |      再生（Restore）       |
| :--------------: | :--------------------------: | :------------------------: |
|   **触发原因**   |         电容自然漏电         | **破坏性读出**导致电荷丢失 |
|   **触发时机**   | 周期性（如64ms内刷新所有行） |       每次读写操作后       |
| **是否依赖访问** |  独立于CPU访问（后台操作）   |  依赖读写操作（同步完成）  |
|   **数据路径**   |     内部重写，不输出数据     | 数据输出到CPU后写回原地址  |

**刷新是周期性行为，再生只有在读出数据时才会发生**

> **地址引脚复用技术**（重要）
>
> **行地址和列地址用同一组地址线，先后分两次输入**，因此需要**行和列尽可能相等**

#### ROM

**常用于控制存储器CM(存储微程序，在CPU内部)**

1. **MROM**：厂商输入，不能修改
2. **PROM**：用户一次输入，不能修改
3. **EROM**：用户多次修改，耗时长
4. **flash**：不加电可长期保存，通电可快速修改
5. **SDD**：基于flash，性能更优

**存储单元**=存储元件=记忆单元：只存储一个0、1位

**存储矩阵**=存储体=存储阵列

**编址**：把一串存储单元构成一个单位，**按字节编址、按字编址**

#### 多模块存储器

**单体多字存储器**：一次连续取多条指令，要求多条指令物理空间连续

**多体并行存储器**：

- **高位交叉编址**（**顺序**方式）

	<img src="408.assets/image-20250728130949072.png" alt="image-20250728130949072" style="zoom:80%;" />

	**模块号=体号在高地址**，**CPU只能顺序访问每个模块**，**多个模块不能并行**

- **低位交叉编址**（**交叉**方式）

	<img src="408.assets/image-20250728131202423.png" alt="image-20250728131202423" style="zoom:80%;" />

	**并行工作**，假设单模块工作周期10s，总线周期1s，那么至少要有10个模块，否则会浪费总线的速度

	**交叉存储器的时间**：

	<img src="408.assets/image-20250728131751531.png" alt="image-20250728131751531" style="zoom:80%;" />
	
	**交叉方式访存冲突**：
	
	根据**低位模块号得到访存所选的存储器**，如果同一存储器的两次访存相邻m位以内，则会冲突
	
	<img src="408.assets/image-20250728164454616.png" alt="image-20250728164454616" style="zoom:80%;" />
	
	<img src="408.assets/image-20250728164525033.png" alt="image-20250728164525033" style="zoom:80%;" />

### 3.主存储器和CPU的连接

#### 主存的扩展

1. **位扩展**：**数据线多**

	<img src="408.assets/image-20250728165152708.png" alt="image-20250728165152708" style="zoom:80%;" />

	**数据线$D_0\sim D_7$并联**(宽度增加)，**地址线$A_0\sim A_{12}$串联**(宽度不变)

2. **字扩展**：地址线多

	<img src="408.assets/image-20250728165609128.png" alt="image-20250728165609128" style="zoom:80%;" />

	**地址线$A_0\sim A_{13}$片内地址，新增$A_{14}\sim A_{15}$用于片选**(宽度增加)，**数据线$D_0\sim D_7$串联**(宽度不变)

3. **字位同时扩展**：

	<img src="408.assets/image-20250728170011345.png" alt="image-20250728170011345" style="zoom:80%;" />

	8片$16K\times 4$位扩展为$64K\times 8$位

	分为4组，需要**两位地址线片选**

	**组内两片的地址线并联为8位**，组间串联

#### 片选

1. **线选法**：**每条高位地址线仅代表一个芯片**
2. **译码片选法**：高位当作**二进制数**

#### 存储器和CPU连接

1. 存储芯片的选择：**ROM存放系统程序，RAM存放用户程序**
2. 地址线连接：**低位片内地址，高位片选**
3. 数据线连接：**CPU数据线位数必须和芯片数据线位数相同**，否则需要扩展
4. 控制线连接：读写控制线分别于读写控制端相连
5. 片选线连接：片选信号只有当访存控制信号$\overline{MERQ}$为低电平时才有效

### 4.外部存储器

#### 磁盘

<img src="408.assets/image-20250728174049790.png" alt="image-20250728174049790" style="zoom:80%;" />

1. **盘片**有正反**两个记录面**

2. **记录面=磁头**

3. **柱面=磁道**

4. **扇区**，内道的位密度大

5. **记录密度**：道密度，位密度，面密度=道密度\*位密度

6. **磁盘容量**：

	- **非格式化容量**：$记录面数\times柱面数\times每条磁道的磁化单元数$
	- **格式化容量**：$记录面数\times柱面数\times扇区数\times扇区容量$

7. **存取时间**：
	$$
	存取时间=寻道时间+旋转延迟时间+传输时间
	$$
	寻道时间取**最外到最内时间的一半**

	旋转延迟时间取**转半周的时间**

8. **磁盘地址**：

	<img src="408.assets/image-20250728175718255.png" alt="image-20250728175718255" style="zoom:80%;" />

9. **RAID**(独立冗余**磁盘阵列**)：**多个物理盘合成一个逻辑盘**，数据在多个物理盘之间交叉存储，**并行读写**

#### 固态硬盘SSD

1. **SSD基于闪存flash**

2. **写入前要擦除**，**寿命有限**

3. **磨损均衡**：

	如果反复写入同一区块，该区块会先报废，导致 SSD 提前失效

	磨损均衡算法，让**所有区块均匀磨损**

	- **动态磨损均衡**：优先写入**擦除次数少的块**
	- **静态磨损均衡**：数据长期不变，也让老的块承担读任务，新的块准备承担写任务

### 5.Cache

由**SRAM**组成，通常集成在CPU中

**时间局限性**：同一段代码再次使用

**空间局限性**：相邻地址的数据一起被使用

<img src="408.assets/image-20250728213113432.png" alt="image-20250728213113432" style="zoom:80%;" />

<img src="408.assets/image-20250728230746375.png" alt="image-20250728230746375" style="zoom:80%;" />

#### 命中率

$$
Cache的总命中次数N_c，访存次数N_m，命中率为：\\\\
H=\frac{N_c}{N_c+N_m}
$$

#### 直接映射

<img src="408.assets/image-20250728213738825.png" alt="image-20250728213738825" style="zoom:80%;" />

**每个set只有一个line**

直接映射**地址结构**：

<img src="408.assets/image-20250728213003606.png" alt="image-20250728213003606" style="zoom:80%;" />
$$
set号=line号 = Cache行号 \ \% \ Cache总行数
$$
先**根据Cache行号找到line**，然后**比较line的tag和地址高位的tag**，相同则匹配成功

#### 全相联映射

**set=1，所有line都在这一个set中**

全相联映射**地址结构**：

<img src="408.assets/image-20250728213849069.png" alt="image-20250728213849069" style="zoom:80%;" />

只有一个set，因此不需要中间的set号，**直接从头到尾比较line的tag和地址的tag**

#### 组相联映射

**每个set中有多个line**，具体数量等于组数，比如二路组相联映射

<img src="408.assets/image-20250728214613991.png" alt="image-20250728214613991" style="zoom:80%;" />

组相联映射**地址结构**：

<img src="408.assets/image-20250728214808192.png" alt="image-20250728214808192" style="zoom:80%;" />
$$
set号 = 组号 \ \% \ Cache总组数
$$
先**根据组号找到set**，然后**依次比较set中每一个line的tag和地址高位的tag**

> 例题：
>
> <img src="408.assets/image-20250728215946938.png" alt="image-20250728215946938" style="zoom:80%;" />
>
> 地址结构应该是：19 3 6 位
>
> 每个line的结构如下：注意**line最后的数据是整个64B，不像地址只需要3位给出offset即可**
>
> <img src="408.assets/image-20250728220126650.png" alt="image-20250728220126650" style="zoom:80%;" />
>
> <img src="408.assets/image-20250728220323231.png" alt="image-20250728220323231" style="zoom:80%;" />
>
> <img src="408.assets/image-20250728220444479.png" alt="image-20250728220444479" style="zoom:80%;" />

> **全相联命中率最高，直接映射命中率最低**

#### 替换算法

RANDOM

FIFO

**LRU：看谁最久没用**(LFU看谁用的最少)，**每个line新增一个计数位(LRU替换位)**

#### Cache一致性

一致性问题：**写数据**时，怎么**保持Cache和Memory的一致性**

**写，Cache命中**：

1. **全写法**：数据**同时写入Cache和主存**（复杂）
2. **回写法**：只写入Cache，**Cache被替换时才写入主存**

**写，Cache不命中**：

1. **写分配法**：写主存，把**主存块调入Cache**（复杂）
2. **非写分配法**：只写主存，**不把主存块调入Cache**

全写法+非写分配法；回写法+写分配法（**记住只有一个复杂即可**）

通常采用：回写法+写分配法

### 6.虚拟存储器

**虚地址=逻辑地址**：编程采用的地址

**实地址=物理地址**：实际主存单元的地址

**虚拟存储器只能采用回写法**：**虚拟地址对应的内容是辅存中的内容**，全写法会频繁访问辅存，时间开销过大

#### 页式虚拟存储器

**页表项**：**有效位(是否在内存)+脏位(是否被修改，用于回写法)+引用位(用于LRU)+物理页号**

<img src="408.assets/image-20250728223117040.png" alt="image-20250728223117040" style="zoom:80%;" />

#### 快表TLB

**SRAM**实现，**集成在CPU内部的Cache中**，目的是**减少访问次数，因为页表在内存中**

#### 页式虚拟存储流程图

<img src="408.assets/image-20250728223703097.png" alt="image-20250728223703097" style="zoom:80%;" />

<img src="408.assets/image-20250728223926858.png" alt="image-20250728223926858" style="zoom:80%;" />

<img src="408.assets/image-20250728224056795.png" alt="image-20250728224056795" style="zoom:80%;" />

#### 段式虚拟存储器

**段的长度可变**，因此段表项需要给出段长

<img src="408.assets/image-20250728224322558.png" alt="image-20250728224322558" style="zoom:80%;" />

#### 段页式虚拟存储器

每个程序对应一个段

**每个段有整数个页**

**虚地址=段号+页号+页内地址**

#### Cache vs 虚存

1. **Cache解决CPU和主存速度不匹配问题**，而**虚存是解决主存容量**
2. Cache不命中CPU还可以直接访问主存，而**虚存不命中就只能先把辅存调入主存，辅存不能和CPU直接通信**



## 第4章：指令系统

### 1.ISA

**ISA(指令集体系结构)**：

1. **指令格式**（操作码、操作数、寻址模式）
2. **寄存器架构**（通用/特殊寄存器，如PC、SP）
3. **数据类型与运算**（整数/浮点指令，如ADD、MOV）
4. **内存模型**（地址空间、字节序、对齐）
5. **控制流指令**（分支、跳转、函数调用）
6. **特权级别**（用户态/内核态权限隔离）

### 2.指令

<img src="408.assets/image-20250729114443600.png" alt="image-20250729114443600" style="zoom:80%;" />

单字长指令：指令字长=机器字长，访存一次，一个存取周期

双字长指令：指令字长=2机器字长，访存2次，2个存取周期

---

定长指令字结构：所有指令长度相等

变长指令字结构

---

零地址指令：**一般和堆栈有关**，ret

一地址指令：**另一个操作数隐式存在规定寄存器或为常数**，inc、dec

二地址指令：intel格式下，**目的操作数在中间**，add

三地址指令：**前两个操作数是原操作数**，**第三个是目的操作数**

四地址指令：**第四个操作数是下一条指令的地址**

### 3.扩展操作码

<img src="408.assets/image-20250729120056544.png" alt="image-20250729120056544" style="zoom:80%;" />

15条指令是因为要留一位到下一级，**保证指令前缀不相同**

编码方式不唯一，可根据题目需求而变

### 4.指令寻址

#### 顺序寻址

PC+1

#### 跳跃寻址

转移指令**修改PC的值**，因为CPU总是根据PC取下一条指令

### 5.数据寻址

<img src="408.assets/image-20250729121730835.png" alt="image-20250729121730835" style="zoom:80%;" />

需要新增一个**寻址特征**字段，指明数据寻址的方式

#### 隐含寻址

**另一个操作数由累加器ACC提供**

```asm
MUL  BL      ; AL * BL → 结果存 AX（隐含 AL/AX）
DIV  CL      ; AX / CL → 商存 AL，余数 AH（隐含 AX）
IN   AL, 60h ; 从端口 60h 读取数据到 AL（隐含 AL）
OUT  21h, AL ; 将 AL 的值写入端口 21h（隐含 AL）
```

#### 立即寻址

寻址特征是`#`

<img src="408.assets/image-20250729122733486.png" alt="image-20250729122733486" style="zoom:80%;" />

```asm
MOV  EAX, 42          ; 将立即数 42 存入 EAX（32位）
MOV  RCX, 0x12345678  ; 将 64 位立即数 0x12345678 存入 RCX
MOV  DL, 0xFF         ; 将 8 位立即数 0xFF 存入 DL
```

#### 直接寻址

直接给出存放操作数的地址

<img src="408.assets/image-20250729123017342.png" alt="image-20250729123017342" style="zoom:80%;" />

```asm
MOV  EAX, [0x8040000]    ; 将内存地址 0x8040000 处的 32 位数据加载到 EAX
MOV  [0x1000], BL        ; 将 BL 的值存入内存地址 0x1000
CMP  DWORD [0x2000], 42  ; 比较内存地址 0x2000 处的值与立即数 42
```

#### 间接寻址

给出的地址的内容，才是存放操作数的地址

<img src="408.assets/image-20250729123200890.png" alt="image-20250729123200890" style="zoom:80%;" />

#### 寄存器寻址

寄存器的内容是操作数

<img src="408.assets/image-20250729123302755.png" alt="image-20250729123302755" style="zoom:80%;" />

```asm
MOV  EAX, EBX      ; 将 EBX 的值复制到 EAX（32 位）
MOV  CL, DL        ; 将 DL 的值复制到 CL（8 位）
MOV  RSI, RDX      ; 将 RDX 的值复制到 RSI（64 位）
```

#### 寄存器间接寻址

寄存器的内容是存放操作数的地址

<img src="408.assets/image-20250729123401827.png" alt="image-20250729123401827" style="zoom:80%;" />

```asm
MOV  EAX, [EBX]      ; 将 EBX 寄存器指向的内存地址处的 32 位数据加载到 EAX
MOV  [EDI], CL       ; 将 CL 的值存入 EDI 寄存器指向的内存地址
CMP  DWORD [ESI], 10 ; 比较 ESI 指向的内存值与立即数 10
```

#### 相对寻址

**PC和给出的数相加**，得到存放操作数的地址，常用于**jmp**指令

<img src="408.assets/image-20250729123528495.png" alt="image-20250729123528495" style="zoom:80%;" />

```asm
JMP  0x8          ; 向前跳转到当前指令后 8 字节处
JZ   label        ; 若零标志（ZF=1）则跳转到 label（编译为相对偏移）
```

<img src="408.assets/image-20250729165047953.png" alt="image-20250729165047953" style="zoom:80%;" />

即**取出指令时，PC就会增加指令的长度**

#### 基址寻址

**基址+固定偏移**

<img src="408.assets/image-20250729165216853.png" alt="image-20250729165216853" style="zoom:80%;" />

```asm
MOV  EAX, [EBX + 8]      ; EAX = *(EBX + 8)（32位偏移）
MOV  [ECX - 4], DL       ; *(ECX - 4) = DL（8位偏移）
```

#### 变址寻址

**基址+变址\*比例因子**，常用于**数组遍历**

<img src="408.assets/image-20250729165902636.png" alt="image-20250729165902636" style="zoom:80%;" />

```asm
MOV  EDX, [EAX + ESI*4]    ; EDX = *(EAX + ESI*4)（适用于32位数组，如 int[]）
MOV  CX, [EBX + EDI*2]     ; CX = *(EBX + EDI*2)（适用于16位数组，如 short[]）
```

在数组遍历中，**A是固定值比如数组首地址，IX寄存器的值是i**

**基址寻址vs变址寻址**：**基址寻址的A可变，变址寻址的A不可变**

#### 堆栈寻址

大多数为**无操作数指令**，因为隐式使用了`SP`

#### 访存次数

**A为形式地址，其内容是EA**

**EA为有效地址，其内容是操作数**

<img src="408.assets/image-20250729171034994.png" alt="image-20250729171034994" style="zoom:80%;" />

### 6.通用寄存器组

<img src="408.assets/image-20250729171354148.png" alt="image-20250729171354148" style="zoom:80%;" />

​	`EBP`和`ESP`的用法较为特殊，其它寄存器的用法比较灵活（比如用于变量、函数传参）

### 7.汇编语言格式

分为**AT&T格式**(CSAPP采用)和**Intel格式**(考研采用)

|        区别点         |         AT&T 格式          |          Intel 格式           |            举例对比（相同功能指令）            |
| :-------------------: | :------------------------: | :---------------------------: | :--------------------------------------------: |
|    **大小写敏感**     |       只能用小写字母       |     不敏感（大小写均可）      |      `movl %eax, %ebx` vs `MOV EAX, EBX`       |
|    **操作数顺序**     |    源→目的（从左到右）     |      目的←源（从右到左）      |        `addl $5, %eax` vs `ADD EAX, 5`         |
| **寄存器/立即数前缀** | 寄存器加 `%`，立即数加 `$` |            无前缀             |       `movl $42, %ecx` vs `MOV ECX, 42`        |
|   **内存寻址符号**    |         使用 `()`          |           使用 `[]`           |    `movl (%edx), %eax` vs `MOV EAX, [EDX]`     |
|   **复杂寻址格式**    | `disp(base, index, scale)` | `[base + index*scale + disp]` |    `8(%edx,%eax,2)` vs `[EDX + EAX*2 + 8]`     |
|   **数据长度指定**    |   操作码后加 `b`/`w`/`l`   |    显式注明 `byte ptr` 等     | `movb %al, (%ebx)` vs `MOV BYTE PTR [EBX], AL` |

### 8.算数和逻辑运算指令

#### mov

**两个操作数不能都是内存**

#### push

**先将`ESP`减4**

#### pop

**先出栈，然后`ESP`加4**

#### add/sub

**结果保存到第一个操作数(目的操作数)**

注意减法是**前减后**

``` asm
sub eax, 10	; eax = eax - 10，前减后
```

#### inc/dec

单操作数

#### imul

**有符号整数乘法**

**单操作数**，**被乘数隐式存储在`eax`，结果存储在`edx:eax`**

**双操作数**，**结果只保留低位**，并把低位存到第一个操作数(**第一个操作数必须是寄存器**)

**三操作数**，后两个乘积存到第一个操作数(**第一个操作数必须是寄存器**)

#### idiv

**有符号整数除法**

**单操作数**，**被除数隐式存储在`edx:eax`，商存储在`eax`，余数存储在`edx`**

#### and/or/xor

结果存到第一个操作数

#### not

取反

#### neg

取相反数

#### shl/sal/shr/sar

a->arithmetic，中间为`a`表示算数左移/右移

### 9.控制流指令

`IP`指针不能直接操作，只能自动更新

#### jmp

#### jcondition

#### cmp/test

**都只影响条件码**

`cmp`：功能相当于`sub`

`test`：功能相当于`and`

#### call/ret

`call`：先把**当前PC入栈**，然后跳转

`ret`：先**出栈赋给PC**，返回调用位置

### 10.过程调用

#### 调用者保存寄存器

`eax, ecx, edx`

P调用Q，由**P将这些寄存器保存到栈中**，返回后**由P恢复这些寄存器的值**

#### 被调用者保存寄存器

`ebx, esi, edi`

P调用Q，由**Q将这些寄存器保存到栈中**，返回前**由Q恢复这些寄存器的值**

#### ebp和esp

**`ebp`指示栈帧起始位置(高地址)**，**`esp`指示栈顶(低地址)**

```asm
section .text
global _start

_start:
    CALL func      ; 1. CALL 隐含 PUSH 返回地址（ESP -= 4）
    MOV  EAX, 1    ; 4. 退出程序
    INT  0x80

func:
    PUSH EBP       ; 2. 保存调用者的 EBP（ESP -= 4）
    MOV  EBP, ESP  ; 3. 设置当前栈帧基址（EBP = ESP）
    SUB  ESP, 8    ; 为局部变量分配 8 字节（ESP -= 8）

    ; 局部变量 [EBP-4] 和 [EBP-8]
    MOV  DWORD [EBP-4], 10  ; 局部变量1 = 10
    MOV  DWORD [EBP-8], 20  ; 局部变量2 = 20

    ADD  ESP, 8    ; 释放局部变量空间（ESP += 8）
    POP  EBP       ; 恢复调用者的 EBP（ESP += 4）
    RET            ; 返回（隐含 POP EIP，ESP += 4）
```

**可以看到`ebp`在`esp`的上面，`ebp > esp`，帧的范围从小到大是 `[esp, ebp]`**

<img src="408.assets/image-20250729180031391.png" alt="image-20250729180031391" style="zoom:80%;" />

### 11.CISC和RISC

**CISC(复杂指令系统计算机)、RISC(精简指令系统计算机)**

![image-20250729183019019](408.assets/image-20250729183019019.png)



## 第5章：中央处理器

### 1.CPU的组成

CPU=运算器+控制器

#### 运算器

ALU+暂存寄存器+ACC+GPRs+PSW+移位寄存器(SR)+计数器(CT)

#### 控制器

PC+IR+指令译码器(ID)

#### 用户可见寄存器

**GPRs、PSW、PC**

#### 用户不可见寄存器

**MAR、MDR、IR、暂存寄存器、ACC、移位寄存器(SR)**

### 2.三个周期

#### 时钟周期

$$
T_{时钟}=\frac{1}{主频}
$$

#### 机器周期

$$
1机器周期 = n个时钟周期
$$

#### 指令周期

一条指令执行完成的时间，等于**多个机器周期**

<img src="408.assets/image-20250729213038247.png" alt="image-20250729213038247" style="zoom:80%;" />

### 3.指令周期的数据流

#### 取指周期

从**主存中取出指令**放到**IR**中

<img src="408.assets/image-20250729213642303.png" alt="image-20250729213642303" style="zoom:80%;" />

#### 间址周期

**取操作数的有效地址**

<img src="408.assets/image-20250729213914430.png" alt="image-20250729213914430" style="zoom:80%;" />

#### 执行周期

**取操作数**

#### 中断周期

CPU在**每条指令结束后，都要发中断查询信号**

<img src="408.assets/image-20250729214220595.png" alt="image-20250729214220595" style="zoom:80%;" />

### 4.指令执行方案

#### 单周期处理器

**所有指令都在一个时钟周期完成**，CPI=1

#### 多周期处理器

**指令需要多个时钟周期**，CPI>1

#### 流水线处理器

每个周期启动一条指令，每个周期内执行不同指令的不同阶段

### 5.数据通路

数据通路=**指令执行过程中经过的部件**，这些部件分为组合逻辑元件和时序逻辑元件

#### 组合逻辑元件

组合逻辑元件**不含存储信号的记忆单元**，包括**加法器、算术逻辑单元(ALU)、译码器、多路选择器、三态门**

<img src="408.assets/image-20250729215416199.png" alt="image-20250729215416199" style="zoom:80%;" />

**多路选择器**：根据**Select信号选择哪个信号被输出**

**三态门**：**EN=1，in=out；EN=0，阻隔态**

#### 时序逻辑元件

组合逻辑元件**不含存储信号的记忆单元**，输出不仅和输入有关，**还和之前的输入有关**

#### 单总线方式

<img src="408.assets/image-20250729221024141.png" alt="image-20250729221024141" style="zoom:80%;" />

**能输出到总线的部件均通过一个三态门与内部总线相连**，控制该部件与内部总线间的连接与断开

<img src="408.assets/image-20250729221353312.png" alt="image-20250729221353312" style="zoom:80%;" />

<img src="408.assets/image-20250729221506473.png" alt="image-20250729221506473" style="zoom:80%;" />

### 6.数据通路中的控制信号

#### 寄存器->总线

```asm
(PC)->MAR	;PCout 和 MARin 有效，PC->MAR
```

#### 从主存取数据

```asm
(PC)->MAR						;PCout 和 MARin 有效，现行指令地址→MAR
MEM(MAR)->MDR, (PC) + 1->PC		;MDRin 有效，cu 发出读命令，取出指令后 PC+1
(MDR)->IR						;MDRout 和 IRin 有效，现行指令→IR
```

#### 数据写入主存

```asm
(R1)->MDR		;R1out 和 MDRin 有效
(R2)->MAR		;R2out 和 MARin 有效
MDR->MEM(MAR)	;MDRout 有效，cu 发出写命令
```

#### ALU执行运算

在单总线数据通路中，**每一时刻总线上只有一个数据有效**。因为 ALU 是一个没有存储功能的组合逻辑元件，在其执行运算时必须保持两个输入端同时有效，所以**先将一个操作数经内部总线送入暂存器 Y 保存**，Y 的内容在 ALU 的左输入端始终有效，再将另一个操作数经内部总线直接送到 ALU 的右输入端。此外，**ALU 的输出端也不能直接与总线相连**，否则其输出会通过总线反馈到输入端，影响运算结果，因此将**运算结果暂存在暂存器 Z 中**：

```asm
(R1)->Y			;Rlout 和 Yin 有效，操作数→Y
(ACC)+(Y)->Z	;ACCout 和 ALUin 有效，CU 向 ALU 发出加命令，结果→z
(Z)->ACC		;Zout 和 ACCin 有效，结果→ACC
```

#### 修改PC的值

```asm
AD(IR)->PC		;IRout和PCin有效
```

### 7.硬布线控制器

> 控制器可分为硬布线控制器和微程序控制器

硬布线控制器由**组合门电路**和**触发器**构成

其**CU的输出**来自于：**操作码译码电路，节拍发生器，执行单元的反馈信息(标志)**

**RISC采用硬布线控制器**

### 8.微程序控制器

#### 基本概念

$$
机器指令=1微程序 \\\\
微程序=n微指令 \\\\
微指令=n微命令 \\\\
1微命令对应1微操作
$$

**微命令**有**相容性**和**互斥性**

硬布线控制器也有微命令和微操作的，非微程序控制器独有

微周期：取出并执行一条微指令的全部时间

**微程序是透明的**

#### 组成结构

<img src="408.assets/image-20250730115744993.png" alt="image-20250730115744993" style="zoom:80%;" />

**控制存储器CM**，存储**微程序**，**CPU内部**，**ROM**实现

> 主存储器，存储程序和数据，CPU外部，DRAM实现

**微指令地址寄存器$\mu PC$**：微指令在控制存储器中的微地址

**微指令寄存器$\mu IR$**：存放待执行的微指令

**工作流程**：

```asm
1. 取指微程序入口地址->uPC
2. uPC->CM->uIR	;取指微程序送入uIR
3. 目标微指令->uPC
4. uPC->CM->uIR	;目标微指令送入uIR执行
5. 重复上述步骤，执行下一条微指令
```

可**将取值相关的微指令合并为一个微程序**，以便每次执行微指令时都调用

#### 微指令编码方式

1. **直接编码方式**：**每一位都代表一个微命令**

	<img src="408.assets/image-20250730120524803.png" alt="image-20250730120524803" style="zoom:80%;" />

2. **字段直接编码方式**：（重要）

	把控制字段分割为若干小段

	**互斥微命令放到同一段，非互斥微命令放到不同段**

	<img src="408.assets/image-20250730120825151.png" alt="image-20250730120825151" style="zoom:80%;" />

	**每个小段要留出一位，表示该段所有微命令都不执行**

#### 微指令的格式

1. **水平型微指令**：上述的**直接编码方式和字段直接编码方式均属于水平型微指令**

	**1水平型微指令=n并行执行的微命令**

	<img src="408.assets/image-20250730123413572.png" alt="image-20250730123413572" style="zoom:80%;" />

2. **垂直型微指令**：只能定义和执行**一条微命令**

	<img src="408.assets/image-20250730123614635.png" alt="image-20250730123614635" style="zoom:80%;" />

#### 两种控制器的比较

<img src="408.assets/image-20250730123759555.png" alt="image-20250730123759555" style="zoom:80%;" />

### 9.异常和中断

#### 异常和中断的区别

|    对比维度     |             异常（Exception）              |                中断（Interrupt）                |
| :-------------: | :----------------------------------------: | :---------------------------------------------: |
|   **触发源**    |   CPU**内部执行指令**时产生的错误或事件    |       **外部硬件**设备或定时器发出的信号        |
|   **同步性**    |          同步（与当前指令强相关）          |        异步（与当前指令无关，随机发生）         |
|  **典型场景**   |     除零错误、缺页异常、非法指令、溢出     |        键盘输入、磁盘IO完成、定时器到期         |
|  **响应时机**   |        立即处理（发生在指令执行中）        |  通常在指令边界处理（指令周期的**中断周期**）   |
| **是否可屏蔽**  |            不可屏蔽（必须处理）            | 可屏蔽（通过中断控制器配置，如CLI指令关闭中断） |
|  **返回地址**   | 可能指向故障指令或下一条指令（如缺页异常） |            始终指向下一条未执行指令             |
| **处理优先级**  |          高（直接影响程序正确性）          |         依赖中断优先级（如硬件IRQ等级）         |
|  **硬件支持**   |       由CPU**内部异常处理单元**管理        |       依赖**中断控制器**（如APIC、8259A）       |
|  **典型用途**   |     处理程序错误、内存管理、特权级切换     |          响应外部事件、实现多任务调度           |
| **示例（x86）** |    `#DE`（除零异常）、`#PF`（缺页异常）    |    `IRQ0`（定时器中断）、`IRQ1`（键盘中断）     |

**所有异常和中断都是由硬件检测的**

#### 异常的分类

|     异常类型      |             触发条件             |           处理行为           |    典型示例（x86）    | 是否可恢复 | 属于     |
| :---------------: | :------------------------------: | :--------------------------: | :-------------------: | :--------: | -------- |
| **故障（Fault）** |      指令执行**检测到错误**      | 修正错误后**重新执行原指令** |   `#PF`（缺页异常）   |     是     | 软件中断 |
| **自陷（Trap）**  |      指令执行后**主动触发**      |    继续执行**下一条指令**    |  `INT 3`（调试断点）  |     是     | 软件中断 |
| **中止（Abort）** | **严重错误**（无法定位具体指令） |    **终止程序**或系统复位    | `#MC`（机器检查异常） |     否     | 硬件中断 |

#### 中断的分类

CPU **每执行完一条指令就检查中断请求信号线**，若检测到中断请求，则进入中断响应周期

**可屏蔽中断**：可屏蔽中断请求线INTR发送给CPU

**不可屏蔽中断**：不可屏蔽中断请求线NMI发送给CPU

#### 异常和中断的处理过程

1. **关中断**：**禁止响应新的中断**，IF触发器=0
2. **保存断点和程序状态**：当前**程序断点以及PSW**保存到**栈**
3. **识别异常和中断并跳到相应处理程序**：**异常采用软件识别**，**中断软件硬件识别均可**

<img src="408.assets/image-20250730171151716.png" alt="image-20250730171151716" style="zoom:80%;" />

### 10.指令流水线

#### 概念

|     维度     |          流水线技术          |          超标量处理机          |
| :----------: | :--------------------------: | :----------------------------: |
| **并行方式** | 时间并行（**指令步骤重叠**） | 空间并行（**多指令同时执行**） |
| **硬件成本** |              低              |       高（需多执行单元）       |

1. **取指**（IF，instruction fetch）：从指令存储器或 Cache 中取指令
2. **译码**/读寄存器（ID，instruction decode）：对指令进行译码，同时从寄存器中取操作数
3. **执行**/计算地址（EX，excute）：执行运算或计算地址
4. **访存**（MEM，memory）：对存储器进行读/写操作
5. **写回**（WB，write back）：将指令执行结果写回寄存器

#### 流水线的实现

<img src="408.assets/image-20250730172708408.png" alt="image-20250730172708408" style="zoom:80%;" />

每段后面有一个**流水段寄存器**，用于锁存本段处理完的数据，防止数据冲突

### 11.流水线的冒险

<img src="408.assets/image-20250730174100310.png" alt="image-20250730174100310" style="zoom:80%;" />

#### 结构冒险

不同指令在**同一时刻争用同一功能部件**而形成的冲突

<img src="408.assets/image-20250730174219131.png" alt="image-20250730174219131" style="zoom:80%;" />

t=4时，**第一条指令的MEM和第四条指令的ID都要访存**

**解决方法**：

1. 将**第四条指令暂停一个时钟周期**
2. 设置多个功能部件
3. **数据Cache和指令Cache分离**

#### 数据冒险

**后面指令引用前面指令的结果，前面指令的结果还没产生**

```asm
add R1, R2, R3
sub R4, R1, R5
```

<img src="408.assets/image-20250730175249912.png" alt="image-20250730175249912" style="zoom:80%;" />

**解决方法**：

1. **延迟读指令(3个时钟周期)**：

	<img src="408.assets/image-20250730175344644.png" alt="image-20250730175344644" style="zoom:80%;" />

2. **旁路转发技术**：

	R1在EX阶段已得出，**直接从EX的流水段寄存器中取出送到ALU的输入端**

	<img src="408.assets/image-20250730180116439.png" alt="image-20250730180116439" style="zoom:80%;" />

3. **load-use型数据冒险**：

	**load指令要在MEM结束后才能得到值**，而**op指令在EX就需要数据**，**来不及使用旁路转发技术**

	可**将op指令阻塞一个时钟周期，再使用旁路转发技术**

	```asm
	load, r2, l2(r1)
	add r4, r3, r2
	```

	<img src="408.assets/image-20250730180840226.png" alt="image-20250730180840226" style="zoom:80%;" />

#### 控制冒险

**不知道是否要跳转，因为MEM阶段结束才会更新PC的值**

**解决方法**：

1. **阻塞后续指令**，延迟损失时间片C

	<img src="408.assets/image-20250730181053342.png" alt="image-20250730181053342" style="zoom:80%;" />

2. 对转移指令进行**分支预测**，预测失败则丢弃当前分支，重新执行正确分支

### 12.流水线的性能标准

**吞吐率(TP)**：
$$
\mathrm{TP}=\frac{n}{T_k} \\\\
\mathrm{TP}=\frac{n}{(k+n-1)\Delta t}
$$
**加速比(S)**：
$$
S=\frac{T_0}{T_k} \\\\
T_0\text{表示不使用流水线的总时间；}T_k\text{表示使用流水线的总时间} \\\\
S=\frac{kn\Delta t}{(k+n-1)\Delta t}=\frac{kn}{k+n-1}
$$

### 13.高级流水线技术

#### 超标量流水线技术

<img src="408.assets/image-20250730184004071.png" alt="image-20250730184004071" style="zoom:80%;" />

#### 超长指令字技术

把**多条能并行执行的指令组合成一个超长的指令字**

#### 超流水线技术

**提高流水线级数**(5->10/15或更多)

### 14.多处理器

#### 架构

| 架构类型 |                全称                |                          核心特点                          |  数据/指令流关系  |        典型应用场景         |              代表硬件               |
| :------: | :--------------------------------: | :--------------------------------------------------------: | :---------------: | :-------------------------: | :---------------------------------: |
| **SISD** |   Single Instruction Single Data   |             单指令流单数据流，**串行执行指令**             | 1指令流 + 1数据流 | 传统单核CPU、简单嵌入式系统 |      Intel 8086、ARM Cortex-M       |
| **SIMD** |  Single Instruction Multiple Data  |  单指令流多数据流，一**条指令并行处理多个数据**（向量化）  | 1指令流 + N数据流 | 图像处理、科学计算、AI推理  |  Intel AVX/SSE、GPU（Shader Core）  |
| **MISD** |  Multiple Instruction Single Data  | 多指令流单数据流，**多条指令处理同一数据**（极少实际应用） | N指令流 + 1数据流 | 容错计算（如航天冗余控制）  |    **理论架构，无广泛商用硬件**     |
| **MIMD** | Multiple Instruction Multiple Data |      多指令流多数据流，**完全并行**（多核/多机协作）       | N指令流 + N数据流 | 分布式系统、多核CPU、云计算 | Intel Core i7、AMD EPYC、NVIDIA GPU |

#### 硬件多线程

|      对比维度      |    细粒度多线程（FGMT）    |       粗粒度多线程（CGMT）       |          同时多线程（SMT）           |
| :----------------: | :------------------------: | :------------------------------: | :----------------------------------: |
|  **线程切换时机**  |   **每时钟周期切换线程**   | **线程阻塞（如缓存缺失）时切换** |  **每周期动态分配指令槽给多个线程**  |
|    **并行粒度**    |       指令级（极细）       |          任务级（较粗）          |         指令级（混合细粒度）         |
|    **硬件需求**    | 多组寄存器，轻量级切换逻辑 |    单组寄存器，高延迟切换逻辑    | 多组寄存器、乱序执行引擎、复杂调度器 |
|   **吞吐量提升**   |    高（隐藏单周期延迟）    |       中（隐藏长延迟阻塞）       |       极高（充分利用执行单元）       |
|    **资源冲突**    |   低（线程轮流使用资源）   |         中（切换频率低）         |       高（多线程竞争执行单元）       |
|    **典型应用**    |  高延迟隐藏（如内存访问）  |      长延迟任务（如IO阻塞）      |       通用计算（如多任务并行）       |
|    **代表架构**    |     Tera MTA（已淘汰）     |        Sun UltraSPARC T1         |    Intel Hyper-Threading、AMD SMT    |
| **时钟周期利用率** |      高（无空闲周期）      |        中（切换时有开销）        |         极高（动态填充气泡）         |
|   **编程复杂度**   |     低（硬件自动调度）     |         中（需任务划分）         |         高（需考虑资源竞争）         |

#### 多核CPU

<img src="408.assets/image-20250730185041683.png" alt="image-20250730185041683" style="zoom:80%;" />

**Cache独立，内存共享**

**使用多线程充分利用每个核**

**真正意义上的并行**



## 第6章：总线

### 1.概念

**分时**：**同一时间只能有一个主设备控制总线**

**共享**：总线上能连多个设备，它们共享总线上的信息

主设备：获得总线控制权的设备

从设备：只能被动响应主设备

总线的**特征**：机械特征，电气特征，功能特征

### 2.总线的分类

#### 片内总线

**芯片内部**的总线

#### 系统总线

各**功能部件(CPU、主存、IO接口)间**相互连接的总线

**数据总线**：数据、指令和中断类型号，**双向**

**地址总线**：主存单元或 IO 端口的地址，**单向**

**控制总线**：各种命令、反馈和定时信号

#### IO总线

连接中低速的IO设备，如 **USB、PCI 总线**

#### 通信总线

**计算机系统之间**或计算机系统**与其他系统(如远程通信设备、测试设备)之间**传送信息的总线，也称**外部总线**

### 3.系统总线的结构

#### 单总线结构

单总线结构将**CPU、主存、IO设备**(通过IO接口)都挂在**一组**总线上

<img src="408.assets/image-20250730212012330.png" alt="image-20250730212012330" style="zoom:80%;" />

**注意**：**“单”不是一条总线**，而是**一组**总线

#### 双总线结构

一条**主存总线**：**CPU、主存和通道之间**传送数据

一条**IO总线**：**多个外部设备与通道之间**传送数据

#### 三总线结构

一条**主存总线**：**CPU、主存和通道之间**传送数据

一条**IO总线**：**多个外部设备与通道之间**传送数据

一条**DMA总线**：**内存和高速外设之间**直接传送数据

> DMA=Direct Memory Access，直接存储器访问

#### 4.总线的性能指标

1. 总线时钟周期=时钟周期
2. 总线时钟频率
3. 总线传输周期：一次总线操作所需的总时间
4. **总线工作频率**
5. **总线宽度**：传输的**数据位数**，32根=32位总线
6. **总线带宽**：**单位时间**最多**传输的位数**，B/s，**总线带宽 = 总线工作频率×(总线宽度/8)**
7. 总线复用：一根总线用做不同功能，比如**地址/数据复用**

### 5.总线事务

请求阶段：主设备(**CPU或DMA**)发出总线传输请求

仲裁阶段：下一个传输周期的总线使用权授予某个申请者

寻址阶段：给出要访问的从设备地址及有关命令

传输阶段：主模块和从模块进行数据交换

释放阶段：让出总线使用权

---

|              |                突发传送（Burst Transfer）                 |        非突发传送（Non-Burst Transfer）        |
| :----------: | :-------------------------------------------------------: | :--------------------------------------------: |
|   **定义**   | 在**单次操作中连续传输多个数据单元**（地址自动递增/固定） | **每次操作仅传输单个数据单元**，需重复发起请求 |
| **传输效率** |                高（减少地址/控制信号开销）                |         低（每次传输均需完整握手流程）         |
| **总线占用** |              短时集中占用，减少总线切换频率               |        频繁占用/释放总线，增加仲裁开销         |
| **典型场景** |           高速连续数据（如视频流、DDR内存读写）           |    随机小数据（如寄存器配置、低速外设通信）    |

**突发传送**：**单次握手，连续传输**

```
| 地址/控制信号 | 数据1 | 数据2 | 数据3 | ... | 数据N | （单次握手，连续传输）
```

**非突发传送**：**每次传输独立握手**

```
| 地址/控制信号 | 数据1 | 地址/控制信号 | 数据2 | ... | （每次传输独立握手）
```

### 6.总线定时

|                |                           工作原理                           |                       特点                       |               适用场景               |                            优缺点                            |
| :------------: | :----------------------------------------------------------: | :----------------------------------------------: | :----------------------------------: | :----------------------------------------------------------: |
|  **同步定时**  | 所有操作由**统一的时钟信号**（CLK）驱动，信号在时钟边沿采样。 |    - 严格时序控制 - 信号简单 - 依赖时钟稳定性    |      高速片上总线（如AXI、AHB）      | **优点**：设计简单，适合高频 **缺点**：时钟偏移（Skew）影响可靠性 |
|  **异步定时**  |    无全局时钟，通过**握手信号**（如`REQ/ACK`）协调传输。     | - **自适应设备速度** - 无时钟约束 - 控制逻辑复杂 |       低速外设（如UART、I2C）        | **优点**：兼容不同速度设备 **缺点**：吞吐量低，延迟不可预测  |
| **半同步定时** | **结合同步时钟和异步握手**（如时钟+`WAIT`信号），设备可请求延长周期。 |      - 折中同步与异步优点 - 可动态调整时序       |   中速设备（如SDRAM、早期PCI总线）   |    **优点**：灵活性高 **缺点**：需额外控制线（如`WAIT`）     |
| **分离式定时** | 将传输分解为**请求（Request）和应答（Response）两个阶段**，中间可插入其他操作。 |   - 高总线利用率 - 支持乱序完成 - 控制逻辑复杂   | 高性能总线（如PCIe、HyperTransport） | **优点**：隐藏延迟，提升并行度 **缺点**：硬件开销大（需标签匹配逻辑） |



## 第7章：IO系统

### 1.IO接口

**实现主机与外部设备的信息转换**

> <img src="408.assets/image-20250730221414428.png" alt="image-20250730221414428" style="zoom:80%;" />
>
> <img src="408.assets/image-20250730221426912.png" alt="image-20250730221426912" style="zoom:80%;" />

<img src="408.assets/image-20250730221848147.png" alt="image-20250730221848147" style="zoom:80%;" />

数据线：读/写数据、状态信息、控制信息和中断类型号

地址线：要访问的IO接口中的寄存器的地址

控制线：读/写控制信号

### 2.IO端口

**IO端口**：IO接口电路中**可被 CPU 直接访问的寄存器**，分为**数据、状态、控制端口**

IO端口要想能够被 CPU 访问，就必须要**对各个IO端口进行编址**，**每个端口对应一个端口地址**

**独立编址**：IO端口的地址空间和主存地址空间独立

**统一编址**：IO端口的地址和主存其它单元的地址在同一内存地址空间的不同位置

### 3.程序查询方式

**直接由 CPU 执行程序实现**

**CPU 周期或持续地查询设备状态**，**直到外设准备就绪**

<img src="408.assets/image-20250730223357830.png" alt="image-20250730223357830" style="zoom:80%;" />

<img src="408.assets/image-20250730223622762.png" alt="image-20250730223622762" style="zoom:80%;" />

<img src="408.assets/image-20250730223649280.png" alt="image-20250730223649280" style="zoom:80%;" />

### 4.程序中断方式

<img src="408.assets/image-20250730223934408.png" alt="image-20250730223934408" style="zoom:80%;" />

<img src="408.assets/image-20250730225021733.png" alt="image-20250730225021733" style="zoom:80%;" />

#### 中断工作流程

1. 中断系统需**对每个中断源设置中断请求标记触发器**，当其状态为“1”时，表示该中断源有请求

2. **中断响应优先级**是指 CPU 响应中断请求的先后顺序

	> <img src="408.assets/image-20250730225353416.png" alt="image-20250730225353416" style="zoom:80%;" />

3. **CPU响应中断的条件**：

	<img src="408.assets/image-20250730225507166.png" alt="image-20250730225507166" style="zoom:80%;" />

4. **中断响应过程**：

	1. 关中断
	2. 保存断点(PC, PSW)
	3. 中断服务程序

5. **中断向量**：

	中断向量表的表项：`中断类型号:中断向量`，中断向量=对应中断服务程序入口地址

<img src="408.assets/image-20250730230014351.png" alt="image-20250730230014351" style="zoom:80%;" />

**现场**：**用户可见寄存器**

第二个关中断的作用：**防止恢复线程和屏蔽字时被打扰**

#### 中断屏蔽字

**每个中断源对应中断屏蔽字寄存器中的一位**，**1表示屏蔽，0表示正常请求**

中断屏蔽只在 CPU 运行中断服务程序时才有用，其并**不能改变 CPU 运行主程序时的中断响应优先级**

> **先处理中断响应优先级高的**，处理时进入中断服务程序，**发现其被屏蔽，这时才会去换另一个**
>
> 图的形式是**先处理中断响应优先级高的一小会儿，然后立马换成另一个**

<img src="408.assets/image-20250730232016643.png" alt="image-20250730232016643" style="zoom:80%;" />

<img src="408.assets/image-20250730232240102.png" alt="image-20250730232240102" style="zoom:80%;" />

<img src="408.assets/image-20250730232314266.png" alt="image-20250730232314266" style="zoom:80%;" />

### 5.DMA方式

DMA方式在**外设与内存**之间开辟了一条“**DMA通路**”，**信息传送不再经过 CPU**，**不需要保护、恢复 CPU 现场**等烦琐操作

#### DMA的工作过程

1. **预处理**：CPU 完成一些必要的准备工作，由 **DMA 控制器向 CPU 发总线请求**
2. **数据传送**：DMA控制器接管总线后，在**设备接口和主存之间**进行数据传送，**完全由DMA(硬件)控制器控制**
3. **后处理**：传送结束后，**DMA 控制器向 CPU 发送中断信号**，做结束处理

<img src="408.assets/image-20250730234032112.png" alt="image-20250730234032112" style="zoom:80%;" />

#### DMA和CPU访存冲突

解决方法：

1. **停止CPU访存**

	<img src="408.assets/image-20250730233522615.png" alt="image-20250730233522615" style="zoom:80%;" />

2. **周期挪用**：如果**CPU正在访存，则必须等CPU完成当前的存取周期，再将总线让出**

	<img src="408.assets/image-20250730233631197.png" alt="image-20250730233631197" style="zoom:80%;" />

3. **DMA和CPU交替访存**：**CPU的工作周期分为两个时间片**

	<img src="408.assets/image-20250730233905778.png" alt="image-20250730233905778" style="zoom:80%;" />

#### DMA和中断的比较

|     对比维度     |               DMA方式                |            中断方式            |
| :--------------: | :----------------------------------: | :----------------------------: |
| **程序是否中断** |      ❌ 不中断当前程序，偷偷干活      |   ✅ 需暂停程序，跳转处理中断   |
|   **响应时机**   |     随时响应（任意机器周期结束）     |   必须等一条指令执行完才响应   |
| **CPU是否干预**  |     ❌ 完全交给DMA控制器，CPU喝茶     |     ✅ CPU亲自处理数据搬运      |
| **数据传输速率** | ⚡ 高速（硬件直连内存，适合大批数据） |    🐢 低速（靠CPU一条条搬）     |
|    **优先级**    |      🏆 比中断更高（抢总线优先）      |          🥈 优先级较低          |
|   **适用场景**   |    硬盘读写、显卡传数据等"体力活"    | 键盘输入、异常处理等"紧急小事" |
|   **硬件支持**   |       需DMA控制器（额外硬件）        |      只需CPU和中断控制器       |
| **数据传送机制** |     🛠️ 硬件自动搬运（内存↔外设）      |  📝 靠程序指令搬运（CPU参与）   |
