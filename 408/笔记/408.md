# 数据结构

## 第1章：绪论

### 1.数据结构

#### 数据

- **定义**：就是信息的原始素材，可以是数字、文字、符号等
- **例子**：`3, "苹果", 3.14, 'A'` 这些都是数据，但它们是零散的、无意义的

#### 数据元素

- **定义**：数据的基本单位（就像组成表格的"一行"）
- **例子**：一个学生的信息（`学号:101，姓名:张三，年龄:20`）就是一个数据元素

#### 数据对象

- **定义**：同一类数据元素的集合（类似"`全班花名册`"）
- **例子**：全班50个学生的信息合起来就是一个数据对象

#### 数据类型

- **定义**：数据的种类，决定了能对它做什么操作（比如数字能加减，文字不能）。
- 例子：
	- `int`（整数类型）：可以加减乘除。
	- `string`（字符串类型）：可以拼接、截取。

#### 数据结构

- **定义**：数据元素之间的组织方式，目的是高效存取或操作。
- 例子：
	- **数组**：像一排连续盒子，快速按编号找东西。
	- **链表**：像手拉手的小朋友，插入删除灵活但查找慢。
	- **树**：像家族家谱，适合表达层级关系。

> - **数据**：`"张三", 20, "李四", 19`（零散信息）
> - **数据元素**：`{"姓名":"张三", "年龄":20}`（一个学生的完整信息）
> - **数据对象**：全班学生的信息集合（所有数据元素放一起）
> - **数据类型**：年龄是`int`，姓名是`string`（规定怎么存、怎么算）
> - **数据结构**：用**数组**存学生（快速查第n个），或用**链表**存（方便插班生）

> **数据**和**数据元素**是原材料，**数据结构**是包装盒

#### 数据结构三要素

1. **逻辑结构**：数据元素之间**一对一、一对多、多对多**的关系（比如**有序表**）
2. **存储结构**：**物理空间**中的存储方法（比如**顺序、链式、索引、散列存储**）
3. 数据的运算

> 区别逻辑结构和物理结构：从名字里无法得出物理存储方式，则为逻辑结构，否则是存储结构
>
> 比如线性表可以顺序或链式存储，为逻辑结构
>
> 而顺序表的物理空间连续，为存储结构

### 2.算法

#### 五个特征

1. 有穷性
2. 确定性
3. 可行性：算法的每条操作都可以实现的
4. 输入
5. 输出

#### 时间复杂度

一般考虑最坏情况

#### 空间复杂度

额外空间



## 第2章：线性表

### 1.线性表

线性表是**逻辑结构**，可**顺序或链式存储**

有前驱和后继

### 2.顺序表

逻辑顺序和物理顺序相同

**空间固定，满了需要扩容**

**随机访问**

结点只存储数据，**不存储数据之间的关系**

### 3.链表

**注意链表的头结点不存储数据，只为方便遍历和插入**

**插入删除的时间复杂度是$O(n)$，因为要找前一个结点**

#### 双链表

**可以在$O(1)$复杂度内完成插入删除**（不用遍历找前一个结点）

#### 循环链表

**尾结点的next是头结点，而不是$a_1$**

#### 静态链表

用**表格**的形式表示链表，以`next=-1`作为结束标志



## 第3章：栈与队列

### 1.卡特兰数

$$
n个元素进栈，有\frac{1}{n+1}C^n_{2n}种出栈排列 \\\\
C_0=1\\\\
C_1=1\\\\
C_2=2\\\\
C_3=5\\\\
C_4=14
$$

> 注意：这里的n个元素进栈是有顺序的，比如以`123`的顺序进栈，但是出栈的顺序有`123，132，213，231，321`五种

### 2.顺序栈

逻辑结构是线性表

初始时设置`S.top=-1`

### 3.共享栈

<img src="408.assets/image-20250723160242276.png" alt="image-20250723160242276" style="zoom:80%;" />

**降低上溢风险**，因为共享栈更大，只有整个空间被占满才会上溢

**栈满条件**：

1. 起始指针为`-1和MaxSize`，表示**已被占用的位置**，`top1-top0=1`
2. 起始指针为`0和MaxSize-1`，表示**下一个将被占用的位置**，两指针以“`top0top1`”相遇时并不会栈满，而是以“`top1top0`”形式相遇时才会栈满，因此栈满条件为`top0-top1=1`

### 4.链栈

<img src="408.assets/image-20250723160823174.png" alt="image-20250723160823174" style="zoom:80%;" />

链栈**不会上溢**

**没有头结点**

**所有操作在表头完成**

### 5.队列

逻辑结构是线性表

**尾进头出**

**front指向队头，rear指向队尾的下一个元素**

初始时`front=rear=0`

<img src="408.assets/image-20250723161207003.png" alt="image-20250723161207003" style="zoom:80%;" />

### 6.循环队列

<img src="408.assets/image-20250723161918601.png" alt="image-20250723161918601" style="zoom:80%;" />

循环队列**以数组的形式存储**

循环队列是**物理结构**

由于判断队满和队空的条件均为`front=rear`，因此采取下面三种方式区分栈满和栈空

1. 牺牲一个存储单元`(rear+1)%MaxSize=front`栈满
2. 引入`size`
3. 引入`tag`，`tag=1`栈满

### 7.链队列

单链表，头指针指向**头结点**，尾指针指向最后一个结点

注意，出队时，如果只剩最后一个结点，则要额外把`rear`移动到头结点和`front`重合，以便通过`front=rear`判断队空

<img src="408.assets/image-20250723163055554.png" alt="image-20250723163055554" style="zoom:80%;" />

### 8.双端队列

<img src="408.assets/image-20250723165305433.png" alt="image-20250723165305433" style="zoom:80%;" />

输出受限的双端队列：

<img src="408.assets/image-20250723165420971.png" alt="image-20250723165420971" style="zoom:80%;" />

输入受限的双端队列：

<img src="408.assets/image-20250723165451458.png" alt="image-20250723165451458" style="zoom:80%;" />

> 输入序列1234
>
> 对于输出受限，预得到4213，先从左右插入得到4213：`1->21->213->4213`，全部左出
>
> 对于输入受限，预得到4132，先从一端插入1234，然后从两端取出：`1234->123->23->3`

### 9.栈与队列的应用

#### 括号匹配

遍历，左括号入栈，右括号则去匹配栈顶

#### 后缀表达式和表达式求值

也称**逆波兰式**

**中缀转后缀**：有一个`op`栈暂存符号

<img src="408.assets/image-20250723171613252.png" alt="image-20250723171613252" style="zoom:80%;" />

**计算中缀表达式**，比如`A+B*(C-D)-E/F`：

1. `num`和`op`两个栈
2. 数字直接入栈
3. 若**栈顶的优先级$\geq$自己，则一直出栈**，直到栈顶优先级$<$自己或栈空为止
4. **右括号一直出栈，直到找到左括号**

#### 栈与递归

#### 队列与层次遍历

```java
while(!Q.isEmpty()) {
    int n = Q.size();
    for (int i = 0; i < n; i++) {
        TreeNode node = Q.pop();
        if (node.left != NULL) {
            Q.push(node.left);
        }
        if (node.right != NULL) {
            Q.push(node.right);
        }
    }
}
```

#### 缓冲区与消息队列

缓冲区：解决快慢匹配问题（如CPU与打印机）

消息队列：异步、削峰（多个外设同时请求CPU）、解耦

### 10.数组和特殊矩阵

#### 对称矩阵

上下三角半区的元素相同，因此**存储在一维数组$[n(n+1)/2]$中**，在一维数组中的下标k与矩阵的坐标关系：

<img src="408.assets/image-20250723211437118.png" alt="image-20250723211437118" style="zoom:80%;" />

#### 三角矩阵

和对称矩阵类似，不过**最后要存储对角线另一侧的常数（三角矩阵对角线另一侧全为常数）**：

<img src="408.assets/image-20250723211446997.png" alt="image-20250723211446997" style="zoom:80%;" />

<img src="408.assets/image-20250723211501436.png" alt="image-20250723211501436" style="zoom:80%;" />

#### 三对角矩阵

存放到**一维数组**：

<img src="408.assets/image-20250723211652983.png" alt="image-20250723211652983" style="zoom:80%;" />

#### 稀疏矩阵

**三元组**$(i,j,a_{ij})$，可用**数组或十字链表存储三元组**



## 第4章：串

### 1.KMP算法

书写得依托答辩，看下面的图即可：

**主串的指针i永远不回退**：

<img src="408.assets/image-20250723214214663.png" alt="image-20250723214214663" style="zoom: 50%;" />

<img src="408.assets/image-20250723214313073.png" alt="image-20250723214313073" style="zoom: 50%;" />

<img src="408.assets/image-20250723214425379.png" alt="image-20250723214425379" style="zoom: 50%;" />

<img src="408.assets/image-20250723214448681.png" alt="image-20250723214448681" style="zoom: 50%;" />

<img src="408.assets/image-20250723214519945.png" alt="image-20250723214519945" style="zoom:50%;" />

<img src="408.assets/image-20250723214530570.png" alt="image-20250723214530570" style="zoom:50%;" />

<img src="408.assets/image-20250723214554955.png" alt="image-20250723214554955" style="zoom:50%;" />

当匹配失败时，找**最后一个匹配位置的next的值**。新一轮匹配时，**模式串直接跳过next的值个字符**，将当前的字符和主串匹配失败的位置继续匹配

现在，所有的问题在于如何寻找next数组

### 2.next数组

next数组的本质就是**寻找子串中相同前后缀的长度**：

<img src="408.assets/image-20250723215237025.png" alt="image-20250723215237025" style="zoom: 67%;" />

计算方法见下图：

<img src="408.assets/image-20250723215342965.png" alt="image-20250723215342965" style="zoom: 80%;" />

<img src="408.assets/image-20250723215402022.png" alt="image-20250723215402022" style="zoom:80%;" />

<img src="408.assets/image-20250723215422402.png" alt="image-20250723215422402" style="zoom:80%;" />

<img src="408.assets/image-20250723215439615.png" alt="image-20250723215439615" style="zoom:80%;" />

<img src="408.assets/image-20250723215450456.png" alt="image-20250723215450456" style="zoom:75%;" />

### 3.递推求解next数组

核心思想：没必要每次都寻找最长前后缀，可以根据**动态规划**的思想，**利用前面掌握的信息递推下一项**

<img src="408.assets/image-20250723220327020.png" alt="image-20250723220327020" style="zoom: 67%;" />

<img src="408.assets/image-20250723220416758.png" alt="image-20250723220416758" style="zoom:67%;" />

<img src="408.assets/image-20250723220431782.png" alt="image-20250723220431782" style="zoom:67%;" />

下面可能有点绕，解释一下：下一位不匹配，但是子串`ABACABA`已经匹配过了，它存在最长前后缀`ABA`，那么后面那个`A`在左边已经求得跳跃长度为1(`next[2]=1`)，因此只需子串`ABACABA`跳过第一个`A`，然后第二个`B`匹配，因此这里的`B`的最长前后缀为`next[2]+1=2`

<img src="408.assets/image-20250723220604737.png" alt="image-20250723220604737" style="zoom:67%;" />

<img src="408.assets/image-20250723221057705.png" alt="image-20250723221057705" style="zoom:67%;" />



## 第5章：树与二叉树

### 1.树的概念

**结点的度=出度**；**树的度=最大度数**

**结点的路径长度=两结点之间的边数**；**树的路径长度=根到所有结点的路径长度总和**

### 2.二叉树

**二叉树是有序树**
$$
n个结点最多形成\frac{(2n)!}{(n+1)!n!}个二叉树
$$
**二叉树**和**度为2的树**的区别：

1. 二叉树可以为空；度为2的树至少要有3个结点
2. 二叉树有序；度为2的树不一定有序

#### 满二叉树

**每一层都填满**

#### 完全二叉树

可以**用一维数组存储**

<img src="408.assets/image-20250724114942660.png" alt="image-20250724114942660" style="zoom:80%;" />

**完全二叉树度为1的结点最多1个**（非常重要）

注意：完全二叉树的**叶子节点最后一层和倒数第二层都可能有**，**不能忽略倒数第二层**

#### 正则二叉树

只有度为0或2的结点

#### 性质

$$
&n_0+n_1+n_2=n_1+2 \times n_2+1 \\\\
&n_0=n_2+1
$$

### 3.二叉树的遍历和线索二叉树

#### 二叉树的遍历

先序遍历：一根线围一圈

中序遍历：竖着看

后序遍历：从左到右摘葡萄

#### 由遍历构造二叉树

核心思路：**分治**

**先序+中序**：

```java
TreeNode findTreeByPreorderInorder(String preorder, String inorder) {
    if (preorder.isEmpty() || inorder.isEmpty()) {
        return null;
    }
    if (preorder.length() == 1 || inorder.length() == 1) {
        return new TreeNode(preorder.charAt(0) - '0');
    }
    
    char root = preorder.charAt(0);
    int rootIndex = inorder.indexOf(root); // 左子树的大小
    
    String leftPreorder = preorder.substring(1, rootIndex + 1);
    String rightPreorder = preorder.substring(rootIndex + 1);
    String leftInorder = inorder.substring(0, rootIndex);
    String rightInorder = inorder.substring(rootIndex + 1);
    
    TreeNode left = findTreeByPreorderInorder(leftPreorder, leftInorder);
    TreeNode right = findTreeByPreorderInorder(rightPreorder, rightInorder);
    
    return new TreeNode(root - '0', left, right);
}
```

**后序+中序**：

基本同理，不再赘述

**层次+中序**：

```java
TreeNode findTreeByLevelorderInorder(String levelorder, String inorder) {
    if (levelorder.isEmpty() || inorder.isEmpty()) {
        return null;
    }
    if (levelorder.length() == 1 || inorder.length() == 1) {
        return new TreeNode(levelorder.charAt(0) - '0');
    }
    
    char rootVal = levelorder.charAt(0);
    int rootIndex = inorder.indexOf(rootVal); // 左子树的大小
    
    String leftInorder = inorder.substring(0, rootIndex);
    String rightInorder = inorder.substring(rootIndex + 1);
    
    StringBuilder leftLevelorder = new StringBuilder();
    StringBuilder rightLevelorder = new StringBuilder();
    
    // 整体的层次遍历，包含了左右子树的层次遍历
    // 如果元素来自左子树，则加入leftInorder，加入顺序符合左子树层次遍历的顺序
    for (int i = 1; i < levelorder.length(); i++) {
        char c = levelorder.charAt(i);
        if (leftInorder.indexOf(c) != -1) {
            leftLevelorder.append(c);
        } else if (rightInorder.indexOf(c) != -1) {
            rightLevelorder.append(c);
        }
    }
    
    TreeNode left = 
        findTreeByLevelorderInorder(leftLevelorder.toString(), leftInorder);
    TreeNode right = 
        findTreeByLevelorderInorder(rightLevelorder.toString(), rightInorder);
    
    return new TreeNode(rootVal - '0', left, right);
}
```

#### 线索二叉树

**总空间：`2n`**

**使用：`n-1`**

**空余：`n+1`**

线索二叉树就是要**把空余的`n+1`个空间利用起来**，用它们**指示结点的先\中\后序遍历的前驱和后继**

增加`ltag`和`rtag`，标识左右子树是指向孩子还是前驱后继：

<img src="408.assets/image-20250724130611335.png" alt="image-20250724130611335" style="zoom:80%;" />

<img src="408.assets/image-20250724130644489.png" alt="image-20250724130644489" style="zoom:80%;" />

遍历**中序**线索二叉树：

```java
TreeNode nextNode(TreeNode root) {
    if (root.rtag == 0) { // 右子树的最左结点
        return firstNode(root.right);
    }
    return root.right; // 直接返回后继
}

TreeNode firstNode(TreeNode root) { // 树的最左结点
    if (root == null || root.left == null) {
        return null;
    }
    return firstNode(root.left);
}
```

### 4.树和森林

#### 树的表示法

**双亲表示法**：

<img src="408.assets/image-20250724162921312.png" alt="image-20250724162921312" style="zoom:80%;" />

**孩子表示法**：

<img src="408.assets/image-20250724162952527.png" alt="image-20250724162952527" style="zoom:80%;" />

**孩子兄弟表示法**：

```c
typedef struct TreeNode {
    ElemType* data;
    struct TreeNode *firstChild, *nextBrother;
} TreeNode, *Tree;
```

有第一个孩子和下一个兄弟，可以轻易**将森林化为二叉树**

#### 树、森林、二叉树转换

**树->二叉树**：

`left`指向**第一个孩子**，`right`指向**右兄弟**：

<img src="408.assets/image-20250724163739566.png" alt="image-20250724163739566" style="zoom:80%;" />

**森林->二叉树**：

同理

**二叉树->森林**：

1. **根结点和左子树是一棵树**，**断开右子树**；
2. 右子树重复上述操作

<img src="408.assets/image-20250724164522857.png" alt="image-20250724164522857" style="zoom:80%;" />

#### 树和森林的遍历

树的**先根遍历**

树的**后根遍历**

**森林的先序遍历**：依次**先根遍历**每一棵树

**森林的中序遍历**：依次**后根遍历**每一棵树

<img src="408.assets/image-20250724165037411.png" alt="image-20250724165037411" style="zoom:80%;" />

### 5.树与二叉树的应用

#### 哈夫曼树

树的带权路径长度(只算叶子结点)最小

<img src="408.assets/image-20250724165527549.png" alt="image-20250724165527549" style="zoom:80%;" />

#### 并查集

作用：**查找两个元素是否属于同一集合，合并两个集合**

`Initial`，`Union`，`Find`

<img src="408.assets/image-20250724170929262.png" alt="image-20250724170929262" style="zoom:80%;" />

**用数组表示并查集**

**数组的index是编号，数组的值是index的父结点**

构造并查集的步骤如下图（**也可初始化为-1或其它负数**）：

<img src="408.assets/image-20250724171606025.png" alt="image-20250724171606025" style="zoom: 50%;" />

<img src="408.assets/image-20250724171726499.png" alt="image-20250724171726499" style="zoom:50%;" />

<img src="408.assets/image-20250724171831385.png" alt="image-20250724171831385" style="zoom:50%;" />

```java
void init(int[] parent) {
    for (int i = 0; i < parent.length; i++)
        parent[i] = i; // 所有元素的父节点初始化为自己
}

int find(int[] parent, int index) {
    return parent[index] == index ? index : find(parent, parent[index]);
}

void union(int[] parent, int index1, int index2) {
    parent[find[index2]] = find[index1];
}
```

**路径压缩**：为了**避免让树过高**，可以在**find的过程中，让树的每一个元素的parent直接指向根节点**

<img src="408.assets/image-20250724173853501.png" alt="image-20250724173853501" style="zoom:50%;" />

```java
int find(int[] parent, int index) {
    if (parent[index] != index) {
        parent[index] = find(parent, parent[index]); // 路径压缩
    }
    return parent[index];
}
```



## 第6讲：图

### 1.图的概念

**顶点集非空，边集可为空**

#### 简单图

1. 无重复边
2. 无指向自己的边

#### 多重图

非简单图

#### 简单路径

顶点不重复的路径

#### 简单回路

顶点不重复的回路

#### 距离

距离=最短路径

#### 连通、连通分量

**无向图**的概念

<img src="408.assets/image-20250724210853147.png" alt="image-20250724210853147" style="zoom:80%;" />

#### 强连通、强连通分量

**有向图**的概念

任意两点相互有弧

#### 生成树

性质：**边数=顶点数-1**（重要）

<img src="408.assets/image-20250724211634711.png" alt="image-20250724211634711" style="zoom:80%;" />

#### 网

网=带权的图

#### 完全图

边全满

### 2.图的存储

#### 邻接矩阵

适合**稠密图**

空间：$V^2$

#### 邻接链表

分为**顶点表**和**边表**

**顶点表竖着，边表横着**

<img src="408.assets/image-20250724212427198.png" alt="image-20250724212427198" style="zoom:80%;" />

空间：$V+E$

#### 十字链表

只适用于**有向图**

<img src="408.assets/image-20250724213114537.png" alt="image-20250724213114537" style="zoom:80%;" />

**顶点结点**：`firstin`以该点作为弧头的第一个弧；`firstout`以该点作为弧尾的第一个弧

**弧结点**：前两个分别是弧的尾头，后面两个是竖着和横着的`next`

<img src="408.assets/image-20250724213315705.png" alt="image-20250724213315705" style="zoom:80%;" />

#### 邻接多重表

只适用于**无向图**

<img src="408.assets/image-20250724214047836.png" alt="image-20250724214047836" style="zoom:80%;" />

`ivex`域和`jvex`域=**两个顶点的编号**

`ilink`域指向ivex的**下一条边**；`jlink`域指向**jvex的下一条边**

<img src="408.assets/image-20250724214243686.png" alt="image-20250724214243686" style="zoom:80%;" />

`firstedge`=该节点的**第一条边**

<img src="408.assets/image-20250724214425849.png" alt="image-20250724214425849" style="zoom:80%;" />

### 3.图的遍历

#### BFS

辅助队列`Q`，且有`visit[]`，类似层次遍历

```java
boolean visited[] = new boolean[V];

void BFSTraverse(Graph G) {
    for (int i = 0; i < V; i++) {
        visited = false;
    }
    Queue Q = new Deque<Integer>();
    for (int i = 0; i < V; i++) {
        if (!visited[i]) {
            BFS(G, i);
        }
    }
}

void BFS(Graph G, int i) {
    visited[i] = true;
    Q.offer(i);
    while (Q.isNotEmpty()) {
        int peek = Q.poll();
        for (int j = 0; j < V; j++) {
            if (G.edge[peek][j] == 1 && !visited[j]) {
                visited[j] = true;
                Q.offer(j);
            }
        }
    }
}
```

适合走迷宫类问题

**空间复杂度**：**$O(V)$**，辅助队列`Q`

**时间复杂度**：**$O(V+E)(邻接链表)$、$O(V^2)(邻接矩阵)$**

#### DFS

类似先序遍历

**空间复杂度**：**$O(V)$**，递归栈

**时间复杂度**：**$O(V+E)(邻接链表)$、$O(V^2)(邻接矩阵)$**

> 连通图/强连通图，一次调用BFS/DFS即可访问所有点
>
> 非连通图/非强连通图，一次调用BFS/DFS不能访问所有点

### 4.图的应用

#### 最小生成树

最小生成树，**边数=顶点数-1**

---

**Prim算法**：

1. 先选一个点，然后选**离它最近的一个点**
2. 更新其它点到这个新整体的距离
3. 在选一个离新整体最近的点

**时间复杂度**：**$O(V^2)$**，只和顶点有关

---

**Kruskal算法**：

1. 选**最短的一条边**
2. 如果不构成回路，则加入，否则丢弃
3. 直到有n-1条边

**时间复杂度**：**$O(E\log_2E)$**，只和变有关

#### 最短路径

**Dijkstra算法**：单源最短路径

每次**选离源点最短的点**，更新其它点到新整体的距离

<img src="408.assets/image-20250725153241678.png" alt="image-20250725153241678" style="zoom:80%;" />

**时间复杂度**：**$O(V^2)$**，只和顶点有关

**边上有负值时，Dijkstra算法不适用**

---

**Floyd算法**：

```java
dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])
```

**时间复杂度**：**$O(V^3)$**，只和顶点有关

**允许负权的边，不允许总权值为负的回路**

<img src="408.assets/image-20250725153847564.png" alt="image-20250725153847564" style="zoom:80%;" />

#### 有向无环图

DAG图，编译原理里有讲过

<img src="408.assets/image-20250725154536028.png" alt="image-20250725154536028" style="zoom:80%;" />

<img src="408.assets/image-20250725154545753.png" alt="image-20250725154545753" style="zoom:80%;" />

#### 拓扑排序

AOV网无权值

不断找**入度为0**的点输出；找不到则说明有回路

<img src="408.assets/image-20250725154941497.png" alt="image-20250725154941497" style="zoom:80%;" />

**时间复杂度**：**$O(V+E)(邻接链表)$、$O(V^2)(邻接矩阵)$**

拓扑排列的结果不一定唯一

#### 关键路径

AOE网有权值

人话：**一个点只有等所有指向它的点都完成才能开始，因此最早开始时间是指向它的所有点中的最晚时间**，求出所有点的最早开始时间后，选一条**时间最长的路径**就是关键路径

<img src="408.assets/image-20250725161303145.png" alt="image-20250725161303145" style="zoom:80%;" />

1. `v_e`就是每个点的最早开始时间

	<img src="408.assets/image-20250725161313042.png" alt="image-20250725161313042" style="zoom:80%;" />

2. `v_l`是每个点的最晚开始时间，从`v_6`开始反着来减，找最大值

	<img src="408.assets/image-20250725161457788.png" alt="image-20250725161457788" style="zoom:80%;" />

3. `e`是弧的最早开始时间，等于弧尾的最早开始时间`v_e`

4. `l`是弧的最晚开始时间，等于弧头的最晚开始时间减`weight`：`v_l-weight`

5. 最后`l-e=0`的就是关键路径

**关键路径不唯一**



## 第7讲：查找

### 1.查找的概念

静态查找表：只查不改，适用于顺序、折半、散列

动态查找表：CRUD，适用于二叉排序树、散列

平均查找长度**ASL**：**被查找概率\*比较次数**

### 2.顺序查找和折半查找

#### 顺序查找

**一般顺序查找**：
$$
\mathrm{ASL}_\text{战功}=\sum_{i=1}^nP_i(n-i+1)=\frac{n+1}{2} \\\\
\mathrm{ASL}_\text{ 不成功 }=n+1
$$

---

**有序线性查找**：

<img src="408.assets/image-20250725211234016.png" alt="image-20250725211234016" style="zoom:80%;" />

有**n+1个空隙**，到达**最后两个空隙都需要比较n次**
$$
\text{ASL}{\text{不成功}} = \sum{j=1}^{n} q_j (l_j - 1) = \frac{1 + 2 + \cdots + n + n}{n+1} = \frac{n}{2} + \frac{n}{n+1}
$$

#### 折半查找

<img src="408.assets/image-20250725211550693.png" alt="image-20250725211550693" style="zoom:80%;" />
$$
\text{ASL} = \frac{1}{n}\sum_{i=1}^{n} l_i = \frac{n+1}{n}\log_2(n+1) - 1 \approx \log_2(n+1) - 1 \\\\
查找成功（圆形结点）：ASL=(1×1+2×2+3×4+4×4)/11=3\\\\
查找失败（方形结点）：ASL=(3×4+4×8)/12=11/3
$$

#### 分块查找

块内无序，块间有序

块内顺序，块间折半

### 3.树形查找

#### 二叉排序树

**不能有重复元素**

CRUD复杂度均为`O(logn)`

**二叉排序树的删除**：

1. 叶子结点直接删除

2. 被删除结点**只有一个子树**，则将子树直接连到父结点

3. 被删除结点有**两个子树**，则用其直接后继(**右子树的最左结点**)代替

	<img src="408.assets/image-20250725213254909.png" alt="image-20250725213254909" style="zoom:80%;" />

#### 平衡二叉树

注意：平衡二叉树是**所有的子树都平衡**，**并不只有根节点所在的树平衡**

```Java
boolean isAVL = true;

int treeLevel(TreeNode root) { // 在求树的高度中顺带判断是否平衡
    if (root == null)
        return 0;
    int leftLevel = treeLevel(root.left);
    int rightLevel = treeLevel(root.right);
    if (Math::abs(leftLevel - rightLevel) > 1)
        isAVL = false;
    return Math::abs(leftLevel, rightLevel) + 1;
}
```

<img src="408.assets/image-20250725220613375.png" alt="image-20250725220613375" style="zoom:80%;" />

**LL**：右旋

<img src="408.assets/image-20250725220755768.png" alt="image-20250725220755768" style="zoom:80%;" />

**RR**：左旋

<img src="408.assets/image-20250725220848648.png" alt="image-20250725220848648" style="zoom:80%;" />

**LR**：C先左旋到B，再右旋到A

<img src="408.assets/image-20250725221515766.png" alt="image-20250725221515766" style="zoom:80%;" />

**RL**：C先右旋到B，再左旋到A

<img src="408.assets/image-20250725221535241.png" alt="image-20250725221535241" style="zoom:80%;" />

**深度为n的平衡二叉树最少结点数**：
$$
n_h=n_{h-2}+n_{h-1}+1
$$
<img src="408.assets/image-20250725222647299.png" alt="image-20250725222647299" style="zoom:80%;" />

#### 红黑树

<img src="408.assets/image-20250725223043283.png" alt="image-20250725223043283" style="zoom:80%;" />

**null是黑色的**

**最长路径不会超过最短路径的两倍**，比如上图中，最短为左子树三黑，最后为右子树的黑红黑红黑

红黑树不平衡，搜索效率率低于AVL树，但插入和删除效率高于AVL树

红黑树的插入和构造不想记

### 4.B树和B+树

> 二叉搜索树、AVL树、红黑树都是将全部数据读到内存中，数据量不大
>
> 而B树适用于数据量很大，无法一次性读入内存，只能一次读一个结点进行比较，然后再比较下一个结点
>
> 硬盘访问次数和树的高度成正比，**B树可以降低硬盘访问次数**（Mysql使用B+树存储数据）

#### B树

**最下面查找失败的外部结点叫叶子结点**

<img src="408.assets/image-20250726111841087.png" alt="image-20250726111841087" style="zoom:80%;" />
$$
m阶B树最多m个子树，m-1个元素 \\\\

m阶B树至少 \left\lceil \frac{m}{2} \right\rceil个子树，\left\lceil \frac{m}{2} \right\rceil -1个元素
$$
**根结点最少还是1个元素**

> 上图中每个结点最多5个子树，4个元素；最少3个子树，2个元素

**访问结点在硬盘上进行**；**结点内查找是在内存中进行**

---

**插入**：出现上溢出，则**中间左偏结点向上提**

> **4阶**B树：最多3个元素，最少1个元素
>
> <img src="408.assets/image-20250726113554135.png" alt="image-20250726113554135" style="zoom:80%;" />
>
> <img src="408.assets/image-20250726113613168.png" alt="image-20250726113613168" style="zoom:80%;" />
>
> <img src="408.assets/image-20250726113638106.png" alt="image-20250726113638106" style="zoom:80%;" />
>
> <img src="408.assets/image-20250726113656062.png" alt="image-20250726113656062" style="zoom:80%;" />
>
> <img src="408.assets/image-20250726113711445.png" alt="image-20250726113711445" style="zoom:80%;" />
>
> <img src="408.assets/image-20250726113805609.png" alt="image-20250726113805609" style="zoom:80%;" />
>
> <img src="408.assets/image-20250726113818971.png" alt="image-20250726113818971" style="zoom:80%;" />
>
> <img src="408.assets/image-20250726113739470.png" alt="image-20250726113739470" style="zoom:80%;" />
>
> <img src="408.assets/image-20250726113847557.png" alt="image-20250726113847557" style="zoom:80%;" />
>
> <img src="408.assets/image-20250726113856309.png" alt="image-20250726113856309" style="zoom:80%;" />

---

**删除**：

1. **删除非最后一层的元素，都用其直接前驱或后继代替**

	<img src="408.assets/image-20250726114522390.png" alt="image-20250726114522390" style="zoom: 80%;" />

	![image-20250726114607174](408.assets/image-20250726114607174.png)

2. **出现下溢出，向左右兄弟借**

	<img src="408.assets/image-20250726115105991.png" alt="image-20250726115105991" style="zoom:80%;" />

	**把父节点元素下移，兄弟元素上移**

	<img src="408.assets/image-20250726115406363.png" alt="image-20250726115406363" style="zoom:80%;" />

	<img src="408.assets/image-20250726115437738.png" alt="image-20250726115437738" style="zoom:80%;" />

3. **左右兄弟都不够借，和其中一个合并**

	**父节点先下移再合并**

	<img src="408.assets/image-20250726115708278.png" alt="image-20250726115708278" style="zoom:80%;" />

	<img src="408.assets/image-20250726115821853.png" alt="image-20250726115821853" style="zoom:80%;" />

	<img src="408.assets/image-20250726115850794.png" alt="image-20250726115850794" style="zoom:80%;" />

4. **父节点下溢出的情况**

	<img src="408.assets/image-20250726120330011.png" alt="image-20250726120330011" style="zoom:80%;" />

	<img src="408.assets/image-20250726120351578.png" alt="image-20250726120351578" style="zoom:80%;" />

	![image-20250726120405422](408.assets/image-20250726120405422.png)

#### B+树

<img src="408.assets/image-20250726121228878.png" alt="image-20250726121228878" style="zoom:80%;" />

每个结点**元素和子树个数相同**

**每个元素对应子树的元素最大值**

---

**最后一层不存储数据，而是指向数据的地址**

<img src="408.assets/image-20250726121550537.png" alt="image-20250726121550537" style="zoom:80%;" />

### 5.散列表

#### 散列函数

1. 直接定址法
2. 除留余数法
3. 数字分析法
4. 平方取中法

#### 哈希冲突

**开放定址法**：放到现有的其它空间，**不开辟新的空间**

1. 线性探测法：向后递推
2. 平方探测法：$d_i=1^2,-1^2,2^2,-2^2,\cdots,k^2,-k^2$
3. 双散列法：$d_i=i\mathrm{xHash}_2(\mathrm{key})$，利用第二个散列函数$Hash_2(key)$计算该关键字的地址增量
4. 伪随机数法

---

**拉链法**：**开辟新的空间**

<img src="408.assets/image-20250726122237024.png" alt="image-20250726122237024" style="zoom:80%;" />

#### 装填因子

$$
\alpha=\frac{\text{表中记录数}n}{\text{散列表长度}m}
$$



## 第8讲：排序

### 1.排序的概念

**稳定排序**：**不改变相同元素的相对位置**

**不稳定排序**：**改变相同元素的相对位置**

**内部排序**：所有数据加载到内存中排序，**速度取决于时间复杂度**

**外部排序**：排序的数据不断在内存、外存中移动，**速度取决于内、外存移动次数**

### 2.插入排序

#### 直接插入排序

前面部分有序

#### 折半插入排序

时间复杂度仍为$O(n^2)$，因为每次循环需要把后面的元素向后移一位

#### 希尔排序

把间隔为 $d$ 的元素分为一组，每一组内部直接插入排序，不断减小 $d$ 直至为 1

<img src="408.assets/image-20250726162537323.png" alt="image-20250726162537323" style="zoom:80%;" />

### 3.交换排序

#### 冒泡排序

如果已经有序，则break，最好时间复杂度为 $O(n)$

#### 快速排序

分治思想，选一个 `pivot`，每一趟左边小于等于 `pivot`，右边大于等于 `pivot`

```Java
void quickSort(int[] arr, int low, int high) {
    if (arr == null || arr.length <= 1 || low >= high)
        return;
    
    int pivotIndex = partition(arr, low, high);
    quickSort(arr, low, pivotIndex - 1);
    quickSort(arr, pivotIndex + 1, high);
}

int partition(int[] arr, int low, int high) {
    int pivot = arr[low];
    while(low < high) {
        while(low < high && arr[high] >= pivot)
            high--;
        arr[low] = arr[high];
        while(low < high && arr[low] <= pivot)
            low++;
        arr[high] = arr[low];
    }
    arr[low] = pivot;
    return low;
}
```

```
[5, 3, 8, 6, 2, 7, 1, 4] 初始
[4, 3, 1, 2, 5, 7, 6, 8] 第1轮后（基准5归位）
[2, 3, 1, 4]             第2轮左子数组（基准4）
[1, 2, 3]                第3轮左子数组（基准2）
[6, 7, 8]                第4轮右子数组（基准7）
[1, 2, 3, 4, 5, 6, 7, 8] 最终结果
```

### 4.选择排序

#### 简单选择排序

每次选一个最小的

#### 堆排序

**堆=完全二叉树**，用**一维数组存储**

<img src="408.assets/image-20250726165706488.png" alt="image-20250726165706488" style="zoom:80%;" />

**从最后一个子树开始，逐步向上调整为大根堆**

<img src="408.assets/image-20250726165937705.png" alt="image-20250726165937705" style="zoom:80%;" />

堆排序就是建立完堆后，**逐步输出并删除堆顶元素**

---

**删除**：

<img src="408.assets/image-20250726170148187.png" alt="image-20250726170148187" style="zoom:80%;" />

1. **堆顶和最后一个元素交换**
2. 然后**逐步向下调整**

<img src="408.assets/image-20250726170237672.png" alt="image-20250726170237672" style="zoom:80%;" />

---

**插入**：

1. 新结点放在末端
2. 然后**逐步向上调整**

<img src="408.assets/image-20250726170434363.png" alt="image-20250726170434363" style="zoom:80%;" />

---

<img src="408.assets/image-20250726170609664.png" alt="image-20250726170609664" style="zoom:80%;" />

适用于从海量数据中找最大的几个数

**建堆时间复杂度 $O(n)$**

**删除和插入只和树高度有关**，**时间复杂度 $O(\log_2n)$**

### 5.归并排序

需要辅助空间，**空间复杂度 $O(n)$**

```Java
void mergeSort(int[] arr, int low, int high) {
    if (arr.legnth == 0 || arr.length == 1)
        return;
    int mid = (low + right) / 2;
    mergeSort(arr, low, mid);
    mergeSort(arr, mid + 1, high);
    int[] temp = new int[arr.length]; // 辅助空间
    int i = 0, j = mid + 1, index = 0;
    while(i <= mid && j <= high) {
        if (arr[i] <= arr[j])
            temp[index++] = arr[i++];
        else
            temp[index++] = arr[j++];
    }
    while(i <= mid)
        temp[index++] = arr[i++];
    while(j <= high)
        temp[index++] = arr[j++];
    for (index = 0; index < arr.length; index++)
        arr[index] = temp[index];
}
```

### 6.基数排序和计数排序

#### 基数排序

就是**桶排序**

```
[329, 457, 657, 839, 436, 720, 355]
按个位排序
[720, 355, 436, 457, 657, 329, 839]
再按十位排序
[720, 329, 436, 839, 355, 457, 657]
再按百位排序
[329, 355, 436, 457, 657, 720, 839]
```

**按每次排序完成的顺序放入下一个桶中**

**时间复杂度**：**$O(d(n+r))$**，其中 **d=3, r=10**

#### 计数排序

给定数的范围，先构造数组，然后一次遍历，**统计每个数出现的次数**

### 7.内部排序比较

| 算法种类     | 最好情况  | 平均情况      | 最坏情况  | 空间复杂度   | 是否稳定 |
| ------------ | --------- | ------------- | --------- | ------------ | -------- |
| 直接插入排序 | **O(n)**  | O(n²)         | O(n²)     | O(1)         | 是       |
| 冒泡排序     | **O(n)**  | O(n²)         | O(n²)     | O(1)         | 是       |
| 简单选择排序 | O(n²)     | O(n²)         | O(n²)     | O(1)         | **否**   |
| 希尔排序     | -         | -             | -         | O(1)         | **否**   |
| 快速排序     | O(nlog₂n) | O(nlog₂n)     | **O(n²)** | **O(log₂n)** | **否**   |
| 堆排序       | O(nlog₂n) | O(nlog₂n)     | O(nlog₂n) | O(1)         | **否**   |
| 二路归并排序 | O(nlog₂n) | O(nlog₂n)     | O(nlog₂n) | **O(n)**     | 是       |
| 基数排序     | O(d(n+r)) | **O(d(n+r))** | O(d(n+r)) | **O(r)**     | 是       |

### 8.外部排序

外部排序指的是大文件的排序，即待**排序的记录存储在外存中**，待排序的文件**无法一次性装入内存**，需要在**内存和外存之间进行多次数据交换**，以达到排序整个文件的目的。

**时间取决于IO次数**

<img src="408.assets/image-20250726175939478.png" alt="image-20250726175939478" style="zoom:80%;" />

**上图进行了3趟归并(树高为3)**

#### 多路平衡归并与败者树

**增加归并路数，降低归并趟数**，但是**归并算法复杂度会增加**；为了**避免归并算法复杂度增加，引入败者树**

1. **叶子节点**：多路归并的各路当前元素
2. **非叶子节点**：比较中的**失败者**的**索引**
3. **根节点**：**全局败者**（最终**胜者不保存在树中，直接输出**）
4. 在**根节点上加一个结点表示最终胜者**

<img src="408.assets/image-20250726212751769.png" alt="image-20250726212751769" style="zoom: 67%;" />

<img src="408.assets/image-20250726212809443.png" alt="image-20250726212809443" style="zoom:67%;" />

#### 置换-选择排序

**作用**：将大量数据分成若干个**有序的块**（而不是完全排序），为后续多路归并排序做准备

**核心思想**：利用有限内存，边读数据边排序，输出一组**相对有序的子序列**，减少后续归并次数

<img src="408.assets/image-20250726213854604.png" alt="image-20250726213854604" style="zoom:80%;" />

<img src="408.assets/image-20250726213902514.png" alt="image-20250726213902514" style="zoom:80%;" />

<img src="408.assets/image-20250726213945756.png" alt="image-20250726213945756" style="zoom:80%;" />

<img src="408.assets/image-20250726213957650.png" alt="image-20250726213957650" style="zoom:80%;" />

#### 最佳归并树

**作用**：在**多路归并排序**中，**用最少的读写次数**将多个有序小文件（归并段）合并成一个大文件

**核心思想**：像“合并快递包裹”一样，**优先合并小的文件**，减少总搬运（IO）次数

**本质**：**多路哈夫曼树**

<img src="408.assets/image-20250726221341283.png" alt="image-20250726221341283" style="zoom:80%;" />

上述方法并不是最佳

若**初始归并段不足以构成一颗完整的k叉树**，则添加长度为0的**虚段**

<img src="408.assets/image-20250726221717066.png" alt="image-20250726221717066" style="zoom:80%;" />

---

**计算虚段个数**：
$$
\text{设度为 }0\text{ 的结点有 }n_0\text{ 个,度为 }k\text{ 的结点有 }n_k\text{ 个,归并树的结点总数为 }n \\\\
\begin{aligned}n&=n_k+n_0\\\\n&=kn_k+1\end{aligned} \\\\
n_k=(n_0-1)/(k-1) \\\\
(n_0-1)\%(k-1)=0，正好可以构造k叉归并树 \\\\
(n_0-1)\%(k-1)=u\neq0，有u个多余，补上k-u-1个虚段
$$
<img src="408.assets/image-20250726222511219.png" alt="image-20250726222511219" style="zoom:80%;" />

<img src="408.assets/image-20250726222451294.png" alt="image-20250726222451294" style="zoom:80%;" />





# 计算机组成原理

## 第1章：计算机系统概述

### 1.冯诺依曼机

1. “存储程序”的工作方式，即把**程序和数据放到存储器，顺序取出执行**
2. **存储器、运算器、控制器、输入输出设备**
3. **指令和数据**以**二进制**表示，同等地位，**形式上没有区别**
4. 指令=**操作码+地址码**

### 2.输入设备

键盘、鼠标、扫描仪等

### 3.输出设备

显示器、打印机

### 4.存储器

分为主存(内存)和外存(辅存)

**CPU能直接访问的是主存**

#### MAR

存储器地址寄存器(Memory Address Register)，在CPU和内存之间传递地址

**MAR的位数=地址线宽度**

#### MDR

存储器数据寄存器(Memory Data Register)，在CPU和内存之间传递读写数据

**MDR的位数=数据线宽度**，**通常=存储字长**，但也可以是**存储字长的倍数**(**一次传输多个存储字**)

| 寄存器  |          作用          | 位于 |    连接方式     |
| :-----: | :--------------------: | :--: | :-------------: |
| **MAR** |  存储要访问的内存地址  | CPU  | 地址总线 → 内存 |
| **MDR** | 临时存储读写内存的数据 | CPU  | 数据总线 ↔ 内存 |

**MAR和MDR均位于CPU内部，参与内存读写**

#### 存储字长

**存储单元**，存储的最小单元

**存储字长**，存储单元的长度，按字节存储，存储字长就是$1B$，**$$1B 或 2^nB$$**

### 5.运算器

**运算器的核心是ALU**(Arithmetic Logic Unit，算数逻辑单元)

**运算器的寄存器**：**通用寄存器组(GPRs)**，**标志寄存器(PSW，如ZF、SF、CF、OF)**

### 6.控制器

**控制器=程序计数器(PC)+指令寄存器(IR)+控制单元(CU)**

#### PC

**PC位数=地址线宽度**

**PC->MAR->地址总线->内存**

#### IR

**IR存放正在执行的指令**

指令=操作码+地址码

**操作码->CU**

**地址码->MAR->地址总线->内存**

### 7.CPU

**中央处理器(CPU)=运算器+控制器**

<img src="408.assets/image-20250727163429603.png" alt="image-20250727163429603" style="zoom:80%;" />

### 8.总线

总线位于**CPU和内存之间**

**地址总线**：CPU**单向**传输到内存，用于寻址(**MAR将地址信息送到地址总线上**)

**控制总线**：控制读\写

**数据总线**：(**MDR将数据送到数据总线，或从数据总线接受数据**)

### 9.软件

系统软件：大家都有

应用软件：特定功能

### 10.语言

机器语言：机器唯一识别和可执行的语言

汇编语言

高级语言：编译型语言(通过编译器生成中间代码)，解释型语言(通过解释器直接翻译成机器语言)

### 11.计算机层次结构

<img src="408.assets/image-20250727164654971.png" alt="image-20250727164654971" style="zoom:80%;" />

软硬件交界面=ISA(指令体系结构)，即所有指令的集合

<img src="408.assets/image-20250727164936033.png" alt="image-20250727164936033" style="zoom:80%;" />

预处理将`#include...`插入过来

### 12.指令执行过程

```
从内存取指令：
PC->MAR->地址总线->Mem->数据总线->MDR->IR
操作码送CU分析指令：
OP(IR)->CU
地址码送内存取数据：
AD(IR)->MAR->地址总线->Mem->数据总线->MDR->ACC
```

### 13.机器字长

机器字长简称字长

**32位机、64位机指的是机器字长**

字长=**定点整数运算**所需的位数

字长通常=**寄存器位数**和**ALU宽度**

字长**影响最大寻址空间**

### 14.性能计算

$$
CPU时钟周期=\frac{1}{主频} \\\\
CPI：一条指令需要的时钟周期数 \\\\
IPS：每秒执行的指令数=\frac{主频}{CPI} \\\\
CPU执行时间=\frac{总周期数}{主频}=\frac{指令数\times CPI}{主频} \\\\
MIPS=\frac{指令条数}{执行时间\times 10^6}=\frac{主频}{CPI\times 10^6}
$$

### 15.透明性

对程序员**可见**：**GPRs、PSW、PC**（可通过汇编指令查看）

对程序员**透明**：**IR、MAR、MDR**（编程时无法获取）



## 第2章：数据的表示和运算

### 1.数制转换

<img src="408.assets/image-20250727202905179.png" alt="image-20250727202905179" style="zoom:80%;" />

<img src="408.assets/image-20250727202922282.png" alt="image-20250727202922282" style="zoom:80%;" />

<img src="408.assets/image-20250727202932409.png" alt="image-20250727202932409" style="zoom:80%;" />

### 2.原码、补码、反码、移码

#### 原码

**只变符号位**

关于原点对称，有正零和负零

#### 补码

$$
-n=\sim n+1
$$

**符号位的权**：**$2^{n-1}$**

**负数补码转真值时，可以直接把符号位当作 $-1\times 2^{n-1}$ 去和后面的相加**

> **原码和补码**表示**8位定点整数和小数**：
>
> **8位定点整数**：
>
> | 表示方式 | 符号 |    范围    |  最小值（二进制）  |  最大值（二进制）  |
> | :------: | :--: | :--------: | :----------------: | :----------------: |
> | **原码** | 正数 | +0 到 +127 |  `0000 0000` (+0)  | `0111 1111` (+127) |
> |          | 负数 | -127 到 -0 | `1111 1111` (-127) |  `1000 0000` (-0)  |
> | **补码** | 正数 | 0 到 +127  |  `0000 0000` (0)   | `0111 1111` (+127) |
> |          | 负数 | -128 到 -1 | `1000 0000` (-128) |  `1111 1111` (-1)  |
>
> **8位定点小数**：
>
> | 表示方式 | 符号 |      范围      |    最小值（二进制）     |    最大值（二进制）    |
> | :------: | :--: | :------------: | :---------------------: | :--------------------: |
> | **原码** | 正数 | +0 到 1−$2^7$  |    `0.000 0000` (+0)    | `0.111 1111` (1−$2^7$) |
> |          | 负数 | -1+$2^7$ 到 -0 | `1.111 1111` (-1+$2^7$) |   `1.000 0000` (-0)    |
> | **补码** | 正数 |  0 到 1−$2^7$  |    `0.000 0000` (0)     | `0.111 1111` (1−$2^7$) |
> |          | 负数 |  -1 到 -$2^7$  |    `1.000 0000` (-1)    | `1.111 1111` (-$2^7$)  |

#### 变形补码

00表示正，11表示负，01正溢出，10负溢出

#### 反码

**除符号位以外取反**

负数的原码符号位取反，反码在此基础上数值位又取反，因此负数的补码等于~n

负数的补码=反码+1

#### 移码

**移码是无符号数**

**移码等于原码+偏置$2^{n-1}$**

### 3.C语言类型转换

隐式类型转换：**小类型->大类型**：

1. `int` → `unsigned int` → `long` → `unsigned long` → `long long` → `unsigned long long`
2. `float` → `double` → `long double`

隐式类型转换：**有符号->无符号**

强制类型转换：**大字节->小字节，高位截断**

强制类型转换：**小字节->大字节，零扩展(无符号整数)\符号扩展(有符号整数)**

---

`int`->`float`，舍入

`int`、`float`->`double`，精确

`double`->`float`，舍入

`float`、`double`->`int`，`int`没有小数，**只保留整数部分**

### 4.运算电路

#### 一位全加器

<img src="408.assets/image-20250727213019925.png" alt="image-20250727213019925" style="zoom:80%;" />

<img src="408.assets/image-20250727213109603.png" alt="image-20250727213109603" style="zoom:80%;" />

#### 串行进位加法器

<img src="408.assets/image-20250727213055769.png" alt="image-20250727213055769" style="zoom:80%;" />

两个$n$位二进制数 $A = A*_{n}A_*{n-1}\cdots A*_{1}$ 和 $B = B_*{n}B*_{n-1}\cdots B_*{1}$ 逐位相加

#### 并行进位加法器

### 5.移位运算

#### 逻辑移位

**全补零**

#### 算数移位

**右移补符号位**

### 6.加法运算

直接加

**溢出判断，采用变补**：**01正溢出，10负溢出**
$$
A-B=A+\sim B+1
$$
**CF**判断**无符号数**是否溢出，**加法进位或减法借位，CF=1**

**OF**判断**有符号数**是否溢出，**正+正得负，或负+负得正，OF=1**

### 7.乘法运算

**原码**乘法，就是列竖式

<img src="408.assets/image-20250727215256064.png" alt="image-20250727215256064" style="zoom:80%;" />

如果乘积用到了**高32位**，则**溢出**

### 8.除法运算

**原码**除法，需要把**被除数补充到2n长度**

<img src="408.assets/image-20250727215534010.png" alt="image-20250727215534010" style="zoom:80%;" />

**商n+1位，则溢出；n位则不溢出**

### 9.浮点数

**阶码用移码表示**(加上偏置$2^{n-1}$)

**尾数用原码表示**

<img src="408.assets/image-20250727220519376.png" alt="image-20250727220519376" style="zoom:80%;" />

偏置为$2^{7-1}=64$，阶码最大为$127-64=63$，最小为$0-64=-64$

> 移码是加上偏置后的结果，因此真值需要减去偏置

<img src="408.assets/image-20250727220503890.png" alt="image-20250727220503890" style="zoom:80%;" />

**浮点数关于原点对称**

#### 规格化浮点数

**尾数最高位为1，且小数点前面不能是1**

> 补码表示尾数，则看符号位和第二位是否相反

**左规**

**右规**：最多一次，因为小数点前面最多为1

#### IEEE标准

<img src="408.assets/image-20250727221313715.png" alt="image-20250727221313715" style="zoom:80%;" />

**注意**：IEEE阶码的**偏置为$2^{n-1}-1$而不是$2^{n-1}$**，比如32位浮点偏置值为127

**小数点前有一个隐藏的1**
$$
(-1)^s\times1.f\times2^{e-127}
$$

|    特殊情况    | 符号位（S） | 阶码（E）  |         尾数（M）         |
| :------------: | :---------: | :--------: | :-----------------------: |
|     **+0**     |     `0`     | `00000000` | `00000000000000000000000` |
|     **-0**     |     `1`     | `00000000` | `00000000000000000000000` |
|     **+∞**     |     `0`     | `11111111` | `00000000000000000000000` |
|     **-∞**     |     `1`     | `11111111` | `00000000000000000000000` |
|    **NaN**     |     `0`     | `11111111` | `10000001000010000010001` |
| **非规格化数** |     `0`     | `00000000` | `10100001000001000000001` |

### 10.浮点数加法

**小阶向大阶看齐，尾数右移**

尾数加完后规格化，最多右规一次

> **舍入法**：
>
> 1. 就近舍入(如果距离两侧相等，则舍入到偶数)
> 2. 正向舍入(取右侧最接近的数)
> 3. 负向舍入(取左侧最接近的数)
> 4. 截断法(直接截取到所需位数)

**阶码无法表示，才会上溢或下溢**

### 11.大小端法和对齐

1. 大端法：低地址高字节

2. 小端法：低地址低字节

3. 半字地址是2的整数倍，字的地址是4的整数倍

	<img src="408.assets/image-20250728110906521.png" alt="image-20250728110906521" style="zoom:80%;" />

4. 结构体对齐：找最大的元素，以它为基准对齐



## 第3章：存储系统

### 1.存储器概述

#### 存储器分类

1. 主存储器：**CPU运行所需的程序和数据**
2. 辅助存储器：**调入主存才能被CPU访问**
3. 高速缓冲存储器：**主存和CPU之间**，存放CPU常用数据

---

1. 随机存储器(RAM)：随机存取，用于**主存(主存系统区，存储操作系统)和缓存**

2. 只读存储器(ROM)：**只读不写**，数据不会更改和丢失，用于**主存**

	> ROM派生的存储器也可写，随机读写，速度慢

3. 串行访问存储器：**按物理位置顺序寻址**

	- 顺序存取存储器：**磁带**，只能按物理顺序，慢
	- 直接存取存储器：**磁盘、光盘**，先寻找某个小区域，在小区域内部顺序查找

---

1. 易失性存储器，**RAM(SRAM+DRAM)**
2. 非易失性存储器，**ROM**

---

1. 破坏性读出，**DRAM**，读出后原信息被破坏，需**再生**
2. 非破坏性读出，**SRAM，ROM**

#### 存储器性能指标

1. 存储容量

2. 单位成本

3. 存储速度

	- 存取时间

	- **存取周期=存取时间+复原时间(破坏性读出)**

		<img src="408.assets/image-20250728114402662.png" alt="image-20250728114402662" style="zoom:80%;" />

	- 主存带宽

#### 存储系统层次结构

<img src="408.assets/image-20250728114541969.png" alt="image-20250728114541969" style="zoom:80%;" />

<img src="408.assets/image-20250728114550001.png" alt="image-20250728114550001" style="zoom:80%;" />

主存和Cache的数据交换由硬件控制，对程序员透明；

主存和辅存的数据交换由硬件和操作系统共同控制，对应用程序员透明

### 2.主存储器

#### SRAM

静态随机存储器(Static Random Access Memory)

**非破坏性读出**

用于**Cache**

#### DRAM

动态随机存储器(Dynamic Random Access Memory)

用于**主存**

**破坏性读出**，需要**刷新和再生**

> **刷新的单位是行**
>
> **同一行两次刷新的间隔通常为2ms**
>
> 刷新方式：
>
> 1. **集中刷新**：集中刷新期间不能访问存储器
> 2. **分散刷新**：前半部分读写，**后半部分刷新**
> 3. **异步刷新**：刷新周期/行数，**均匀间隔**刷新每一行

|       特性       |       刷新（Refresh）        |      再生（Restore）       |
| :--------------: | :--------------------------: | :------------------------: |
|   **触发原因**   |         电容自然漏电         | **破坏性读出**导致电荷丢失 |
|   **触发时机**   | 周期性（如64ms内刷新所有行） |       每次读写操作后       |
| **是否依赖访问** |  独立于CPU访问（后台操作）   |  依赖读写操作（同步完成）  |
|   **数据路径**   |     内部重写，不输出数据     | 数据输出到CPU后写回原地址  |

**刷新是周期性行为，再生只有在读出数据时才会发生**

> **地址引脚复用技术**（重要）
>
> **行地址和列地址用同一组地址线，先后分两次输入**，因此需要**行和列尽可能相等**

#### ROM

**常用于主存和控制存储器CM(存储微程序，在CPU内部)**

1. **MROM**：厂商输入，不能修改
2. **PROM**：用户一次输入，不能修改
3. **EROM**：用户多次修改，耗时长
4. **flash**：不加电可长期保存，通电可快速修改
5. **SDD**：基于flash，性能更优

**存储单元**=存储元件=记忆单元：只存储一个0、1位

**存储矩阵**=存储体=存储阵列

**编址**：把一串存储单元构成一个单位，**按字节编址、按字编址**

#### 多模块存储器

**单体多字存储器**：一次连续取多条指令，要求多条指令物理空间连续

**多体并行存储器**：

- **高位交叉编址**（**顺序**方式）

	<img src="408.assets/image-20250728130949072.png" alt="image-20250728130949072" style="zoom:80%;" />

	**模块号=体号在高地址**，**CPU只能顺序访问每个模块**，**多个模块不能并行**

- **低位交叉编址**（**交叉**方式）

	<img src="408.assets/image-20250728131202423.png" alt="image-20250728131202423" style="zoom:80%;" />

	**并行工作**，假设单模块工作周期10s，总线周期1s，那么至少要有10个模块，否则会浪费总线的速度

	**交叉存储器的时间**：

	<img src="408.assets/image-20250728131751531.png" alt="image-20250728131751531" style="zoom:80%;" />
	
	**交叉方式访存冲突**：
	
	根据**低位模块号得到访存所选的存储器**，如果同一存储器的两次访存相邻m位以内，则会冲突
	
	<img src="408.assets/image-20250728164454616.png" alt="image-20250728164454616" style="zoom:80%;" />
	
	<img src="408.assets/image-20250728164525033.png" alt="image-20250728164525033" style="zoom:80%;" />

### 3.主存储器和CPU的连接

#### 主存的扩展

1. **位扩展**：**数据线多**

	<img src="408.assets/image-20250728165152708.png" alt="image-20250728165152708" style="zoom:80%;" />

	**数据线$D_0\sim D_7$并联**(宽度增加)，**地址线$A_0\sim A_{12}$串联**(宽度不变)

2. **字扩展**：地址线多

	<img src="408.assets/image-20250728165609128.png" alt="image-20250728165609128" style="zoom:80%;" />

	**地址线$A_0\sim A_{13}$片内地址，新增$A_{14}\sim A_{15}$用于片选**(宽度增加)，**数据线$D_0\sim D_7$串联**(宽度不变)

3. **字位同时扩展**：

	<img src="408.assets/image-20250728170011345.png" alt="image-20250728170011345" style="zoom:80%;" />

	8片$16K\times 4$位扩展为$64K\times 8$位

	分为4组，需要**两位地址线片选**

	**组内两片的地址线并联为8位**，组间串联

#### 片选

1. **线选法**：**每条高位地址线仅代表一个芯片**
2. **译码片选法**：高位当作**二进制数**

#### 存储器和CPU连接

1. 存储芯片的选择：**ROM存放系统程序，RAM存放用户程序**
2. 地址线连接：**低位片内地址，高位片选**
3. 数据线连接：**CPU数据线位数必须和芯片数据线位数相同**，否则需要扩展
4. 控制线连接：读写控制线分别于读写控制端相连
5. 片选线连接：片选信号只有当访存控制信号$\overline{MERQ}$为低电平时才有效

### 4.外部存储器

#### 磁盘

<img src="408.assets/image-20250728174049790.png" alt="image-20250728174049790" style="zoom:80%;" />

1. **盘面=磁头**

2. **柱面=磁道**

3. **扇区**，内道的位密度大

4. **记录密度**：道密度，位密度，面密度=道密度\*位密度

5. **磁盘容量**：

  - **非格式化容量**：$记录面数\times柱面数\times每条磁道的磁化单元数$
  - **格式化容量**：$记录面数\times柱面数\times扇区数\times扇区容量$

6. **存取时间**：
$$
  存取时间=寻道时间+旋转延迟时间+传输时间
$$
  寻道时间取**最外到最内时间的一半**

  旋转延迟时间取**转半周的时间**

  **寻道时间最长**

7. **磁盘地址**：

  <img src="408.assets/image-20250728175718255.png" alt="image-20250728175718255" style="zoom:80%;" />

8. **RAID**(独立冗余**磁盘阵列**)：**多个物理盘合成一个逻辑盘**，数据在多个物理盘之间交叉存储，**并行读写**

#### 固态硬盘 SSD

1. **SSD基于闪存flash**

2. **写入前要擦除**，**寿命有限**

3. **磨损均衡**：

	如果反复写入同一区块，该区块会先报废，导致 SSD 提前失效

	磨损均衡算法，让**所有区块均匀磨损**

	- **动态磨损均衡**：优先写入**擦除次数少的块**
	- **静态磨损均衡**：数据长期不变，也让老的块承担读任务，新的块准备承担写任务

### 5.Cache

由**SRAM**组成，通常集成在CPU中

**时间局限性**：同一段代码再次使用

**空间局限性**：相邻地址的数据一起被使用

<img src="408.assets/image-20250728213113432.png" alt="image-20250728213113432" style="zoom:80%;" />

<img src="408.assets/image-20250728230746375.png" alt="image-20250728230746375" style="zoom:80%;" />

#### 命中率

$$
Cache的总命中次数N_c，访存次数N_m，命中率为：\\\\
H=\frac{N_c}{N_c+N_m}
$$

#### 直接映射

<img src="408.assets/image-20250728213738825.png" alt="image-20250728213738825" style="zoom:80%;" />

**每个set只有一个line**

直接映射**地址结构**：

<img src="408.assets/image-20250728213003606.png" alt="image-20250728213003606" style="zoom:80%;" />
$$
set号=line号 = Cache行号 \ \% \ Cache总行数
$$
先**根据Cache行号找到line**，然后**比较line的tag和地址高位的tag**，相同则匹配成功

#### 全相联映射

**set=1，所有line都在这一个set中**

全相联映射**地址结构**：

<img src="408.assets/image-20250728213849069.png" alt="image-20250728213849069" style="zoom:80%;" />

只有一个set，因此不需要中间的set号，**直接从头到尾比较line的tag和地址的tag**

#### 组相联映射

**每个set中有多个line**，具体数量等于组数，比如二路组相联映射

<img src="408.assets/image-20250728214613991.png" alt="image-20250728214613991" style="zoom:80%;" />

组相联映射**地址结构**：

<img src="408.assets/image-20250728214808192.png" alt="image-20250728214808192" style="zoom:80%;" />
$$
set号 = 组号 \ \% \ Cache总组数
$$
先**根据组号找到set**，然后**依次比较set中每一个line的tag和地址高位的tag**

> 例题：
>
> <img src="408.assets/image-20250728215946938.png" alt="image-20250728215946938" style="zoom:80%;" />
>
> 地址结构应该是：19 3 6 位
>
> 每个line的结构如下：注意**line最后的数据是整个64B，不像地址只需要3位给出offset即可**
>
> <img src="408.assets/image-20250728220126650.png" alt="image-20250728220126650" style="zoom:80%;" />
>
> <img src="408.assets/image-20250728220323231.png" alt="image-20250728220323231" style="zoom:80%;" />
>
> <img src="408.assets/image-20250728220444479.png" alt="image-20250728220444479" style="zoom:80%;" />

> **全相联命中率最高，直接映射命中率最低**

#### 替换算法

RANDOM

FIFO

**LRU：看谁最久没用**(LFU看谁用的最少)，**每个line新增一个计数位(LRU替换位)**

#### Cache一致性

一致性问题：**写数据**时，怎么**保持Cache和Memory的一致性**

**写，Cache命中**：

1. **全写法**：数据**同时写入Cache和主存**（复杂）
2. **回写法**：只写入Cache，**Cache被替换时才写入主存**

**写，Cache不命中**：

1. **写分配法**：写主存，把**主存块调入Cache**（复杂）
2. **非写分配法**：只写主存，**不把主存块调入Cache**

全写法+非写分配法；回写法+写分配法（**记住只有一个复杂即可**）

通常采用：回写法+写分配法

### 6.虚拟存储器

**虚地址=逻辑地址**：编程采用的地址

**实地址=物理地址**：实际主存单元的地址

**虚拟存储器只能采用回写法**：**虚拟地址对应的内容是辅存中的内容**，全写法会频繁访问辅存，时间开销过大

#### 页式虚拟存储器

**页表项**：**有效位(是否在内存)+脏位(是否被修改，用于回写法)+引用位(用于LRU)+物理页号**

<img src="408.assets/image-20250728223117040.png" alt="image-20250728223117040" style="zoom:80%;" />

#### 快表 TLB

**SRAM**实现，**集成在CPU内部的Cache中**，目的是**减少访问次数，因为页表在内存中**

#### 页式虚拟存储流程图

<img src="408.assets/image-20250728223703097.png" alt="image-20250728223703097" style="zoom:80%;" />

<img src="408.assets/image-20250728223926858.png" alt="image-20250728223926858" style="zoom:80%;" />

<img src="408.assets/image-20250728224056795.png" alt="image-20250728224056795" style="zoom:80%;" />

#### 段式虚拟存储器

**段的长度可变**，因此段表项需要给出段长

<img src="408.assets/image-20250728224322558.png" alt="image-20250728224322558" style="zoom:80%;" />

#### 段页式虚拟存储器

每个程序对应一个段

**每个段有整数个页**

**虚地址=段号+页号+页内地址**

#### Cache vs 虚存

1. **Cache解决CPU和主存速度不匹配问题**，而**虚存是解决主存容量**
2. Cache不命中CPU还可以直接访问主存，而**虚存不命中就只能先把辅存调入主存，辅存不能和CPU直接通信**



## 第4章：指令系统

### 1.ISA

**ISA(指令集体系结构)**：

1. **指令格式**（操作码、操作数、寻址模式）
2. **寄存器架构**（通用/特殊寄存器，如PC、SP）
3. **数据类型与运算**（整数/浮点指令，如ADD、MOV）
4. **内存模型**（地址空间、字节序、对齐）
5. **控制流指令**（分支、跳转、函数调用）
6. **特权级别**（用户态/内核态权限隔离）

### 2.指令

<img src="408.assets/image-20250729114443600.png" alt="image-20250729114443600" style="zoom:80%;" />

单字长指令：指令字长=机器字长，访存一次，一个存取周期

双字长指令：指令字长=2机器字长，访存2次，2个存取周期

---

定长指令字结构：所有指令长度相等

变长指令字结构

---

零地址指令：**一般和堆栈有关**，ret

一地址指令：**另一个操作数隐式存在规定寄存器或为常数**，inc、dec

二地址指令：intel格式下，**目的操作数在中间**，add

三地址指令：**前两个操作数是原操作数**，**第三个是目的操作数**

四地址指令：**第四个操作数是下一条指令的地址**

### 3.扩展操作码

<img src="408.assets/image-20250729120056544.png" alt="image-20250729120056544" style="zoom:80%;" />

15条指令是因为要留一位到下一级，**保证指令前缀不相同**

编码方式不唯一，可根据题目需求而变

### 4.指令寻址

#### 顺序寻址

PC+1

#### 跳跃寻址

转移指令**修改PC的值**，因为CPU总是根据PC取下一条指令

### 5.数据寻址

<img src="408.assets/image-20250729121730835.png" alt="image-20250729121730835" style="zoom:80%;" />

需要新增一个**寻址特征**字段，指明数据寻址的方式

#### 隐含寻址

**另一个操作数由累加器ACC提供**

```asm
MUL  BL      ; AL * BL → 结果存 AX（隐含 AL/AX）
DIV  CL      ; AX / CL → 商存 AL，余数 AH（隐含 AX）
IN   AL, 60h ; 从端口 60h 读取数据到 AL（隐含 AL）
OUT  21h, AL ; 将 AL 的值写入端口 21h（隐含 AL）
```

#### 立即寻址

寻址特征是`#`

<img src="408.assets/image-20250729122733486.png" alt="image-20250729122733486" style="zoom:80%;" />

```asm
MOV  EAX, 42          ; 将立即数 42 存入 EAX（32位）
MOV  RCX, 0x12345678  ; 将 64 位立即数 0x12345678 存入 RCX
MOV  DL, 0xFF         ; 将 8 位立即数 0xFF 存入 DL
```

#### 直接寻址

直接给出存放操作数的地址

<img src="408.assets/image-20250729123017342.png" alt="image-20250729123017342" style="zoom:80%;" />

```asm
MOV  EAX, [0x8040000]    ; 将内存地址 0x8040000 处的 32 位数据加载到 EAX
MOV  [0x1000], BL        ; 将 BL 的值存入内存地址 0x1000
CMP  DWORD [0x2000], 42  ; 比较内存地址 0x2000 处的值与立即数 42
```

#### 间接寻址

给出的地址的内容，才是存放操作数的地址

<img src="408.assets/image-20250729123200890.png" alt="image-20250729123200890" style="zoom:80%;" />

#### 寄存器寻址

寄存器的内容是操作数

<img src="408.assets/image-20250729123302755.png" alt="image-20250729123302755" style="zoom:80%;" />

```asm
MOV  EAX, EBX      ; 将 EBX 的值复制到 EAX（32 位）
MOV  CL, DL        ; 将 DL 的值复制到 CL（8 位）
MOV  RSI, RDX      ; 将 RDX 的值复制到 RSI（64 位）
```

#### 寄存器间接寻址

寄存器的内容是存放操作数的地址

<img src="408.assets/image-20250729123401827.png" alt="image-20250729123401827" style="zoom:80%;" />

```asm
MOV  EAX, [EBX]      ; 将 EBX 寄存器指向的内存地址处的 32 位数据加载到 EAX
MOV  [EDI], CL       ; 将 CL 的值存入 EDI 寄存器指向的内存地址
CMP  DWORD [ESI], 10 ; 比较 ESI 指向的内存值与立即数 10
```

#### 相对寻址

**PC和给出的数相加**，得到存放操作数的地址，常用于**jmp**指令

<img src="408.assets/image-20250729123528495.png" alt="image-20250729123528495" style="zoom:80%;" />

```asm
JMP  0x8          ; 向前跳转到当前指令后 8 字节处
JZ   label        ; 若零标志（ZF=1）则跳转到 label（编译为相对偏移）
```

<img src="408.assets/image-20250729165047953.png" alt="image-20250729165047953" style="zoom:80%;" />

即**取出指令时，PC就会增加指令的长度**

#### 基址寻址

**基址+固定偏移**

<img src="408.assets/image-20250729165216853.png" alt="image-20250729165216853" style="zoom:80%;" />

```asm
MOV  EAX, [EBX + 8]      ; EAX = *(EBX + 8)（32位偏移）
MOV  [ECX - 4], DL       ; *(ECX - 4) = DL（8位偏移）
```

#### 变址寻址

**基址+变址\*比例因子**，常用于**数组遍历**

<img src="408.assets/image-20250729165902636.png" alt="image-20250729165902636" style="zoom:80%;" />

```asm
MOV  EDX, [EAX + ESI*4]    ; EDX = *(EAX + ESI*4)（适用于32位数组，如 int[]）
MOV  CX, [EBX + EDI*2]     ; CX = *(EBX + EDI*2)（适用于16位数组，如 short[]）
```

在数组遍历中，**A是固定值比如数组首地址，IX寄存器的值是i**

**基址寻址vs变址寻址**：**基址寻址的A可变，变址寻址的A不可变**

#### 堆栈寻址

大多数为**无操作数指令**，因为隐式使用了`SP`

#### 访存次数

**A为形式地址，其内容是EA**

**EA为有效地址，其内容是操作数**

<img src="408.assets/image-20250729171034994.png" alt="image-20250729171034994" style="zoom:80%;" />

### 6.通用寄存器组

<img src="408.assets/image-20250729171354148.png" alt="image-20250729171354148" style="zoom:80%;" />

​	`EBP`和`ESP`的用法较为特殊，其它寄存器的用法比较灵活（比如用于变量、函数传参）

### 7.汇编语言格式

分为**AT&T格式**(CSAPP采用)和**Intel格式**(考研采用)

|        区别点         |         AT&T 格式          |          Intel 格式           |            举例对比（相同功能指令）            |
| :-------------------: | :------------------------: | :---------------------------: | :--------------------------------------------: |
|    **大小写敏感**     |       只能用小写字母       |     不敏感（大小写均可）      |      `movl %eax, %ebx` vs `MOV EAX, EBX`       |
|    **操作数顺序**     |    源→目的（从左到右）     |      目的←源（从右到左）      |        `addl $5, %eax` vs `ADD EAX, 5`         |
| **寄存器/立即数前缀** | 寄存器加 `%`，立即数加 `$` |            无前缀             |       `movl $42, %ecx` vs `MOV ECX, 42`        |
|   **内存寻址符号**    |         使用 `()`          |           使用 `[]`           |    `movl (%edx), %eax` vs `MOV EAX, [EDX]`     |
|   **复杂寻址格式**    | `disp(base, index, scale)` | `[base + index*scale + disp]` |    `8(%edx,%eax,2)` vs `[EDX + EAX*2 + 8]`     |
|   **数据长度指定**    |   操作码后加 `b`/`w`/`l`   |    显式注明 `byte ptr` 等     | `movb %al, (%ebx)` vs `MOV BYTE PTR [EBX], AL` |

### 8.算数和逻辑运算指令

#### mov

**两个操作数不能都是内存**

#### push

**先将`ESP`减4**

#### pop

**先出栈，然后`ESP`加4**

#### add/sub

**结果保存到第一个操作数(目的操作数)**

注意减法是**前减后**

``` asm
sub eax, 10	; eax = eax - 10，前减后
```

#### inc/dec

单操作数

#### imul

**有符号整数乘法**

**单操作数**，**被乘数隐式存储在`eax`，结果存储在`edx:eax`**

**双操作数**，**结果只保留低位**，并把低位存到第一个操作数(**第一个操作数必须是寄存器**)

**三操作数**，后两个乘积存到第一个操作数(**第一个操作数必须是寄存器**)

#### idiv

**有符号整数除法**

**单操作数**，**被除数隐式存储在`edx:eax`，商存储在`eax`，余数存储在`edx`**

#### and/or/xor

结果存到第一个操作数

#### not

取反

#### neg

取相反数

#### shl/sal/shr/sar

a->arithmetic，中间为`a`表示算数左移/右移

### 9.控制流指令

`IP`指针不能直接操作，只能自动更新

#### jmp

#### jcondition

#### cmp/test

**都只影响条件码**

`cmp`：功能相当于`sub`

`test`：功能相当于`and`

#### call/ret

`call`：先把**当前PC入栈**，然后跳转

`ret`：先**出栈赋给PC**，返回调用位置

### 10.过程调用

#### 调用者保存寄存器

`eax, ecx, edx`

P调用Q，由**P将这些寄存器保存到栈中**，返回后**由P恢复这些寄存器的值**

#### 被调用者保存寄存器

`ebx, esi, edi`

P调用Q，由**Q将这些寄存器保存到栈中**，返回前**由Q恢复这些寄存器的值**

#### ebp和esp

**`ebp`指示栈帧起始位置(高地址)**，**`esp`指示栈顶(低地址)**

```asm
section .text
global _start

_start:
    CALL func      ; 1. CALL 隐含 PUSH 返回地址（ESP -= 4）
    MOV  EAX, 1    ; 4. 退出程序
    INT  0x80

func:
    PUSH EBP       ; 2. 保存调用者的 EBP（ESP -= 4）
    MOV  EBP, ESP  ; 3. 设置当前栈帧基址（EBP = ESP）
    SUB  ESP, 8    ; 为局部变量分配 8 字节（ESP -= 8）

    ; 局部变量 [EBP-4] 和 [EBP-8]
    MOV  DWORD [EBP-4], 10  ; 局部变量1 = 10
    MOV  DWORD [EBP-8], 20  ; 局部变量2 = 20

    ADD  ESP, 8    ; 释放局部变量空间（ESP += 8）
    POP  EBP       ; 恢复调用者的 EBP（ESP += 4）
    RET            ; 返回（隐含 POP EIP，ESP += 4）
```

**可以看到`ebp`在`esp`的上面，`ebp > esp`，帧的范围从小到大是 `[esp, ebp]`**

<img src="408.assets/image-20250729180031391.png" alt="image-20250729180031391" style="zoom:80%;" />

### 11.CISC和RISC

**CISC(复杂指令系统计算机)、RISC(精简指令系统计算机)**

![image-20250729183019019](408.assets/image-20250729183019019.png)



## 第5章：中央处理器

### 1.CPU的组成

CPU=运算器+控制器

#### 运算器

ALU+暂存寄存器+ACC+GPRs+PSW+移位寄存器(SR)+计数器(CT)

#### 控制器

PC+IR+指令译码器(ID)

#### 用户可见寄存器

**GPRs、PSW、PC**

#### 用户不可见寄存器

**MAR、MDR、IR、暂存寄存器、ACC、移位寄存器(SR)**

### 2.三个周期

#### 时钟周期

$$
T_{时钟}=\frac{1}{主频}
$$

#### 机器周期

$$
1机器周期 = n个时钟周期
$$

#### 指令周期

一条指令执行完成的时间，等于**多个机器周期**

<img src="408.assets/image-20250729213038247.png" alt="image-20250729213038247" style="zoom:80%;" />

### 3.指令周期的数据流

#### 取指周期

从**主存中取出指令**放到**IR**中

<img src="408.assets/image-20250729213642303.png" alt="image-20250729213642303" style="zoom:80%;" />

#### 间址周期

**取操作数的有效地址**

<img src="408.assets/image-20250729213914430.png" alt="image-20250729213914430" style="zoom:80%;" />

#### 执行周期

**取操作数**

#### 中断周期

CPU在**每条指令结束后，都要发中断查询信号**

<img src="408.assets/image-20250729214220595.png" alt="image-20250729214220595" style="zoom:80%;" />

### 4.指令执行方案

#### 单周期处理器

**所有指令都在一个时钟周期完成**，CPI=1

#### 多周期处理器

**指令需要多个时钟周期**，CPI>1

#### 流水线处理器

每个周期启动一条指令，每个周期内执行不同指令的不同阶段

### 5.数据通路

数据通路=**指令执行过程中经过的部件**，这些部件分为组合逻辑元件和时序逻辑元件

#### 组合逻辑元件

组合逻辑元件**不含存储信号的记忆单元**，包括**加法器、算术逻辑单元(ALU)、译码器、多路选择器、三态门**

<img src="408.assets/image-20250729215416199.png" alt="image-20250729215416199" style="zoom:80%;" />

**多路选择器**：根据**Select信号选择哪个信号被输出**

**三态门**：**EN=1，in=out；EN=0，阻隔态**

#### 时序逻辑元件

组合逻辑元件**不含存储信号的记忆单元**，输出不仅和输入有关，**还和之前的输入有关**

#### 单总线方式

<img src="408.assets/image-20250729221024141.png" alt="image-20250729221024141" style="zoom:80%;" />

**能输出到总线的部件均通过一个三态门与内部总线相连**，控制该部件与内部总线间的连接与断开

<img src="408.assets/image-20250729221353312.png" alt="image-20250729221353312" style="zoom:80%;" />

<img src="408.assets/image-20250729221506473.png" alt="image-20250729221506473" style="zoom:80%;" />

### 6.数据通路中的控制信号

#### 寄存器->总线

```asm
(PC)->MAR	;PCout 和 MARin 有效，PC->MAR
```

#### 从主存取数据

```asm
(PC)->MAR						;PCout 和 MARin 有效，现行指令地址→MAR
MEM(MAR)->MDR, (PC) + 1->PC		;MDRin 有效，cu 发出读命令，取出指令后 PC+1
(MDR)->IR						;MDRout 和 IRin 有效，现行指令→IR
```

#### 数据写入主存

```asm
(R1)->MDR		;R1out 和 MDRin 有效
(R2)->MAR		;R2out 和 MARin 有效
MDR->MEM(MAR)	;MDRout 有效，cu 发出写命令
```

#### ALU执行运算

在单总线数据通路中，**每一时刻总线上只有一个数据有效**。因为 ALU 是一个没有存储功能的组合逻辑元件，在其执行运算时必须保持两个输入端同时有效，所以**先将一个操作数经内部总线送入暂存器 Y 保存**，Y 的内容在 ALU 的左输入端始终有效，再将另一个操作数经内部总线直接送到 ALU 的右输入端。此外，**ALU 的输出端也不能直接与总线相连**，否则其输出会通过总线反馈到输入端，影响运算结果，因此将**运算结果暂存在暂存器 Z 中**：

```asm
(R1)->Y			;Rlout 和 Yin 有效，操作数→Y
(ACC)+(Y)->Z	;ACCout 和 ALUin 有效，CU 向 ALU 发出加命令，结果→z
(Z)->ACC		;Zout 和 ACCin 有效，结果→ACC
```

#### 修改PC的值

```asm
AD(IR)->PC		;IRout和PCin有效
```

### 7.硬布线控制器

> 控制器可分为硬布线控制器和微程序控制器

硬布线控制器由**组合门电路**和**触发器**构成

其**CU的输出**来自于：**操作码译码电路，节拍发生器，执行单元的反馈信息(标志)**

**RISC采用硬布线控制器**

### 8.微程序控制器

#### 基本概念

$$
机器指令=1微程序 \\\\
微程序=n微指令 \\\\
微指令=n微命令 \\\\
1微命令对应1微操作
$$

**微命令**有**相容性**和**互斥性**

硬布线控制器也有微命令和微操作的，非微程序控制器独有

微周期：取出并执行一条微指令的全部时间

**微程序是透明的**

#### 组成结构

<img src="408.assets/image-20250730115744993.png" alt="image-20250730115744993" style="zoom:80%;" />

**控制存储器CM**，存储**微程序**，**CPU内部**，**ROM**实现

> 主存储器，存储程序和数据，CPU外部，DRAM实现

**微指令地址寄存器$\mu PC$**：微指令在控制存储器中的微地址

**微指令寄存器$\mu IR$**：存放待执行的微指令

**工作流程**：

```asm
1. 取指微程序入口地址->uPC
2. uPC->CM->uIR	;取指微程序送入uIR
3. 目标微指令->uPC
4. uPC->CM->uIR	;目标微指令送入uIR执行
5. 重复上述步骤，执行下一条微指令
```

可**将取值相关的微指令合并为一个微程序**，以便每次执行微指令时都调用

#### 微指令编码方式

1. **直接编码方式**：**每一位都代表一个微命令**

	<img src="408.assets/image-20250730120524803.png" alt="image-20250730120524803" style="zoom:80%;" />

2. **字段直接编码方式**：（重要）

	把控制字段分割为若干小段

	**互斥微命令放到同一段，非互斥微命令放到不同段**

	<img src="408.assets/image-20250730120825151.png" alt="image-20250730120825151" style="zoom:80%;" />

	**每个小段要留出一位，表示该段所有微命令都不执行**

#### 微指令的格式

1. **水平型微指令**：上述的**直接编码方式和字段直接编码方式均属于水平型微指令**

	**1水平型微指令=n并行执行的微命令**

	<img src="408.assets/image-20250730123413572.png" alt="image-20250730123413572" style="zoom:80%;" />

2. **垂直型微指令**：只能定义和执行**一条微命令**

	<img src="408.assets/image-20250730123614635.png" alt="image-20250730123614635" style="zoom:80%;" />

#### 两种控制器的比较

<img src="408.assets/image-20250730123759555.png" alt="image-20250730123759555" style="zoom:80%;" />

### 9.异常和中断

#### 异常和中断的区别

|    对比维度     |             异常（Exception）              |                中断（Interrupt）                |
| :-------------: | :----------------------------------------: | :---------------------------------------------: |
|   **触发源**    |   CPU**内部执行指令**时产生的错误或事件    |       **外部硬件**设备或定时器发出的信号        |
|   **同步性**    |          同步（与当前指令强相关）          |        异步（与当前指令无关，随机发生）         |
|  **典型场景**   |     除零错误、缺页异常、非法指令、溢出     |        键盘输入、磁盘IO完成、定时器到期         |
|  **响应时机**   |        立即处理（发生在指令执行中）        |  通常在指令边界处理（指令周期的**中断周期**）   |
| **是否可屏蔽**  |            不可屏蔽（必须处理）            | 可屏蔽（通过中断控制器配置，如CLI指令关闭中断） |
|  **返回地址**   | 可能指向故障指令或下一条指令（如缺页异常） |            始终指向下一条未执行指令             |
| **处理优先级**  |          高（直接影响程序正确性）          |         依赖中断优先级（如硬件IRQ等级）         |
|  **硬件支持**   |       由CPU**内部异常处理单元**管理        |       依赖**中断控制器**（如APIC、8259A）       |
|  **典型用途**   |     处理程序错误、内存管理、特权级切换     |          响应外部事件、实现多任务调度           |
| **示例（x86）** |    `#DE`（除零异常）、`#PF`（缺页异常）    |    `IRQ0`（定时器中断）、`IRQ1`（键盘中断）     |

所有异常和中断都是由**硬件检测**的

#### 异常的分类

|     异常类型      |             触发条件             |           处理行为           |     典型示例（x86）     | 是否可恢复 | 属于     |
| :---------------: | :------------------------------: | :--------------------------: | :---------------------: | :--------: | -------- |
| **故障（Fault）** |      指令执行**检测到错误**      | 修正错误后**重新执行原指令** |  `#PF`（**缺页异常**）  |     是     | 软件中断 |
| **自陷（Trap）**  |      指令执行后**主动触发**      |    继续执行**下一条指令**    | `INT 3`（**调试断点**） |     是     | 软件中断 |
| **终止（Abort）** | **严重错误**（无法定位具体指令） |    **终止程序**或系统复位    |  `#MC`（机器检查异常）  |     否     | 硬件中断 |

#### 中断的分类

CPU **每执行完一条指令就检查中断请求信号线**，若检测到中断请求，则进入中断响应周期

**可屏蔽中断**：可屏蔽中断请求线**INTR**发送给CPU

**不可屏蔽中断**：不可屏蔽中断请求线**NMI**发送给CPU

> **异常不能被屏蔽**

#### 异常和中断的处理过程

1. **关中断**：**禁止响应新的中断**，IF触发器=0
2. **保存断点和程序状态**：当前**程序断点以及PSW**保存到**栈**
3. **识别异常和中断并跳到相应处理程序**：**异常采用软件识别**，**中断软件硬件识别均可**

<img src="408.assets/image-20250730171151716.png" alt="image-20250730171151716" style="zoom:80%;" />

### 10.指令流水线

#### 概念

|     维度     |          流水线技术          |          超标量处理机          |
| :----------: | :--------------------------: | :----------------------------: |
| **并行方式** | 时间并行（**指令步骤重叠**） | 空间并行（**多指令同时执行**） |
| **硬件成本** |              低              |       高（需多执行单元）       |

1. **取指**（IF，instruction fetch）：从指令存储器或 Cache 中取指令
2. **译码**/读寄存器（ID，instruction decode）：对指令进行译码，同时从寄存器中取操作数
3. **执行**/计算地址（EX，excute）：执行运算或计算地址
4. **访存**（MEM，memory）：对存储器进行读/写操作
5. **写回**（WB，write back）：将指令执行结果写回寄存器

#### 流水线的实现

<img src="408.assets/image-20250730172708408.png" alt="image-20250730172708408" style="zoom:80%;" />

每段后面有一个**流水段寄存器**，用于锁存本段处理完的数据，防止数据冲突

### 11.流水线的冒险

<img src="408.assets/image-20250730174100310.png" alt="image-20250730174100310" style="zoom:80%;" />

#### 结构冒险

不同指令在**同一时刻争用同一功能部件**而形成的冲突

<img src="408.assets/image-20250730174219131.png" alt="image-20250730174219131" style="zoom:80%;" />

t=4时，**第一条指令的MEM和第四条指令的ID都要访存**

**解决方法**：

1. 将**第四条指令暂停一个时钟周期**
2. 设置多个功能部件
3. **数据Cache和指令Cache分离**

#### 数据冒险

**后面指令引用前面指令的结果，前面指令的结果还没产生**

```asm
add R1, R2, R3
sub R4, R1, R5
```

<img src="408.assets/image-20250730175249912.png" alt="image-20250730175249912" style="zoom:80%;" />

**解决方法**：

1. **延迟读指令(3个时钟周期)**：

	<img src="408.assets/image-20250730175344644.png" alt="image-20250730175344644" style="zoom:80%;" />

2. **旁路转发技术**：

	R1在EX阶段已得出，**直接从EX的流水段寄存器中取出送到ALU的输入端**

	<img src="408.assets/image-20250730180116439.png" alt="image-20250730180116439" style="zoom:80%;" />

3. **load-use型数据冒险**：

	**load指令要在MEM结束后才能得到值**，而**op指令在EX就需要数据**，**来不及使用旁路转发技术**

	可**将op指令阻塞一个时钟周期，再使用旁路转发技术**

	```asm
	load, r2, l2(r1)
	add r4, r3, r2
	```

	<img src="408.assets/image-20250730180840226.png" alt="image-20250730180840226" style="zoom:80%;" />

#### 控制冒险

**不知道是否要跳转，因为MEM阶段结束才会更新PC的值**

**解决方法**：

1. **阻塞后续指令**，延迟损失时间片C

	<img src="408.assets/image-20250730181053342.png" alt="image-20250730181053342" style="zoom:80%;" />

2. 对转移指令进行**分支预测**，预测失败则丢弃当前分支，重新执行正确分支

### 12.流水线的性能标准

**吞吐率(TP)**：
$$
\mathrm{TP}=\frac{n}{T_k} \\\\
\mathrm{TP}=\frac{n}{(k+n-1)\Delta t}
$$
**加速比(S)**：
$$
S=\frac{T_0}{T_k} \\\\
T_0\text{表示不使用流水线的总时间；}T_k\text{表示使用流水线的总时间} \\\\
S=\frac{kn\Delta t}{(k+n-1)\Delta t}=\frac{kn}{k+n-1}
$$

### 13.高级流水线技术

#### 超标量流水线技术

<img src="408.assets/image-20250730184004071.png" alt="image-20250730184004071" style="zoom:80%;" />

#### 超长指令字技术

把**多条能并行执行的指令组合成一个超长的指令字**

#### 超流水线技术

**提高流水线级数**(5->10/15或更多)

### 14.多处理器

#### 架构

| 架构类型 |                全称                |                          核心特点                          |  数据/指令流关系  |        典型应用场景         |              代表硬件               |
| :------: | :--------------------------------: | :--------------------------------------------------------: | :---------------: | :-------------------------: | :---------------------------------: |
| **SISD** |   Single Instruction Single Data   |             单指令流单数据流，**串行执行指令**             | 1指令流 + 1数据流 | 传统单核CPU、简单嵌入式系统 |      Intel 8086、ARM Cortex-M       |
| **SIMD** |  Single Instruction Multiple Data  |  单指令流多数据流，一**条指令并行处理多个数据**（向量化）  | 1指令流 + N数据流 | 图像处理、科学计算、AI推理  |  Intel AVX/SSE、GPU（Shader Core）  |
| **MISD** |  Multiple Instruction Single Data  | 多指令流单数据流，**多条指令处理同一数据**（极少实际应用） | N指令流 + 1数据流 | 容错计算（如航天冗余控制）  |    **理论架构，无广泛商用硬件**     |
| **MIMD** | Multiple Instruction Multiple Data |      多指令流多数据流，**完全并行**（多核/多机协作）       | N指令流 + N数据流 | 分布式系统、多核CPU、云计算 | Intel Core i7、AMD EPYC、NVIDIA GPU |

#### 硬件多线程

|      对比维度      |    细粒度多线程（FGMT）    |       粗粒度多线程（CGMT）       |          同时多线程（SMT）           |
| :----------------: | :------------------------: | :------------------------------: | :----------------------------------: |
|  **线程切换时机**  |   **每时钟周期切换线程**   | **线程阻塞（如缓存缺失）时切换** |  **每周期动态分配指令槽给多个线程**  |
|    **并行粒度**    |       指令级（极细）       |          任务级（较粗）          |         指令级（混合细粒度）         |
|    **硬件需求**    | 多组寄存器，轻量级切换逻辑 |    单组寄存器，高延迟切换逻辑    | 多组寄存器、乱序执行引擎、复杂调度器 |
|   **吞吐量提升**   |    高（隐藏单周期延迟）    |       中（隐藏长延迟阻塞）       |       极高（充分利用执行单元）       |
|    **资源冲突**    |   低（线程轮流使用资源）   |         中（切换频率低）         |       高（多线程竞争执行单元）       |
|    **典型应用**    |  高延迟隐藏（如内存访问）  |      长延迟任务（如IO阻塞）      |       通用计算（如多任务并行）       |
|    **代表架构**    |     Tera MTA（已淘汰）     |        Sun UltraSPARC T1         |    Intel Hyper-Threading、AMD SMT    |
| **时钟周期利用率** |      高（无空闲周期）      |        中（切换时有开销）        |         极高（动态填充气泡）         |
|   **编程复杂度**   |     低（硬件自动调度）     |         中（需任务划分）         |         高（需考虑资源竞争）         |

#### 多核CPU

<img src="408.assets/image-20250730185041683.png" alt="image-20250730185041683" style="zoom:80%;" />

**Cache独立，内存共享**

**使用多线程充分利用每个核**

**真正意义上的并行**



## 第6章：总线

### 1.总线概念

**分时**：**同一时间只能有一个主设备控制总线**

**共享**：总线上能连多个设备，它们共享总线上的信息

主设备：获得总线控制权的设备

从设备：只能被动响应主设备

总线的**特征**：机械特征，电气特征，功能特征

### 2.总线的分类

#### 片内总线

**芯片内部**的总线

#### 系统总线

各**功能部件(CPU、主存、IO接口)间**相互连接的总线

**数据总线**：数据、指令和中断类型号，**双向**

**地址总线**：主存单元或 IO 端口的地址，**单向**

**控制总线**：各种命令、反馈和定时信号

#### IO总线

连接中低速的IO设备，如 **USB、PCI 总线**

#### 通信总线

**计算机系统之间**或计算机系统**与其他系统(如远程通信设备、测试设备)之间**传送信息的总线，也称**外部总线**

### 3.系统总线的结构

#### 单总线结构

单总线结构将**CPU、主存、IO设备**(通过IO接口)都挂在**一组**总线上

<img src="408.assets/image-20250730212012330.png" alt="image-20250730212012330" style="zoom:80%;" />

**注意**：**“单”不是一条总线**，而是**一组**总线

#### 双总线结构

一条**主存总线**：**CPU、主存和通道之间**传送数据

一条**IO总线**：**多个外部设备与通道之间**传送数据

#### 三总线结构

一条**主存总线**：**CPU、主存和通道之间**传送数据

一条**IO总线**：**多个外部设备与通道之间**传送数据

一条**DMA总线**：**内存和高速外设之间**直接传送数据

> DMA=Direct Memory Access，直接存储器访问

#### 4.总线的性能指标

1. 总线时钟周期=时钟周期
2. 总线时钟频率
3. 总线传输周期：一次总线操作所需的总时间
4. **总线工作频率**
5. **总线宽度**：传输的**数据位数**，32根=32位总线
6. **总线带宽**：**单位时间**最多**传输的位数**，B/s，**总线带宽 = 总线工作频率×(总线宽度/8)**
7. 总线复用：一根总线用做不同功能，比如**地址/数据复用**

### 5.总线事务

请求阶段：主设备(**CPU或DMA**)发出总线传输请求

仲裁阶段：下一个传输周期的总线使用权授予某个申请者

寻址阶段：给出要访问的从设备地址及有关命令

传输阶段：主模块和从模块进行数据交换

释放阶段：让出总线使用权

---

|              |                突发传送（Burst Transfer）                 |        非突发传送（Non-Burst Transfer）        |
| :----------: | :-------------------------------------------------------: | :--------------------------------------------: |
|   **定义**   | 在**单次操作中连续传输多个数据单元**（地址自动递增/固定） | **每次操作仅传输单个数据单元**，需重复发起请求 |
| **传输效率** |                高（减少地址/控制信号开销）                |         低（每次传输均需完整握手流程）         |
| **总线占用** |              短时集中占用，减少总线切换频率               |        频繁占用/释放总线，增加仲裁开销         |
| **典型场景** |           高速连续数据（如视频流、DDR内存读写）           |    随机小数据（如寄存器配置、低速外设通信）    |

**突发传送**：**单次握手，连续传输**

```
| 地址/控制信号 | 数据1 | 数据2 | 数据3 | ... | 数据N | （单次握手，连续传输）
```

**非突发传送**：**每次传输独立握手**

```
| 地址/控制信号 | 数据1 | 地址/控制信号 | 数据2 | ... | （每次传输独立握手）
```

### 6.总线定时

|                |                           工作原理                           |                       特点                       |               适用场景               |                            优缺点                            |
| :------------: | :----------------------------------------------------------: | :----------------------------------------------: | :----------------------------------: | :----------------------------------------------------------: |
|  **同步定时**  | 所有操作由**统一的时钟信号**（CLK）驱动，信号在时钟边沿采样。 |    - 严格时序控制 - 信号简单 - 依赖时钟稳定性    |      高速片上总线（如AXI、AHB）      | **优点**：设计简单，适合高频 **缺点**：时钟偏移（Skew）影响可靠性 |
|  **异步定时**  |    无全局时钟，通过**握手信号**（如`REQ/ACK`）协调传输。     | - **自适应设备速度** - 无时钟约束 - 控制逻辑复杂 |       低速外设（如UART、I2C）        | **优点**：兼容不同速度设备 **缺点**：吞吐量低，延迟不可预测  |
| **半同步定时** | **结合同步时钟和异步握手**（如时钟+`WAIT`信号），设备可请求延长周期。 |      - 折中同步与异步优点 - 可动态调整时序       |   中速设备（如SDRAM、早期PCI总线）   |    **优点**：灵活性高 **缺点**：需额外控制线（如`WAIT`）     |
| **分离式定时** | 将传输分解为**请求（Request）和应答（Response）两个阶段**，中间可插入其他操作。 |   - 高总线利用率 - 支持乱序完成 - 控制逻辑复杂   | 高性能总线（如PCIe、HyperTransport） | **优点**：隐藏延迟，提升并行度 **缺点**：硬件开销大（需标签匹配逻辑） |



## 第7章：IO系统

### 1.IO接口

**实现主机与外部设备的信息转换**

> <img src="408.assets/image-20250730221414428.png" alt="image-20250730221414428" style="zoom:80%;" />
>
> <img src="408.assets/image-20250730221426912.png" alt="image-20250730221426912" style="zoom:80%;" />

<img src="408.assets/image-20250730221848147.png" alt="image-20250730221848147" style="zoom:80%;" />

数据线：读/写数据、状态信息、控制信息和中断类型号

地址线：要访问的IO接口中的寄存器的地址

控制线：读/写控制信号

### 2.IO端口

**IO端口**：IO接口电路中**可被 CPU 直接访问的寄存器**，分为**数据、状态、控制端口**

IO端口要想能够被 CPU 访问，就必须要**对各个IO端口进行编址**，**每个端口对应一个端口地址**

**独立编址**：IO端口的地址空间和主存地址空间独立

**统一编址**：IO端口的地址和主存其它单元的地址在同一内存地址空间的不同位置

### 3.程序查询方式

**直接由 CPU 执行程序实现**

**CPU 周期或持续地查询设备状态**，**直到外设准备就绪**

<img src="408.assets/image-20250730223357830.png" alt="image-20250730223357830" style="zoom:80%;" />

<img src="408.assets/image-20250730223622762.png" alt="image-20250730223622762" style="zoom:80%;" />

<img src="408.assets/image-20250730223649280.png" alt="image-20250730223649280" style="zoom:80%;" />

### 4.程序中断方式

<img src="408.assets/image-20250730223934408.png" alt="image-20250730223934408" style="zoom:80%;" />

<img src="408.assets/image-20250730225021733.png" alt="image-20250730225021733" style="zoom:80%;" />

#### 中断工作流程

1. 中断系统需**对每个中断源设置中断请求标记触发器**，当其状态为“1”时，表示该中断源有请求

2. **中断响应优先级**是指 CPU 响应中断请求的先后顺序

	> <img src="408.assets/image-20250730225353416.png" alt="image-20250730225353416" style="zoom:80%;" />

3. **CPU响应中断的条件**：

	<img src="408.assets/image-20250730225507166.png" alt="image-20250730225507166" style="zoom:80%;" />

4. **中断响应过程**：

	1. 关中断
	2. 保存断点(PC, PSW)
	3. 中断服务程序

5. **中断向量**：

	中断向量表(数组保存)的表项：`中断类型号:中断向量`，中断向量=对应中断服务程序入口地址

<img src="408.assets/image-20250730230014351.png" alt="image-20250730230014351" style="zoom:80%;" />

**现场**：**用户可见寄存器**

第二个关中断的作用：**防止恢复线程和屏蔽字时被打扰**

#### 中断屏蔽字

**每个中断源对应中断屏蔽字寄存器中的一位**，**1表示屏蔽，0表示正常请求**

中断屏蔽只在 CPU 运行中断服务程序时才有用，其并**不能改变 CPU 运行主程序时的中断响应优先级**

> **先处理中断响应优先级高的**，处理时进入中断服务程序，**发现其被屏蔽，这时才会去换另一个**
>
> 图的形式是**先处理中断响应优先级高的一小会儿，然后立马换成另一个**

<img src="408.assets/image-20250730232016643.png" alt="image-20250730232016643" style="zoom:80%;" />

<img src="408.assets/image-20250730232240102.png" alt="image-20250730232240102" style="zoom:80%;" />

<img src="408.assets/image-20250730232314266.png" alt="image-20250730232314266" style="zoom:80%;" />

### 5.DMA方式

DMA方式在**外设与内存**之间开辟了一条“**DMA通路**”，**信息传送不再经过 CPU**，**不需要保护、恢复 CPU 现场**等烦琐操作

#### DMA的工作过程

1. **预处理**：CPU 完成一些必要的准备工作，由 **DMA 控制器向 CPU 发总线请求**
2. **数据传送**：DMA控制器接管总线后，在**设备接口和主存之间**进行数据传送，**完全由DMA(硬件)控制器控制**
3. **后处理**：传送结束后，**DMA 控制器向 CPU 发送中断信号**，做结束处理

<img src="408.assets/image-20250730234032112.png" alt="image-20250730234032112" style="zoom:80%;" />

#### DMA和CPU访存冲突

解决方法：

1. **停止CPU访存**

	<img src="408.assets/image-20250730233522615.png" alt="image-20250730233522615" style="zoom:80%;" />

2. **周期挪用**：如果**CPU正在访存，则必须等CPU完成当前的存取周期，再将总线让出**

	<img src="408.assets/image-20250730233631197.png" alt="image-20250730233631197" style="zoom:80%;" />

3. **DMA和CPU交替访存**：**CPU的工作周期分为两个时间片**

	<img src="408.assets/image-20250730233905778.png" alt="image-20250730233905778" style="zoom:80%;" />

#### DMA和中断的比较

|     对比维度     |               DMA方式                |            中断方式            |
| :--------------: | :----------------------------------: | :----------------------------: |
| **程序是否中断** |      ❌ 不中断当前程序，偷偷干活      |   ✅ 需暂停程序，跳转处理中断   |
|   **响应时机**   |     随时响应（任意机器周期结束）     |   必须等一条指令执行完才响应   |
| **CPU是否干预**  |     ❌ 完全交给DMA控制器，CPU喝茶     |     ✅ CPU亲自处理数据搬运      |
| **数据传输速率** | ⚡ 高速（硬件直连内存，适合大批数据） |    🐢 低速（靠CPU一条条搬）     |
|    **优先级**    |      🏆 比中断更高（抢总线优先）      |          🥈 优先级较低          |
|   **适用场景**   |    硬盘读写、显卡传数据等"体力活"    | 键盘输入、异常处理等"紧急小事" |
|   **硬件支持**   |       需DMA控制器（额外硬件）        |      只需CPU和中断控制器       |
| **数据传送机制** |     🛠️ 硬件自动搬运（内存↔外设）      |  📝 靠程序指令搬运（CPU参与）   |





# 计算机网络

## 第1章：计算机网络体系结构

### 1.计算机网概述

#### 计算机网络概念

**计算机网络**：通过链路把**节点**连接起来

**互联网internet**：通过路由器将**网络**连接起来

**因特网Internet**：**最大的互联网**

#### 计算机网络组成

计算机网络=**硬件+软件+协议**

1. 硬件：主机、链路、交换设备
2. 软件：Email程序、FTP程序等
3. 协议

**边缘部分**：**主机**

**核心部分**：**网络和连接网络的路由器**

<img src="408.assets/image-20250731114636185.png" alt="image-20250731114636185" style="zoom:80%;" />

### 2.xx交换

#### 电路交换

1. 建立连接
2. 数据交换
3. 释放连接

**比特流连续，不存在存储转发**

**优点**：

1. **通信时延小**
2. 实时性强

**缺点**：

1. **建立连接时间长**
2. **线路利用率低**
3. 灵活性差：链路故障则要重新建立链路

#### 报文交换

**不进行分组**，而是在**连续比特流上的封装**

数据交换的单位是**报文**，**储存转发**

**优点**：

1. **无建立连接时延**
2. **线路利用率高**
3. 支持差错控制

**缺点**：

1. **转发时延高**
2. **缓存开销大**：**缓存整个报文**
3. **错误处理低效**：**出错需重传整个报文**

#### 分组交换

报文划分为等长数据段，数据段加上首部构成**分组(单位)**，**存储转发**

**优点**：

1. **存储转发开销小**：**只需缓存一个分组**
2. **差错和重传代价小**

**缺点**：

1. **额外信息量**
2. **乱序、重复、丢失**

<img src="408.assets/image-20250731161351787.png" alt="image-20250731161351787" style="zoom:80%;" />

### 3.网络拓扑结构

<img src="408.assets/image-20250731161458416.png" alt="image-20250731161458416" style="zoom:80%;" />

**环形网络**中的数据**单向传输**

### 4.网络的性能指标

1. **速率**：B/s，**bit/s=bps**，数据**在介质中传播的速度**

2. **带宽**：B/s，数据**发送到链路**的**理论最大速度**

	> 带宽$\neq$传输速率，带宽是理论最大值，传输速率是实际速度

3. **吞吐量**：单位时间接收数据量

4. **时延**：

	1. **传输时延**：数据发送到链路上的时间
	2. **传播时延**：数据在介质中传播的时间
	3. **处理时延**：**在中间节点存储转发的时间**
	4. 排队时延

5. **时延带宽积**：第一个比特到达时，已经发送的比特数
	$$
	时延带宽积=传播时延\times 带宽
	$$

	> <img src="408.assets/image-20250731174950418.png" alt="image-20250731174950418" style="zoom:80%;" />
	>
	> 时延带宽积是3

6. **往返时延**：RTT

7. **信道利用率**：
	$$
	\text{信道利用率}=\text{有数据通过的时间}/(\text{有数据通过的时间}+\text{无数据通过的时间})
	$$
	

### 5.网络分层结构

1. **协议数据单元 PDU**：对等层的数据传输单位，比如帧、分组、报文
2. **服务数据单元 SDU**：层于层之间数据交换的单位
3. **协议控制信息 PCI**

$$
n\mathrm{-SDU}+n\mathrm{-PCI}=n\mathrm{-PDU}=(n-1)\mathrm{-SDU}
$$

### 6.协议、接口、服务

#### 协议

**语法**：静态格式，报文格式

**语义**：静态行为，三次握手执行的操作

**时序**：动态顺序，三次握手的时序关系

#### 接口

**服务访问点 SAP**：

#### 服务

**协议是水平的，服务是垂直的**

面向连接服务(TCP)与无连接服务(IP,UDP)

可靠服务(TCP)和不可靠服务(UDP)

有应答服务(文件传输服务)和无应答服务(WWW服务)

### 7.OSI模型

<img src="408.assets/image-20250731164725978.png" alt="image-20250731164725978" style="zoom:80%;" />

#### 物理层

传输单位是**比特**，功能是在**物理介质**上为数据端设备透明地传输**原始比特流**

**物理介质**(如双绞线、光缆、无线信道等)属于**第0层**

#### 数据链路层

传输单位是**帧**，**点到点**通信

**差错控制**，**流量控制**(**节点之间的流量控制**，区别传输层端到端的流量控制)

#### 网络层

传输单位是**数据报**

**差错控制**，**流量控制**，**拥塞控制**

> 流量控制：**两个点之间速度不匹配**
>
> 拥塞控制：**整个网络堵塞**导致大量数据丢失

提供**有连接可靠的虚电路服务**，也提供**无连接不可靠的数据报服务**

#### 传输层

两个进程间(**端到端**)通信

**差错控制**，**流量控制**(**端与端之间的流量控制**)

**仅提供有连接可靠的服务**

#### 会话层

**会话(session)**：表示层实体和用户进程之间的**连接**

**建立、管理和终结会话**

检查点：通信失效后从检查点恢复通信，断点下载的原理

#### 表示层

**统一**不同主机的**信息表示方式**

**数据压缩、加密和解密**

#### 应用层

**用户和网络的接口**

### 8.TCP/IP模型

<img src="408.assets/image-20250731170851772.png" alt="image-20250731170851772" style="zoom:80%;" />

**只有4层**

#### 网络接口层

#### 网际层

**主机-主机**

传输单位是**数据报**

**仅提供无连接不可靠的IP**

#### 传输层

**应用-应用**或**进程-进程**

**TCP**，可靠有连接，单位是**报文段**

**UDP**，不可靠无连接，单位是**用户数据报**

#### 应用层

### OSI和TCP/IP比较

> **IP是互联网的核心协议**

<img src="408.assets/image-20250731174508345.png" alt="image-20250731174508345" style="zoom:80%;" />



## 第2章：物理层

### 1.通信概念

**模拟**数据/信号：**连续的**

**数字**数据/信号：**离散的**

**码元**：一段固定时长内的信号，固定时长为码元宽度

> - 若1个码元表示**4种状态**（如00、01、10、11），则 **1码元=2比特**
> - 若1个码元只有**2种状态**（如0/1），则 **1码元=1比特**

**单向通信**：只能发送接收**二选一**

**半双工通信**：即可发送又可接收，但**不能同时发送和接收**

**全双工通信**：可**同时发送和接收**

**码元传输速率=波特率**：Baud

**信息传输速率=比特率**：b/s

**带宽**：某信道**最高和最低频率之差**，Hz

> 区别于上一章的带宽(数据传输到链路的速度)

### 2.信道极限容量

#### 奈奎斯特定理

**前提**：**理想低通**(**没有噪声、带宽有限**)信道
$$
W为带宽 \\\\
极限码元传播速率=2W\ (Baud) \\\\
极限信息传播速率=2W\log_2V\ (b/s)
$$
奈奎斯特定理**给出了码元传输速率的极限**，但由于**每个码元可以携带多个比特**，所以**信息传输速率并未限制**

#### 香农定理

**前提**：**带宽受限且有高斯噪声**的信道
$$
\text{S/N 为信噪比} \\\\
信道的极限信息传输速率=W\log_2(1+S/N)\ (b/s)
$$
**信噪比的分贝(dB)计数法**：
$$
10log_{10}(S/N) \\\\
S/N=1000时，信噪比为30dB
$$
香农定理体现：**一个码元可以携带的比特数是有限的(信息传输速率有上限)**

### 3.编码和调制

将数据转换为**数字信号**的过程称为**编码**，将数据转换为**模拟信号**的过程称为**调制**

|              |              核心特点              |                 典型技术/编码                  |
| :----------: | :--------------------------------: | :--------------------------------------------: |
| **基带传输** |    数字信号直接传输，**不调制**    | **不归零编码、曼彻斯特编码、差分曼彻斯特编码** |
| **频带传输** |   数字信号**调制成模拟信号**传输   |          **ASK、FSK、PSK、DPSK、QAM**          |
| **宽带传输** | 高频模拟信号，**多路复用**共享带宽 |         OFDM、QAM、DOCSIS（有线电视）          |

#### 数字数据->数字信号

<img src="408.assets/image-20250731215037771.png" alt="image-20250731215037771" style="zoom:80%;" />

**同步**：接收端能准确**识别每个比特或码元的起始和结束**时刻

|     编码方式     | 是否需要同步 |  能否自同步  |      典型应用场景      |
| :--------------: | :----------: | :----------: | :--------------------: |
|     **NRZ**      |    ❌ 不能    | ❌ 无时钟信号 |  短距离通信（如UART）  |
|      **RZ**      |     ✅ 能     | ✅ 靠归零脉冲 |       早期以太网       |
| **曼彻斯特编码** |     ✅ 能     | ✅ 跳变即同步 | **以太网**（10BASE-T） |
| **差分曼彻斯特** |     ✅ 能     |  ✅ 跳变同步  |       令牌环网络       |

#### 模拟数据->数字信号

**采样(连续信号->离散信号)、量化(得到离散数字量)、编码(得到二进制编码)**

常用于对音频信号进行编码的**PCM编码**

#### 数字数据->模拟信号

<img src="408.assets/image-20250731215928244.png" alt="image-20250731215928244" style="zoom:80%;" />

发送方**调制：数->模**；接收方**解调：模->数**

| 调制方式 |     全称     |                      原理                      | 抗干扰性 | 带宽需求 |            通俗比喻            |
| :------: | :----------: | :--------------------------------------------: | :------: | :------: | :----------------------------: |
| **ASK**  |   幅移键控   | 用不同**幅度**表示0和1（如高幅度=1，低幅度=0） |    ⭐     |    低    |   像摩斯密码：大声=1，小声=0   |
| **FSK**  |   频移键控   |   用不同**频率**表示0和1（如高频=1，低频=0）   |    ⭐⭐    |    中    |     像鸟叫：高音=1，低音=0     |
| **PSK**  |   相移键控   |    用不同**相位**表示0和1（如0°=0，180°=1）    |   ⭐⭐⭐    |    低    | 像钟表指针：指向左=0，指向右=1 |
| **DPSK** | 差分相移键控 | 用**相位变化**表示0和1（如相位翻转=1，不变=0） |   ⭐⭐⭐⭐   |    低    |   像扭开关：拧一下=1，不拧=0   |

**正交幅度调制(QAM)**：
$$
\text{设波特率为 B，采用 }m\text{ 个相位，每个相位有 }n\text{ 种振幅，则该 QAM 的数据传输速率为：}\\\\
R=B\log_2(mn) \text{(单位为 b/s)}
$$

#### 模拟数据->模拟信号

频分复用(FDM)技术，电话机和本地局交换机

### 4.传输介质

|   传输介质   |                结构特点                | 抗干扰性 |     传输距离      |      典型应用场景      |
| :----------: | :------------------------------------: | :------: | :---------------: | :--------------------: |
|  **双绞线**  |     两根绝缘铜线相互缠绕（如网线）     |    ⭐⭐    |  100米（无中继）  | 局域网（以太网）、电话 |
| **同轴电缆** | 中心铜线+绝缘层+金属屏蔽层（如电视线） |   ⭐⭐⭐    | 500米（模拟信号） |  有线电视、监控摄像头  |
|   **光纤**   | 玻璃/塑料纤维传导光信号（分单模/多模） |  ⭐⭐⭐⭐⭐   |   千米至百千米    | 互联网骨干网、数据中心 |
| **无线传输** |       电磁波（无线电/微波/红外）       |    ⭐     |   10米-100千米    |  Wi-Fi、5G、卫星通信   |

### 5.物理层的接口特性

|   特性类型   |             定义              |                           核心内容                           |              典型例子              |
| :----------: | :---------------------------: | :----------------------------------------------------------: | :--------------------------------: |
| **机械特性** |   接口的 **物理形态和结构**   | - **接口形状、尺寸、引脚数量/排列** - 连接器类型（如RJ45、USB） - 线缆材质/硬度 |  网线水晶头（8根针脚）、HDMI接口   |
| **电气特性** |     接口的 **电信号规范**     | - **电压范围（如±12V）** - **信号频率/速率** - 阻抗匹配 - 抗干扰要求（如屏蔽） |    RS-232（±15V）、USB 5V/0.5A     |
| **功能特性** | 接口的 **信号用途和交互逻辑** | - **每根引脚的作用**（如Tx发送、Rx接收） - 信号时序（如时钟同步） - 控制流程 | 串口协议（TXD/RXD/GND）、I2C时钟线 |

### 6.物理层设备

- **冲突域**：指网络中**可能发生数据冲突的区域**。交换机（Switch）每个端口是一个独立的冲突域，而Hub的所有端口共享一个冲突域
- **广播域**：指**广播帧能够到达的范围**。路由器或三层交换机可以分割广播域，而中继器和集线器不能

|              特性              |                     中继器（Repeater）                     |                        集线器（Hub）                         |
| :----------------------------: | :--------------------------------------------------------: | :----------------------------------------------------------: |
|          **工作层次**          |                   物理层（OSI Layer 1）                    |                    物理层（OSI Layer 1）                     |
|            **功能**            | 单纯放大和再生电信号，**延长传输距离**，**原理是信号再生** |        **只起信号放大和转发作用**，扩大网络的传输范围        |
|          **端口数量**          |               **通常为2个端口（输入/输出）**               |                  **多端口（4/8/16/24等）**                   |
|          **带宽共享**          |                    不涉及（点对点连接）                    | **所有端口共享带宽（如10Mbps Hub 连接8台计算机，每台计算机的带宽为12.5Mbps）** |
| **冲突域（Collision Domain）** |        不分割冲突域（**与连接设备同属一个冲突域**）        |          不分割冲突域（**所有端口同属一个冲突域**）          |
| **广播域（Broadcast Domain）** |        不分割广播域（**与连接设备同属一个广播域**）        |          不分割广播域（**所有端口同属一个广播域**）          |
|          **典型应用**          |                延长电缆或光纤的信号传输距离                |           早期星型拓扑网络的中心连接设备（已淘汰）           |



## 第3章：数据链路层

### 1.数据链路层概念

数据链路层功能：**封装成帧、透明传输、差错检验**

数据链路层的信道：

1. **点对点信道**：PPP协议
2. **广播信道**：CSMA/CD、CSMA/CA协议

PDU：**帧**

**封装成帧**：添加首部和尾部，构成帧

**透明传输**：传输的数据含标识符，也能正确传输

**流量控制**：OSI中数据链路层有流量控制，TCP/IP则把流量控制移到传输层

**差错检验**：位错(CRC检验)，帧错(丢失、乱序、重复、出错)

### 2.组帧

核心任务：确认帧的起始结束位置

#### 字符计数法

字段记录帧长

<img src="408.assets/image-20250801173945638.png" alt="image-20250801173945638" style="zoom:80%;" />

#### 字节填充法

首位添加特定转义字符

<img src="408.assets/image-20250801174219687.png" alt="image-20250801174219687" style="zoom:80%;" />

#### 零比特填充法

特定的比特串 01111110，**每遇到5个连续的1，就添加一个0，防止冲突**

<img src="408.assets/image-20250801174347868.png" alt="image-20250801174347868" style="zoom:80%;" />

#### 违规编码法

**曼切斯特编码**采用

### 3.差错控制

1. **ARQ** 自动重传请求：**请求重发**，**检错编码**
2. FEC 向前纠错：**自行纠错**，**纠错编码**

#### 奇偶校验码

**奇校验码**：添加一个附加位，让1的个数变为奇数，$\text{1001101}\underline{1}$

**偶校验码**：添加一个附加位，让1的个数变为偶数，$\text{1001101}\underline{0}$

如果有2、4、6位出错，则无法检验

#### 循环冗余码 CRC

**G(x)是双方约定的多项式**
$$
\text{数据 }M=101001(m=6), \ \text{除数 }G(x)=1101(r=3) \\\\
在数据后面加上r个0：101001000 \\\\
用G(x)除新数据，得到的余数是冗余码：FCS=001 \\\\
冗余码替换加上的r个0：CRC=101001001 \\\\
接收方用G(x)除CRC，余数为0，则无误码
$$
<img src="408.assets/image-20250801205905274.png" alt="image-20250801205905274" style="zoom:80%;" />

注意：

1. 这里的除法**内部是按位异或**
2. **余数为0，也有小概率发生了误码**
3. **CRC码有纠错能力**，但是并未介绍

#### 海明码

**纠错**编码

1. **发送方**：
	- 在原始数据中**插入几个校验位**（位置是**2的幂次方**：1, 2, 4, 8…）。
	- 每个校验位负责**检查某些数据位**（用奇偶校验）。
	- 把**数据+校验位**一起发送出去。
2. **接收方**：
	- 重新计算校验位，对比接收到的校验位。
	- 如果发现不一致，就能**定位错误的位置**，并**纠正错误**。

$$
\text{信息位为 }D_{4}D_{3}D_{2}D_{1}(1010)， \\\\
\text{检验位为 }P_3P_2P_1\text{，共 3 位，对应的海明码为 }H_7H_6H_5H_4H_3H_2H_1 \\\\
海明码在2的幂次位上：\\\\
H_{7}H_{6}H_{5}H_{4}H_{3}H_{2}H_{1}\\D_{4}D_{3}D_{2}P_{3}D_{1}P_{2}P_{1}\\\\
第3位=2+1，因此H_3对应海明码P_1和P_2 \\\\
P_1=所有对应它的信息位的异或=D_1\oplus D_2\oplus D_4=0\oplus1\oplus1=0\\\\
\text{1010 对应的海明码为 101} \underline{0} 0\underline{10}\\\\
接收方：S_1=P_1\oplus D_1\oplus D_2\oplus D_4，判断其是否为0可得该位是否出错
$$

### 4.流量控制

#### 滑动窗口协议

发送方得到一个确认，发送窗口前进一位

接收方得到一个帧，接收窗口前进一位，**收到的帧落在接收窗口之外，则一律丢弃**
$$
\text{若采用 }n\text{ 比特对帧编号，则 }W_\mathrm{T}+W_\mathrm{R}\leqslant2^n
$$

|     协议类型      | 发送窗口大小 (W<sub>T</sub>) | 接收窗口大小 (W<sub>R</sub>) |               核心特点                |
| :---------------: | :--------------------------: | :--------------------------: | :-----------------------------------: |
| **停止-等待协议** |              1               |              1               |    每发一帧必须等待确认，效率最低     |
|  **后退N帧协议**  |              >1              |              1               | 发送方连续发送多帧，出错时重传最后N帧 |
| **选择重传协议**  |              >1              |              >1              |   只重传错误帧，接收方可缓存乱序帧    |

上述三个都属于**ARQ(自动重传请求)协议**

#### 停止-等待协议

发送方发一个帧，接收方接收并返回确认后，发送方才能发下一个

发送方超时重传

**交替使用0、1表示帧号**

**发送方缓存发送的数据，直到收到ACK才会清除**

#### Go-Back-N协议

**N个帧的前一个帧超时，则重传这N+1个帧**

**ACKn表示n及其之前的都已收到**

接收方**必须顺序接收**

<img src="408.assets/image-20250801220455193.png" alt="image-20250801220455193" style="zoom:80%;" />

2号帧丢失，后面的3~8只能丢弃，因为必须顺序接收
$$
1<W_\mathrm{T}\leqslant2^n-1 \\\\
W_T\geq2^n\text{，发送方可以一次性发送超过序号范围的帧，接收方无法区分“新帧”和“旧帧”}
$$

> n=2，帧可用序号为0、1、2、3；$W_T=4$，发送方可以一次发送4个帧
>
> 接收方收到0、1、2、3之后，再收到0无法判断0号是新帧还是旧帧：
>
> 1. 若ACK3丢失，发送方重传0号帧
> 2. 若一切正常，发送方发的下一个帧还是0号(因为n=2，帧号只有4个，循环编号)
>
> 如果$W_T=3$就不会有上述问题，重传传0号，新发发3号，接收方可以辨别

#### 选择重传协议

**接收方不能累计确认，必须各自确认**

没收到旧等待重传，收到了但是出错则主动发送NAK，要求发送方立刻重传

<img src="408.assets/image-20250801224352266.png" alt="image-20250801224352266" style="zoom:80%;" />
$$
W_\mathrm{R}+W_\mathrm{T}\leqslant2^n \\\\
W_{\mathrm{R}}\leqslant W_{\mathrm{T}} \\\\
W_\mathrm{R}\leqslant2^{n-1}
$$

#### 信道利用率

**停止-等待协议**

<img src="408.assets/image-20250801224639237.png" alt="image-20250801224639237" style="zoom:80%;" />
$$
\text{发送方传输时延为 }T_\mathrm{D}，接收方ACK传输时延\text{为 }T_\mathrm{A} \\\\
U=\frac{T_\mathrm{D}}{T_\mathrm{D}+\mathrm{RTT}+T_\mathrm{A}}
$$
**连续ARQ协议**

<img src="408.assets/image-20250801225553231.png" alt="image-20250801225553231" style="zoom:80%;" />
$$
nT_{\mathrm{D}}<T_{\mathrm{D}}+\mathrm{RTT}+T_{\mathrm{A}}：U=\frac{nT_\mathrm{D}}{T_\mathrm{D}+\mathrm{RTT}+T_\mathrm{A}} \\\\
nT_\mathrm{D}\geqslant T_\mathrm{D}+\mathrm{RTT}+T_\mathrm{A}：U=1
$$
**信道数据传输速率**：
$$
\text{信道平均(实际)数据传输速率}=\text{信道利用率}\times\text{信道带宽(最大数据传输速率)}\\\\
\text{信道平均(实际)数据传输速率}=\text{发送周期内发送的数据量/发送周期}
$$

### 5.介质访问控制 MAC

**MAC作用**：**控制多个设备如何共享同一通信信道**

|           分类           |      具体技术      |           典型协议/方法            |                             特点                             |
| :----------------------: | :----------------: | :--------------------------------: | :----------------------------------------------------------: |
| **信道划分介质访问控制** | **时分复用 (TDM)** |      2G GSM、蓝牙（部分模式）      | 用户轮流使用信道，按时间片分配，适合周期性数据，但存在同步开销。 |
|                          | **频分复用 (FDM)** | 传统无线电广播、蜂窝网络（2G GSM） |      不同用户分配不同频段，互不干扰，但频谱利用率较低。      |
|                          | **波分复用 (WDM)** |          光纤通信（WDM）           |          光信号通过不同波长区分，用于高速数据传输。          |
|                          | **码分复用 (CDM)** |   3G（CDMA2000）、Wi-Fi（DSSS）    |  用户共享同一频段，通过编码区分，抗干扰强，但接收复杂度高。  |
| **随机访问介质访问控制** |     **ALOHA**      |         纯ALOHA、时隙ALOHA         | 用户随机发送，冲突后重传；简单但效率低（纯ALOHA最大效率仅18%）。 |
|                          |      **CSMA**      |      CSMA（载波侦听多路访问）      | 先监听信道，空闲则发送，减少冲突；但仍可能因传播延迟冲突（如以太网早期）。 |
|                          |    **CSMA/CD**     |        以太网（IEEE 802.3）        | 边发送边检测冲突（Collision Detection），冲突后立即停止并重传。 |
|                          |    **CSMA/CA**     |        Wi-Fi（IEEE 802.11）        | 避免冲突（Collision Avoidance），通过RTS/CTS预约信道，解决隐蔽终端问题。 |
| **轮询访问介质访问控制** |    **令牌传递**    |     令牌环（IEEE 802.5）、FDDI     | 令牌在节点间传递，持有令牌的节点可发送数据，公平但令牌丢失会导致系统瘫痪。 |

#### 信道划分介质访问控制

**复用**：多条信号组合发送，接收方分离出来

1. **时分复用 (TDM)**：

	<img src="408.assets/image-20250802162330117.png" alt="image-20250802162330117" style="zoom:80%;" />

	按**时间片**分配

2. **频分复用 (FDM)**：

	<img src="408.assets/image-20250802162501927.png" alt="image-20250802162501927" style="zoom:80%;" />

	不同用户**分配不同频段**，互不干扰

3. **波分复用 (WDM)**：

	光信号通过不同波长区分

4. **码分复用 (CDM)**：

	每个站一个码片，表示发出1或0(按位取反)
	$$
	A站的码片00011011，发送00011011表示1，发送11100100表示0\\\\
	\text{A站的码片序列是(}-1,-1,-1,+1,+1,-1,+1,+1)\\\\
	S\cdot T\equiv\frac{1}{m}\sum_{i=1}^{m}S_{i}T_{i}=0\\\\
	S\cdot S=\frac{1}{m}\sum_{i=1}^{m}S_{i}S_{i}=\frac{1}{m}\sum_{i=1}^{m}S_{i}^{2}=\frac{1}{m}\sum_{i=1}^{m}(\pm1)^{2}=1\\\\
	S\cdot\overline{S}=\frac{1}{m}\sum_{i=1}^{m}S_{i}\overline{S_{i}}=-\frac{1}{m}\sum_{i=1}^{m}S_{i}^{2}=-1\\\\
	两个向量在信道的叠加，等价于线性相加：\boldsymbol{S}+\overline{\boldsymbol{T}}=\begin{pmatrix}0,0,-2,2,0,-2,0,2\end{pmatrix}\\\\
	\boldsymbol{S}\cdot(\boldsymbol{S}+\overline{\boldsymbol{T}})=1，表示A站发出1\\\\
	T\cdot(S+\overline{T})=-1，表示B站发出0
	$$

#### ALOHA协议

任何站点**发送时不检测**，**遇到冲突随机间隔后重发**

**时隙ALOHA协议**：只能在时隙的开始发送：

<img src="408.assets/image-20250802163908659.png" alt="image-20250802163908659" style="zoom:80%;" />

#### CSMA协议

**监听公共信道，空闲时才发**

| 信道状态 |      1-坚持 CSMA       |           非坚持 CSMA            |       p-坚持 CSMA        |
| :------: | :--------------------: | :------------------------------: | :----------------------: |
| **空闲** |      立即发送数据      |           立即发送数据           |   以概率 *p* 发送数据    |
|  **忙**  | 持续监听，直到信道空闲 | 放弃监听，等待随机时间后重新监听 | 持续监听，下一间隙再检测 |

#### CSMA/CD协议

适用于**总线型以太网**

**先听后发，边发边听，冲突停发，延迟重发**

1. **冲突发生的最长时间**：

	<img src="408.assets/image-20250802164853377.png" alt="image-20250802164853377" style="zoom:67%;" />

	可见最长是2倍传播时延，此为争用期

	只要超过2倍传播时延没有冲突，就不会冲突

2. **最短帧长**：

	目的：在传输完之前能发现冲突
	$$
	\text{最短帧长}=(2\text{传播时延})\times\text{数据传输速率}
	$$

	> $$
	> 以太网规定51.2μs为争用期的长度，10Mb/s的以太网，最短帧长为512bit=64B
	> $$
	>
	> 前64B没有冲突就不会有冲突，不足64B则填充到64B

3. **二进制指数退避算法**：
	$$
	\text{基本退避时间(单位)：}2\tau\\\\
	\text{从离散的整数集合}[0,1,\cdots,(2^k-1)]\text{中随机取出一个数}\\\\
	第一次，k=1，k最大为10
	$$
	重传16次不成功，则报错

#### CSMA/CA协议

适用于**无线局域网**

使用**冲突避免**而不是冲突检测

1. **确认-重传(ARQ)机制**：

	使用**停止-等待**协议，$W_T=W_R=1$

2. **帧间间隔(IFS)**：检测到**信道空闲后，还要等待一段很短的时间**才能发生帧

	**SIFS**：**最短**，包括**ACK、CTS、回应AP的帧、分片后的数据帧**

	**DIFS**：**最长**，发送的数据是**第一个数据帧**，**信道空闲**，**等待DIFS**后发送

3. **退避算法**：

	**退避前提**：

	1. 发送**第一个帧**检测到**信道忙**
	2. **重传**
	3. **发送下一帧**

	$$
	[0^{\cdots},(2^{2+k}-1)]\text{个时隙中随机选择一个}，k最大为6(最大范围255)
	$$

4. **隐蔽站问题**：

	> <img src="408.assets/image-20250802211135285.png" alt="image-20250802211135285" style="zoom:80%;" />

	<img src="408.assets/image-20250802211151855.png" alt="image-20250802211151855" style="zoom:80%;" />

	RTS(Request to Send)：源站广播的请求发送帧

	CTS(Clear to Send)：AP广播，**包含信道占用时间**

	注意**源站第一次发送且检测到信道空闲，需要等待DIFS**；而**CTS、回应AP、ACK均只需等待SIFS**

5. **NAV的计算**：

	**NAV(网络分配向量)**：CTS中包含，信道占用时间，是从其他站收到CTS开始，到ACK报文送达源站的时间
	$$
	NAV=SIFS+DATA+SIFA+ACK
	$$

#### 轮询访问：令牌传递协议

令牌在**环路中传播**，只有拿到令牌才能发送数据

把**要发送的数据写入令牌**，令牌传播时其它节点接收令牌内的数据(**类似于广播**)

### 6.局域网LAN

#### 局域网概念

局域网**三个要素**：拓扑结构、传输介质、**介质访问控制方式(最重要)**

**拓扑结构**：**星型、环形、总线型**、星型和总线型复合

**传输介质**：**双绞线**为主

**介质访问控制方式**：**CSMA/CD(总线型)，令牌环协议(环形)**

|       特殊局域网        | 逻辑拓扑 | 物理拓扑 |               特点/标准               |
| :---------------------: | :------: | :------: | :-----------------------------------: |
|       **以太网**        |  总线形  |   星形   | **目前应用最广**（如家庭/办公室网络） |
| **令牌环 (IEEE 802.5)** |   环形   |   星形   |     通过令牌控制访问，已逐渐淘汰      |
|  **FDDI (IEEE 802.8)**  |   环形   | 双环结构 |   光纤传输，高可靠性，用于骨干网络    |

#### 以太网和IEEE 802.3

**以太网**是目前最流行的**有线局域网**技术

1. 采用**无连接，不可靠服务**
2. 采用**曼切斯特编码**

---

**MAC地址**：**48位，6字节**，固化在网卡中

**路由器同时连接2个网络，就有两个MAC地址**

---

**以太网帧**：

<img src="408.assets/image-20250802220445246.png" alt="image-20250802220445246" style="zoom:80%;" />

**类型**：指出**上层协议，如IP**

**FCS**：**32位CRC校验码**

**Data最短46字节**，因为以太网采用CSMA/CD协议，最短帧长64B，**64-6-6-2-4=46**

---

**特殊以太网**：

|                      | 100Base-T以太网 |  吉比特以太网   |      10吉比特以太网      |
| :------------------: | :-------------: | :-------------: | :----------------------: |
|     **传输速率**     |     100Mb/s     |      1Gb/s      |          10Gb/s          |
|     **传输介质**     |     双绞线      |  双绞线或光纤   |       双绞线或光纤       |
|     **通信方式**     |  半双工/全双工  |  半双工/全双工  |         仅全双工         |
| **介质访问控制协议** | 半双工用CSMA/CD | 半双工用CSMA/CD | 无（全双工无需冲突检测） |

#### 无限局域网和IEEE 802.11

**星型拓扑**，**中心接入点AP**，**基本服务集ESS**，**CSMA/CA协议**，通过**分配系统DS连接另一个ESS**

<img src="408.assets/image-20250802221705158.png" alt="image-20250802221705158" style="zoom:80%;" />

---

**802.11 MAC帧结构**：

<img src="408.assets/image-20250802222110151.png" alt="image-20250802222110151" style="zoom:80%;" />

<img src="408.assets/image-20250802222258326.png" alt="image-20250802222258326" style="zoom:80%;" />

**路由器只认识802.3帧**，**节点只认识802.11帧**，AP作为中间节点，如果要**转发给路由器，则将802.3$\rightarrow$802.11**，如果**转发给节点，则将802.11$\rightarrow$802.3**

#### 虚拟局域网VLAN和802.3ac

将一个**大局域网分割为多个虚拟局域网**，**每个VLAN是一个广播域**，**不同VLAN中的计算机无法通信**

---

**802.1Q帧结构**：

<img src="408.assets/image-20250802223737988.png" alt="image-20250802223737988" style="zoom:80%;" />

**在以太网帧中插入4字节的VLAN标识符，指明来自哪个VLAN**

---

<img src="408.assets/image-20250802224000167.png" alt="image-20250802224000167" style="zoom:80%;" />

A->B，通过交换机1识别B的MAC地址在VLAN-10中，就像普通以太网中一样发送

A->E，在**交换机内部使用802.3帧**，**交换机之间的干线链路上使用802.1Q帧**，**交换机2把802.1Q->802.3转发给E**

#### 广域网

**广域网$\neq$互联网**

广域网通常采用**点到点连接**

<img src="408.assets/image-20250802224426301.png" alt="image-20250802224426301" style="zoom:80%;" />

### 7.点对点协议 PPP

两台网络设备之间的**直连专用线路**

PPP允许采用**多种网络层协议**

**不可靠**

**仅全双工**

<img src="408.assets/image-20250802224619987.png" alt="image-20250802224619987" style="zoom:80%;" />

标志字段F=0x7E

地址字段A=0xFF

控制字段C=0x03

协议字段：网络层协议，**0x21则为IP协议**，两端可不同网络层协议

FCS：CRC校验的冗余码

### 8.数据链路层设备

#### 交换机

**划分冲突域**

**10Mb/s以太网，N个用户，每个用户带宽依然10Mb/s**(而**集线器会变为10/N**)

全双工模式下，不需要CSMA/CD

半双工模式下，使用CSMA/CD

#### 交换表

<img src="408.assets/image-20250802225531455.png" alt="image-20250802225531455" style="zoom:80%;" />

**A发给B，交换机把A的端口和MAC地址记录到交换表**

#### 各设备冲突域和广播域

**交换机隔离冲突域的原理：全双工模式下两条信道**

<img src="408.assets/image-20250802231137502.png" alt="image-20250802231137502" style="zoom:80%;" />



## 第4章：网络层

### 1.网络层概念

#### 基本概念

**OSI**主张有连接可靠的**虚电路服务**

**TCP/IP**主张无连接不可靠的**数据报服务**，将可靠性交给上层去实现

**路由器**：路由选择+分组转发

**路由选择**：根据路由协议**构造路由表**

**分组转发**：**根据转发表**将分组从合适端口转发

**路由表**：根据路由算法得出

**转发表**：由路由表得出

#### 虚电路服务

虚电路建立、数据传输、虚电路释放

每个虚电路分配一个**虚电路号**，**只有第一个分组携带目的地址，其它分组只携带虚电路号**

**两个节点之间可能有多个虚电路**

<img src="408.assets/image-20250803114838830.png" alt="image-20250803114838830" style="zoom: 67%;" />

#### 数据报服务

采用**存储转发**技术

**每个分组都必须携带目的地址**

|  对比项  |       数据报服务       |          虚电路服务          |
| :------: | :--------------------: | :--------------------------: |
| 连接建立 |      无需建立连接      |        需要先建立连接        |
| 地址使用 | 每个数据包都带完整地址 | 连接建立后用虚电路号代替地址 |
| 路由选择 |     每个包独立选路     |    同连接所有包走相同路径    |
| 顺序保证 |       不保证顺序       |         保证顺序传输         |
|  可靠性  |       由终端保证       |          由网络保证          |
| 故障影响 |    自动切换其他路径    |     故障节点导致连接中断     |
| 流量控制 |      终端自行控制      |        网络或终端控制        |

#### 软件定义网络 SDN

 **SDN（软件定义网络）**：

|              |   控制平面   |   数据平面   |  北向接口   |   南向接口   |    东西向接口    |
| :----------: | :----------: | :----------: | :---------: | :----------: | :--------------: |
|   **功能**   | 决策路由策略 | 执行数据转发 | 提供API接口 | 兼容硬件设备 | 内部控制器间通信 |
| **通信协议** |              |              | RESTful API | OpenFlow/P4  |   BGP-LS/RAFT    |

#### 拥塞控制

|              |                  流量控制                  |               拥塞控制                |
| :----------: | :----------------------------------------: | :-----------------------------------: |
| **控制目标** | 防止**发送方**撑爆**接收方**（**点对点**） |  防止**网络链路**过载（**全局性**）   |
| **触发条件** |           接收方**缓冲区快满**了           | 路由器/交换机**排队延迟高、丢包严重** |
| **控制对象** |           调整单个连接的发送速率           |    调整所有经过拥塞链路的连接速率     |
| **实现层级** |    数据链路层或传输层（如TCP滑动窗口）     | 网络层或传输层（如TCP Reno、BBR算法） |
| **生活比喻** |        水龙头调小水流，防止水杯溢出        |  交警在拥堵路口限流，避免全城大堵车   |
|  **关联性**  |         解决**接收端能力不足**问题         |       解决**网络资源不足**问题        |

**开环控制** → **"预防性限流"**
**闭环控制** → **"动态监控调整"**

### 2.IPv4

#### IPV4分组格式

<img src="408.assets/image-20250803170119922.png" alt="image-20250803170119922" style="zoom:80%;" />

**首部20B**

|   字段名   |  长度  |                           作用说明                           |
| :--------: | :----: | :----------------------------------------------------------: |
|    版本    | 4 bit  |                协议版本号（**IPv4固定为4**）                 |
|  首部长度  | 4 bit  |     头部长度（**单位：4字节**），**通常为5（即20字节**）     |
|  服务类型  | 8 bit  |             用于区分网络优先级（如视频通话优先）             |
|   总长度   | 16 bit | 整个数据报的总大小（最大$2^{16}-1=65535$字节）（**单位：1字节**） |
|    标识    | 16 bit |               **数据报唯一编号，用于分片重组**               |
|    标志    | 3 bit  |       控制分片：**DF=0允许分片**；**MF=1后面还有分片**       |
|   片偏移   | 13 bit |       当前**分片在原数据中的位置**（**单位：8字节**）        |
|  生存时间  | 8 bit  |        数据报存活跳数（每经过一个路由器减1，到0丢弃）        |
|    协议    | 8 bit  |              上层协议类型（**6=TCP，17=UDP**）               |
| 首部校验和 | 16 bit |                       校验头部是否出错                       |
|   源地址   | 32 bit |                        发送方的IP地址                        |
|  目的地址  | 32 bit |                        接收方的IP地址                        |
|    选项    |  可变  |                   扩展功能（实际很少使用）                   |
|    填充    |  可变  |                  确保头部长度是4字节的倍数                   |

#### 数据报分片

**最大传送单元MTU，数据报大小超过MTU，则要分片**

分片相关首部字段：**标识、标志、片偏移**

**同一数据报，所有分片的标识相同**

<img src="408.assets/image-20250803171509127.png" alt="image-20250803171509127" style="zoom:80%;" />

注意：**片偏移的计算只包含数据部分，不包含首部**（上面用1480而不是1500除以8）

#### IP地址

<img src="408.assets/image-20250803171710785.png" alt="image-20250803171710785" style="zoom:80%;" />

|    特殊IP地址    | 格式      |            示例             |                        用途说明                        |
| :--------------: | --------- | :-------------------------: | :----------------------------------------------------: |
|   **网络地址**   | 主机号全0 |        202.98.174.0         |      表示整个网络本身（如"202.98.174.x"这个网段）      |
| **直接广播地址** | 主机号全1 |       202.98.174.255        |      向本网络内所有设备广播（如局域网内群发消息）      |
| **环回测试地址** | 127.x.x.x | 127.0.0.1 ~ 127.255.255.254 | **本机内部通信**（如**ping 127.0.0.1**测试本地网络栈） |
|   **本机地址**   | 全0       |           0.0.0.0           |   **表示当前设备**（常见于**DHCP**获取IP前临时使用）   |
| **受限广播地址** | 全1       |       255.255.255.255       |    仅在本网络内广播（路由器不转发，用于ARP请求等）     |

<img src="408.assets/image-20250803172357577.png" alt="image-20250803172357577" style="zoom:80%;" />

**A类少的两个网络号**分别为**全0(本机地址)**和**127(环回地址)**

**A、B、C少的两个主机号**分别为**全0(表示网络)**和**全1(广播地址)**

IP地址特点：

1. 路由器**仅根据网络号转发**
2. **路由器分割广播域**，因此**每个端口的网络号不同**
3. 转发器(**集线器、中继器**)和桥接器(**交换机、网桥**)**不分割广播域**，因此**每个端口的网络号相同**，但是**主机号不同**

#### 网络地址转换 NAT

连接多个LAN的**路由器使用公网IP**访问互联网

路由器内部的**LAN采用私网IP**

**私网IP可重复**，缓解IP地址不足

**私网IP的范围是固定的**，和公网IP地址区别开：

|            私网地址范围             |    适用场景     |       备注        |
| :---------------------------------: | :-------------: | :---------------: |
|    10.0.0.0/8 ~ 10.255.255.255/8    |  大型企业内网   |   单个A类地址段   |
|  172.16.0.0/12 ~ 172.31.255.255/12  | 中型机构/云服务 | 16个连续B类地址段 |
| 192.168.0.0/16 ~ 192.168.255.255/16 | 家庭/小型办公室 |  256个C类地址段   |

$$
多个私网IP\rightarrow 公网IP:多个端口
$$

<img src="408.assets/image-20250803174545124.png" alt="image-20250803174545124" style="zoom:80%;" />

由于NAT路由器需要**用端口和私网IP映射**，因此**NAT路由器工作在传输层**

#### 子网

$$
\mathrm{IP~}\text{地址}..=\{<\text{网络号}>,<\text{子网号}>,<\text{主机号}>\}
$$

比如C类网络208.115.21.0，4个子网，**子网号2位，主机号6位**
**每个子网可分配的IP地址数$2^6-2=62$**，可见**划分子网减少了主机数**

---

$$
IP地址按位与子网掩码=网络号
$$

**子网掩码包含子网位**

**默认网关**：主机或子网连接的**路由器端口的IP地址**。作用是如果**目的地址不在子网下，就必须先传给默认网关**，默认网关通过路由表对比目的地址的网络号，找到下一条地址

> **路由表格式**：
>
> | 网络号 | 子网掩码 | 下一条地址 |
> | ------ | -------- | ---------- |

#### 无分类编址 CIDR

斜线表示法

CIDR不使用子网：**没有子网字段**

#### 路由聚合

寻找**最长相同前缀**

**定长子网掩码划分子网**：**每个子网长度相同**

<img src="408.assets/image-20250803210151793.png" alt="image-20250803210151793" style="zoom:80%;" />

**变长子网掩码划分子网**：

<img src="408.assets/image-20250803210458359.png" alt="image-20250803210458359" style="zoom: 67%;" />

#### 转发分组的过程

**转发表匹配时，优先匹配最长前缀**

**特定主机路由**：a.b.c.d/32，**指明必须走某个路由**(常用于网络测试)

**默认路由**：0.0.0.0/0，路由器到互联网的路由，**目标路由不在转发表中，只能选择默认路由**

#### 地址解析协议 ARP

网络层的路由器找到下一条，由于**报文需要封装为帧在数据链路层传输**，**数据链路看不到IP地址**，因此需要**借助ARP协议得到下一条的MAC地址写入帧首部**中，让**数据链路层能正确找到目的地址**

因此，**在不同网络间传输时，帧的源地址和目的地址在不断变化**

**ARP表格式**：

| IP地址 | MAC地址 |
| ------ | ------- |

**ARP获取MAC帧地址**：

1. 查看每台主机都有的ARP表，若有，则直接写入帧的目的地址
2. 若没有，**广播目的地址为`FF-FF-FF-FF-FF-FF`的帧**：
	1. **只有目标IP的主机**会单播回复ARP响应，包含自己的`IP-MAC`映射。
	2. 其他主机收到广播请求后，发现IP不匹配则**丢弃请求**（不会回复）。

#### 动态主机配置协议 DHCP

**DHCP是应用层协议**，它是**基于UDP**的

| 步骤 |   交互报文    |             源IP              |           目的IP            |                             说明                             |
| :--: | :-----------: | :---------------------------: | :-------------------------: | :----------------------------------------------------------: |
|  1   | DHCP Discover |           `0.0.0.0`           |      `255.255.255.255`      | 新设备喊话：“我是新来的，有没有DHCP服务器？”（全网广播寻找服务器） |
|  2   |  DHCP Offer   |  服务器IP（如`192.168.1.1`）  |      `255.255.255.255`      | 服务器回应：“我这有IP（如192.168.1.100），租期2天，要不要？”（可能收到多个Offer） |
|  3   | DHCP Request  |           `0.0.0.0`           |      `255.255.255.255`      | 客户端选择其中一个Offer，广播确认：“我要用这个IP！”（防止其他服务器重复分配） |
|  4   |   DHCP ACK    |  服务器IP（如`192.168.1.1`）  |      `255.255.255.255`      | 服务器最终确认：“IP和配置（网关、DNS等）给你了，计时开始！”（客户端正式启用网络配置） |
| 释放 | DHCP Release  | 客户端IP（如`192.168.1.100`） | 服务器IP（如`192.168.1.1`） | 设备下线时主动归还IP：“不用这个地址了，回收吧！”（提前终止租约） |

**采用广播是因为客户端初始无IP地址，只能通过全网广播（255.255.255.255）寻找DHCP服务器，确保服务器和客户端能发现彼此**

#### 网际控制报文协议 ICMP

|     报文类型     | 类型值 |           用途           |                           典型示例                           |
| :--------------: | :----: | :----------------------: | :----------------------------------------------------------: |
| **差错报告报文** |        | **通知传输过程中的错误** |  目标主机或到日标主机路径上的路由器，向源主机报告差错和异常  |
|    终点不可达    |   3    |  路由/端口不可达时反馈   | 发送数据到未开启的端口，路由器回复`Type=3, Code=3`（端口不可达） |
|     源点抑制     |   4    |  通知发送方降低发送速率  |    路由器缓存满时发送（已弃用，现代网络改用TCP拥塞控制）     |
|     时间超过     |   11   |  TTL减到0或分片重组超时  | `tracert`命令利用此报文逐跳探测路径（`Type=11, Code=0`表示TTL超时） |
|      重定向      |   5    |     指示更优路由路径     |      网关通知主机直接发送给另一网关（`Type=5, Code=0`）      |
|   **询问报文**   |        |  **主动发起诊断或测试**  |                                                              |
|  回送请求/回答   |  8/0   |        测试连通性        |     **`ping`命令**使用`Type=8`请求，目标回复`Type=0`应答     |
| 时间戳请求/回答  | 13/14  |    同步时间或测量延迟    | 请求方发送`Type=13`，应答方返回`Type=14`（含发送/接收时间戳） |

### 3.IPv6

#### IPv6数据报

<img src="408.assets/image-20250804113614862.png" alt="image-20250804113614862" style="zoom:80%;" />

|                  |           IPv4            |                  IPv6                   |                    更改原因/影响                    |
| :--------------: | :-----------------------: | :-------------------------------------: | :-------------------------------------------------: |
| **地址长度** |      **32位**       |      **128位**       |         IPv6彻底解决地址耗尽问题         |
| **地址表示** | **点分十进制**（如`192.168.1.1`） | **冒号分十六进制**（如`2001:0db8::1`） |       IPv6**省略前导0和连续0**（`::`压缩）       |
|   **首部长度**   | 可变（20-60字节，含选项） |             **固定40字节**              |        路由器无需解析变长首部         |
|   **服务类型**   |      存在（ToS字段）      |                **取消**                 |     优先级和流标号字段（IPv6新功能）替代其功能      |
|    **总长度**    |   总长度字段（含首部）    |  **有效载荷长度**字段（**仅数据部分**） |          更精准描述数据大小，排除首部干扰           |
|   **分片控制**   |  标识、标志、片偏移字段   |         **移至分片的扩展首部**          |           分片由源端处理，减少路由器负担            |
|   **生存时间**   |          TTL字段          | **跳数限制(Hop Limit)**字段（功能相同） |           名称更贴切（每跳减1，直至归零）           |
| **上层协议标识** |    协议字段（如TCP=6）    |             下一个首部字段              | 兼容扩展首部链式结构（如`IPv6头→路由扩展头→TCP头`） |
|    **校验和**    |     存在（首部校验）      |                **取消**                 |      **依赖上层（如TCP/UDP）校验**，加速路由器转发      |
|   **选项功能**   |  选项字段（嵌入主首部）   |    扩展首部实现（如路由、分片选项）     |          按需加载扩展首部，避免主首部膨胀           |

#### IPv6首部

<img src="408.assets/image-20250804113634545.png" alt="image-20250804113634545" style="zoom:80%;" />

|     字段名称     | 位数  |                           功能说明                           |
| :--------------: | :---: | :----------------------------------------------------------: |
|     **版本**     |  4位  |              协议版本号（**IPv6固定值为`6`**）               |
|   **通信量类**   |  8位  |    区分数据报的**优先级或服务类别**（如视频通话优先传输）    |
|    **流标号**    | 20位  |  所有**属于同一个流的数据报都具有相同的流标号**（如音视频）  |
| **有效载荷长度** | 16位  | **除基本首部外**，数据报的总字节数（含扩展首部），最大65535字节 |
|  **下一个首部**  |  8位  | 无扩展首部时：**标识上层协议（如`6=TCP`）**；有扩展首部时：标识首个扩展首部类型 |
|   **跳数限制**   |  8位  |  **类似IPv4的TTL**，每经路由器减1，归零时丢弃（最大255跳）   |
|    **源地址**    | 128位 |             发送端的IPv6地址（如`2001:db8::1`）              |
|   **目的地址**   | 128位 |             接收端的IPv6地址（如`2001:db8::2`）              |

#### IPv6地址

地址表示方法

1. 每个域的**前导0省略**
2. 多个**相邻的域全为0，用`::`表示**（**只能使用一次**，否则无法推断省略的域的个数）

`4BF5:0000:0000:0000:BA5F:039A:000A:2176`->`4BF5::BA5F:039A:A:2176`

---

**特殊地址**：

|       地址类型       | 二进制前缀 |  简写形式   |                           用途说明                           |
| :------------------: | :--------: | :---------: | :----------------------------------------------------------: |
|    **未指明地址**    |   00...0   |  `::/128`   | 仅作为未配置IP时的临时源地址（如初始化阶段），不能用作目的地址 |
|     **环回地址**     |  00...01   |  `::1/128`  |   用于本机内部测试（类似IPv4的`127.0.0.1`），仅此一个地址    |
|     **多播地址**     |  11111111  | `FF00::/8`  |       一对多通信（如视频会议），占IPv6地址空间的1/256        |
| **本地链路单播地址** | 1111111010 | `FE80::/10` |   局域网内通信（类似IPv4的`169.254.0.0/16`），无需全局路由   |

**全球单播地址**：

<img src="408.assets/image-20250804120224158.png" alt="image-20250804120224158" style="zoom:80%;" />

由于接口标识符(网络号)有64位，因此可以**将MAC地址直接存到接口标识符**，**IPv6不需要ARP协议**

#### IPv4向IPv6过度

1. **双协议栈**：设备同时配有IPv4、IPv6两个ip地址
2. **隧道技术**：把IPv6封装到IPv4的数据部分

### 4.路由算法

**静态路由算法**：手动配置路由

**动态路由算法**：动态调整，可分为两类：距离-向量路由算法、链路状态路由算法

|              |             距离-向量算法              |                    链路状态算法                    |
| :----------: | :------------------------------------: | :------------------------------------------------: |
| **核心思想** |   邻居间交换路由表，**迭代更新跳数**   | **每个路由器掌握全网拓扑图**，**独立计算最短路径** |
| **信息交换** | 定期**向每个邻居**发送**距离向量副本** |        广播**所有节点**自己的**链路状态图**        |
| **收敛速度** |       **慢**（逐跳传递，易环路）       |           **快**（基于**Dijkstra**算法）           |
| **适用规模** |       **小型网络**（跳数限制15）       |           **中大型网络**（支持分层设计）           |
| **典型协议** |                **RIP**                 |                      **OSPF**                      |

每个自治系统(AS)有一组路由器，AS内部用内部网关协议，AS之间用外部网关协议

<img src="408.assets/image-20250804161805353.png" alt="image-20250804161805353" style="zoom:80%;" />

### 5.路由协议

#### RIP

**距离-向量算法**，**内部网关协议**

**路由表项**：

| 目的网络$N$ | 距离$d$(跳数) | 下一跳路由器地址$X$ |
| ----------- | ------------- | ------------------- |

**和谁交换信息**：**相邻节点**

**交换什么信息**：自己的**路由表**

**交换间隔**=30秒

**跳数上限**=15，只适用于**小型网络**

RIP是**应用层**协议，它使用**UDP**传送数据(端口520)

“好消息传播得快，**坏消息传播得慢**”，**链路发生故障的消息收敛速度很慢**

**算法过程**：

```python
函数 处理RIP报文(路由器X的报文, 相邻路由器X, 当前路由表):
    # 第一步：修改报文内容
    对于 路由器X的报文中的每个项目:
        项目.下一跳 = 相邻路由器X  # 将下一跳地址改为发送方X
        项目.距离 += 1           # 距离值加1
    
    # 第二步：更新路由表
    对于 修改后的路由器X的报文的每个项目:
        N = 项目.目的网络
        
        如果 当前路由表中不存在目的网络N:
            # 情况1：新网络，直接添加
            当前路由表.添加项目(项目)
            
        否则 如果 存在目的网络N，该行的下一跳 == 相邻路由器X:
            # 情况2：来自同一邻居的更新，直接替换
            当前路由表.更新项目(项目)
            
        否则 如果 存在目的网络N，该行的下一跳 != 相邻路由器X:
            # 情况3：发现更优路径，更新路由表
            当前路由表.选择更优项目(项目, 当前路由表[N])
    
    返回 当前路由表
```

> 例子：R6收到R4发来的路由表
>
> <img src="408.assets/image-20250804163606088.png" alt="image-20250804163606088" style="zoom:80%;" />

#### OSPF

**链路状态算法**，**内部网关协议**

**和谁交换信息**：**所有节点**

**交换什么信息**：与本路由器**相邻的所有路由器的链路状态**

每个节点**都有一份完整的网络拓扑**，通过**Djikstra算法**得到最短路径

适用于**大型网络**

OSPF是**网络层**协议，它使用**IP**传送数据(首部协议号89)

**OSPF的五种分组**：

|       分组类型       |                           主要作用                           |
| :------------------: | :----------------------------------------------------------: |
|     **问候分组**     |    用于**发现和维护邻居关系**，周期性发送以确认邻接存活。    |
|  **数据库描述分组**  | 在**邻接建立初期**，交换链路状态数据库的摘要信息，用于**同步两端数据**。 |
| **链路状态请求分组** | 当发现**本地缺少或过时的链路状态信息**时，向邻居请求详细数据。 |
| **链路状态更新分组** | 携带具体的链路状态信息，用于**响应请求或主动更新**网络状态。 |
| **链路状态确认分组** |         确认收到链路状态更新分组，确保信息可靠传输。         |

**OSPF的流程**：

1. **邻居发现**：通过**问候分组**建立并维护邻居关系
2. **数据库同步**：使用**数据库描述分组**、**链路状态请求分组**、**链路状态更新分组**完成链路状态数据库同步
3. **路由计算**：基于同步后的数据库计算**Djikstra**最短路径，生成路由表
4. **状态维护**：通过**问候分组**保持连接，使用**链路状态更新分组**和**链路状态确认分组**处理网络变化。

#### BGP

**外部网关协议**

BGP是**应用层**协议，它是基于**TCP**的

**外部BGP(eBGP)**：跨越两个AS的BGP会话

**内部BGP(iBGP)**：AS内部的BGP会话

**热土豆路由选择算法**：选择**最少次数离开本AS的路由**

BGP**刚运行时，交换整个路由表**；**之后只交换有变化的分布**

**BGP的四种报文**：

|         报文类型         |              作用              |
| :----------------------: | :----------------------------: |
|     **打开（Open）**     |  **初始化通信**，建立对等关系  |
|    **更新（Update）**    |      核心**路由通告**机制      |
|  **保活（Keepalive）**   | 周期性发送以**确认对等方存活** |
| **通知（Notification）** |    **检测到错误时立即发送**    |

![image-20250804174708480](408.assets/image-20250804174708480.png)

### 6.IP多播

<img src="408.assets/image-20250804175211769.png" alt="image-20250804175211769" style="zoom:80%;" />

**IP多播地址**：D类地址`224.0.0.0~239.255.255.255(1110开头)`

#### 网际组管理协议 IGMP

让路由器知道**哪些设备想接收多播数据**（比如谁加入了视频直播组），实现高效组播转发

### 7.移动IP

让设备在**切换网络时（如从WiFi切到4G）保持IP地址不变**，确保**通信不中断**

### 8.网络层设备

#### 冲突域和广播域

**冲突域**：**连接到同一物理介质**上的所有节点的集合，介质争用

**广播域**：能**接收同样广播消息**的节点集合，**局域网**是由路由器分割的网络，是一个广播域

#### 路由器

**路由器**：路由选择+分组转发

**路由选择**：根据路由协议**构造路由表**

**分组转发**：**根据转发表**将分组从合适端口转发

路由器有能力对数据“包装”这三层协议或者“拆开”这三层协议

**路由器有能力互联三层协议不同的两个网络**

#### 路由表

**路由表表项**：

| 目的网络号 | 子网掩码 | 下一跳IP地址 | 接口 |
| ---------- | -------- | ------------ | ---- |

转发表由路由表得出，里面可以有**默认路由**，即**目的网络号不在转发表，则一律转发至默认路由**

**转发表表项**：

| 目的网络号 | 下一跳IP地址 |
| ---------- | ------------ |

**转发**：只涉及一个路由器

**路由选择**：涉及多个路由器



## 第5章：传输层

### 1.传输层概念

#### 端口

**端到端通信**：主机和主机的**进程之间**的通信

<img src="408.assets/image-20250804204309121.png" alt="image-20250804204309121" style="zoom:80%;" />

**端口**：**端口在传输层的作用=IP地址在网络层的作用**

#### 端口号

16位，$2^{16}-1=65536$

1. **服务器**端使用的端口号：

	1. **熟知端口号**：1~1023，分配给最重要的应用程序

		|    应用程序    | FTP  | TELNET | SMTP | DNS  | TFTP | HTTP | SNMP |
		| :------------: | :--: | :----: | :--: | :--: | :--: | :--: | :--: |
		| **熟知端口号** |  21  |   23   |  25  |  53  |  69  |  80  | 161  |

	2. **登记端口号**：1024~49151

2. **客户端**使用的端口号：49152~65535，客户端应用运行时**动态分配**

#### 套接字 Socket

$$
套接字(Socket) =(IP 地址：端口号)
$$

#### 服务访问点 SAP

|                |   服务访问点（SAP）    |                           作用说明                           |
| :------------: | :--------------------: | :----------------------------------------------------------: |
| **数据链路层** |    帧的**类型字段**    | 标识上层协议类型（如`0x0800`表示IPv4，`0x0806`表示ARP），决定数据交给哪个网络层协议处理。 |
|   **网络层**   | IP数据报的**协议字段** | 标识传输层协议（如`6`=TCP，`17`=UDP），决定数据交给哪个传输层协议处理。 |
|   **传输层**   |     **端口号字段**     | 标识应用层服务（如`80`=HTTP，`443`=HTTPS），决定数据交给哪个应用进程处理。 |
|   **应用层**   |      **用户界面**      | 用户直接交互的入口（如浏览器地址栏、APP界面），将数据呈现给最终用户或接收用户输入。 |

#### 无连接服务和面向连接服务

**TCP不提供广播和多播服务**，因为是**一对一有连接**的通信

|  互联网应用  |    TCP/IP 应用层协议     | TCP/IP 传输层协议 |
| :----------: | :----------------------: | :---------------: |
|   域名解析   |     域名系统（DNS）      |        UDP        |
|   文件传送   | 简单文件传送协议（TFTP） |        UDP        |
|   路由选择   |   路由信息协议（RIP）    |        UDP        |
| IP 地址分配  | 动态主机配置协议（DHCP） |        UDP        |
|   网络管理   | 简单网络管理协议（SNMP） |        UDP        |
|   IP 多播    |  网际组管理协议（IGMP）  |        UDP        |
|   电子邮件   | 简单邮件传送协议（SMTP） |        TCP        |
| 远程终端接入 |  远程终端协议（TELNET）  |        TCP        |
|    万维网    |  超文本传送协议（HTTP）  |        TCP        |
|   文件传送   |   文件传送协议（FTP）    |        TCP        |

### 2.UDP

|    优点    |                             说明                             |
| :--------: | :----------------------------------------------------------: |
| **无连接** |           无需预先建立连接即可发送数据，通信效率高           |
| **速度快** | 无握手、重传等流程，传输**延迟低**，适合实时应用（如**视频流**、**IP多播**） |
| **开销小** | 头部仅8字节（TCP至少20字节），节省带宽，适合**小数据量传**输（如**DNS**、**SNMP**） |

**可靠性在应用层实现**

最小单位是**报文**

#### UDP首部

大小为**8B**

<img src="408.assets/image-20250804211100265.png" alt="image-20250804211100265" style="zoom:80%;" />

#### UDP校验

添加12B的伪首部

把**伪首部、首部、数据字段**看作许多**16位(2字节)**串起来（不足则补0）

1. **把这些16位相加**，注意**最高位进1则回写到最低位**
2. 把第一步的和**按位取反**（不能忘记）
3. **把这些16位连同第二步的结果相加**，**结果全为1，则无误**

<img src="408.assets/image-20250804212408930.png" alt="image-20250804212408930" style="zoom:80%;" />

**还可以校验伪首部中的源IP地址和目的IP地址**

### 3.TCP

#### TCP报文段

数据单元位**报文段**

**TCP首部最短20B，必须是4B的倍数**

<img src="408.assets/image-20250804213303107.png" alt="image-20250804213303107" style="zoom:80%;" />

|     字段     | 长度 |                          含义与作用                          |
| :----------: | :--: | :----------------------------------------------------------: |
|  **源端口**  | 16位 |         发送方的应用程序端口号（如HTTP服务端默认80）         |
| **目的端口** | 16位 |          接收方的应用程序端口号（如客户端随机端口）          |
|  **序列号**  | 32位 | 当前**数据段的第一个字节的编号**，**TCP给字节流每个字节编号** |
|  **确认号**  | 32位 |  **期望收到的下一个字节的序列号**，实现可靠传输（ACK机制）   |
| **数据偏移** | 4位  | **TCP首部长度**（以**4字节为单位**），用于定位数据部分起始位置。 |
| **控制标志** | 6位  | `SYN`=建立连接 `ACK`=确认有效 `FIN`=关闭连接 `RST`=重置连接  |
| **窗口大小** | 16位 |     **接收方可接收的剩余缓冲区大小**（**流量控制**依据）     |
|  **校验和**  | 16位 |      校验**头部**和**数据部分**的完整性（防止传输错误）      |
| **紧急指针** | 16位 |      标识**紧急数据的字节数**（需配合`URG=1`标志使用）       |
|   **选项**   | 可变 |          扩展功能（如最大段长度MSS、窗口缩放因子）           |

#### TCP连接管理

**三次握手**：

<img src="408.assets/image-20250804215125286.png" alt="image-20250804215125286" style="zoom:80%;" />

**四次挥手**：

<img src="408.assets/image-20250804215110219.png" alt="image-20250804215110219" style="zoom:80%;" />

**CLOSE_WAIT阶段，服务器还能传输数据**，但是之前发生FIN的**客户端到服务器的信道已经关闭**

#### TCP可靠传输

校验方法同UDP

**序号**：TCP**传输字节流**，**给每个字节一个编号**

<img src="408.assets/image-20250804215819298.png" alt="image-20250804215819298" style="zoom:80%;" />

**确认**：期待接收的**下一个序号**

**重传**：两种情况会重传：**超时、冗余ACK**

1. 超时
2. **冗余ACK**：TCP规定**每当比期望序号大的失序报文段到达时，就发送一个冗余ACK**，发送方收到3个冗余ACK就快速重传

#### TCP流量控制

端到端流量控制，发送方不要太快

TCP通过**滑动窗口**实现流量控制

**接收窗口(rwnd)**大小放在TCP报文段的**“窗口”字段**中，

<img src="408.assets/image-20250804220920610.png" alt="image-20250804220920610" style="zoom:80%;" />

**传输层的接收窗口大小可变**，**数据链路层的接收窗口不可变**

> **TCP的流量控制是GBN和SR的混合**
>
> 接收方可以**冗余ACK**(GBN特征)
>
> 发送方不需要重传N个，**只需重传一个**(SR特征)

#### TCP拥塞控制

防止网络中数据过多，导致丢包率显著增加

**拥塞控制是全局的**，**流量控制是端到端的**

**拥塞窗口(cwnd)**

**慢开始和拥塞避免**：

<img src="408.assets/image-20250804221621847.png" alt="image-20250804221621847" style="zoom:80%;" />

> **第17个轮次时cwnd=12，而不等于16**

**快重传和快恢复**：

<img src="408.assets/image-20250804221840551.png" alt="image-20250804221840551" style="zoom:80%;" />

> Tahoe版本连续收到3个冗余ACK和网络拥塞一样，采用拥塞避免

**触发条件**：

1. **慢开始和拥塞避免**：**网络拥塞**(Tahoe版本的3ACK)
2. **快重传和快恢复**：**连续3个冗余ACK**(Reno版本)



## 第6章：应用层

|    应用程序    | FTP 数据连接 | FTP 控制连接 | TELNET | SMTP | DNS  | TFTP | HTTP | POP3 | SNMP |
| :------------: | :----------: | :----------: | :----: | :--: | :--: | :--: | :--: | :--: | :--: |
|  **使用协议**  |     TCP      |     TCP      |  TCP   | TCP  | UDP  | UDP  | TCP  | TCP  | UDP  |
| **熟知端口号** |      20      |      21      |   23   |  25  |  53  |  69  |  80  | 110  | 161  |

### 1.网络模型

|              | C/S（客户端-服务器） |      P2P（对等网络）      |
| :----------: | :------------------: | :-----------------------: |
|   **架构**   | 集中式（服务器主导） |    分布式（节点平等）     |
|  **扩展性**  |    依赖服务器升级    |       节点越多越强        |
|  **可靠性**  |     单点故障风险     |         高容错性          |
| **典型应用** |   HTTP、FTP、SMTP    | BitTorrent、区块链、Skype |
|   **流量**   |     服务器易拥塞     |         负载均衡          |
|   **管理**   |     简单集中管理     |      复杂分布式管理       |

### 2.域名系统 DNS

**CS模型，UDP**

#### 域名

<img src="408.assets/image-20250804223529451.png" alt="image-20250804223529451" style="zoom:80%;" />

#### 域名服务器

|                    |               特点               |               主要作用                |   查询顺序   |
| :----------------: | :------------------------------: | :-----------------------------------: | :----------: |
|  **根域名服务器**  |            全球共13组            |      提供顶级域名服务器的IP地址       |  第1步查询   |
| **顶级域名服务器** | 管理顶级域名（如**.com、.net**） |       返回权限域名服务器的地址        |  第2步查询   |
| **权限域名服务器** |  由域名所有者管理（如**公司**）  |        存储每台主机的权限域名         |  第3步查询   |
| **本地域名服务器** |     通常由**ISP或企业提供**      | 代理用户完成整个DNS查询过程，缓存结果 | 用户直接访问 |

<img src="408.assets/image-20250804223824719.png" alt="image-20250804223824719" style="zoom:80%;" />

#### 域名解析

1. **主机**向**本地域名服务器**的查询都采用**递归查询**
2. **本地域名服务器**向**其他域名服务器**采用**递归查询或迭代查询**

<img src="408.assets/image-20250804224339322.png" alt="image-20250804224339322" style="zoom:80%;" />

### 3.文件传输协议 FTP

**CS模型，TCP**

FTP使用**两个并行的TCP连接**：**控制连接**(21)**和数据连接**(20)

**控制连接**：监听21号端口，**等待客户端连接**

**数据连接**：**PORT模式**(默认)，**客户端开一个端口，和服务器的20端口通信**；PASV模式，服务器开一个端口通知客户端

### 4.电子邮件

**SMTP协议**：**CS模型，TCP**，**发邮件**，**发送方服务器->接收方服务器**

**POP3协议**：**TCP**，**收邮件**

<img src="408.assets/image-20250804225456776.png" alt="image-20250804225456776" style="zoom:80%;" />

**SMTP**直接传输**ASCII码数据**

### 5.万维网

**因特网（Internet）**是全球连接的“硬件网络”（如电缆、路由器），像高速公路系统

**​万维网（WWW）​**​是跑在这条路上的“信息服务”（如网页、视频），像高速路上的快递和物流

**一句话**：因特网是基础，万维网是上面的应用——没有因特网，万维网无法存在；但没有万维网，因特网还能跑其他服务（如邮件、游戏）

#### HTTP

**HTTP协议**：**CS模型，TCP**

统一资源定位符**URL**：负责标识万维网上的各种文档，$<协议>://<主机>:<端口>/<路径>$

<img src="408.assets/image-20250804230407136.png" alt="image-20250804230407136" style="zoom:80%;" />

**HTTP协议特点**：

1. **无连接**，虽使用TCP，但在交换HTTP报文前不需要先建立HTTP连接
2. **无状态**，不记得用户，Cookie
3. **非持续性连接(HTTP1.0)**，**持续性连接(HTTP1.1)**

#### 页面请求时间分析

**非持续性连接**：**每个元素**（图片等）都需要：**传输时间+2RTT(1RTT握手，1RTT传文件)**

**持续性连接**：**一次握手**(1RTT)，**每个元素**：**传输时间+1RTT(传文件)**

**流水线**：**一次握手**(1RTT)，**n传输时间+1RTT**(自行画图理解)

#### HTTP报文

<img src="408.assets/image-20250804231256235.png" alt="image-20250804231256235" style="zoom:80%;" />

<img src="408.assets/image-20250804231315578.png" alt="image-20250804231315578" style="zoom:80%;" />





# 操作系统

## 第1章：计算机系统概述

### 1.操作系统概念

#### 操作系统作用

控制和管理**硬件和软件资源**，并为**用户提供**与计算机硬件系统的**接口**

1. 计算机**资源的管理**者：
	1. 处理机管理
	2. 存储器管理
	3. 文件管理
	4. 设备管理
2. 给**用户**和**应用程序**提供**接口**：
	1. **命令接口**：进一步分为**联机命令接口**和**脱机命令接口**
	2. **程序接口**：由**系统调用**组成（**程序接口就是系统调用**）
3. 实现对计算机资源的扩充：**裸机在内部，操作系统在外部**，方便用户将裸机改造为功能更强的机器

#### 操作系统特征

**并发性**：并发分时，并行真正同时

**共享性**：互斥共享(临界资源)，同时访问

**虚拟性**：虚拟处理器(一个处理器为多个终端用户服务)，虚拟存储器(扩大编程的地址空间)

**异步性**：**进程的执行顺序和速度不可预测**（但**结果确定**）

**最基本特征**：**并发+共享**

### 2.操作系统分类

#### 手工操作阶段

#### 批处理系统

**单道批处理系统**：

1. 自动性
2. 顺序性
3. **单道性**：**内存中只有一个程序**

**多道批处理系统**：

1. **多道**：一个程序因为**IO阻塞**，CPU**转而执行另一个程序**，通过**中断**实现
2. **宏观上并行**：**多个程序处于运行过程中，但是都未完成**
3. **微观上串行**：**轮流占用CPU**

批处理系统作业自动控制，**不支持人机交互**

**不具备顺序性**，**提高CPU利用率和吞吐量**

#### 分时系统

分成**时间片**

支持**多道程序设计**，**支持人机交互**

**目标**：**及时接收并处理用户输入的命令**

1. 同时性：**多个终端用户**同时使用计算机
2. 交互性：支持**人机交互**
3. 独立性：多个用户间**互不干扰**
4. 及时性：**短时间内得到回复**

#### 实时系统

必须在**被控对象规定时间内**完成事件

|                  |                          实时系统                          |                        分时系统                        |
| :--------------: | :--------------------------------------------------------: | :----------------------------------------------------: |
|   **核心目标**   | **保证任务在规定时间内完成**（硬实时）或尽量完成（软实时） |     **公平分配CPU时间**，提高多用户/多任务交互体验     |
| **响应时间要求** |              **严格时限**（毫秒级甚至微秒级）              |       **宽松时限**（秒级或更长，用户可接受延迟）       |
|   **任务调度**   |        **优先级驱动**，高优先级任务抢占低优先级任务        |       **时间片轮转**，每个任务轮流执行固定时间片       |
|  **可靠性要求**  | **极高**（系统故障可能导致严重后果，如航天控制、医疗设备） |     **较高**（用户容忍偶尔故障，如电脑死机可重启）     |
|   **应用场景**   |       工业控制、自动驾驶、导弹制导、医疗设备、机器人       | 多用户操作系统（如Linux、Windows）、服务器、个人计算机 |
|   **资源分配**   |             **资源预留**，确保关键任务资源可用             |               **动态分配**，资源按需分配               |
|    **确定性**    |          **强确定性**（任务执行时间和顺序可预测）          |    **弱确定性**（受用户行为影响，响应时间波动较大）    |
|   **用户交互**   |           **无交互或有限交互**（面向自动化控制）           | **强交互性**（支持多用户同时操作，如命令行或图形界面） |
|   **典型例子**   |                   VxWorks、QNX、FreeRTOS                   |                  UNIX、Linux、Windows                  |

<img src="408.assets/image-20250805132333228.png" alt="image-20250805132333228" style="zoom:80%;" />

### 3.用户态和内核态

#### 特权指令、非特权指令、硬件实现

**特权指令**：置时钟指令，停机指令，开中断指令，转移指令，中断屏蔽字设置指令，磁盘调度指令，中断处理指令，设备驱动指令，操作系统初始化指令，文件IO指令，进程切换指令，设备管理指令，访问程序状态指令，存取特殊寄存器指令

|      子类别      |                          指令/功能                           |
| :--------------: | :----------------------------------------------------------: |
|  **处理器控制**  |           停机指令、开中断指令、中断屏蔽字设置指令           |
| **内存/IO管理**  |     磁盘调度指令、设备驱动指令、文件IO指令、设备管理指令     |
| **系统核心操作** | 操作系统初始化指令、进程切换指令、创建新进程指令、访问程序状态字PSW指令、存取特殊寄存器指令 |
|   **安全隔离**   |                          置时钟指令                          |

**非特权指令**：存数指令，寄存器清零指令，陷入指令，系统调用指令，跳转指令，压栈指令，设置断点指令

|      子类别      |                       指令/功能                       |                 说明                 |
| :--------------: | :---------------------------------------------------: | :----------------------------------: |
|   **数据操作**   |          存数指令、寄存器清零指令、压栈指令           | 通用寄存器/栈操作（如`MOV`、`PUSH`） |
|   **流程控制**   |                跳转指令（条件/无条件）                |     改变执行流（如`JMP`、`JE`）      |
| **系统服务请求** | 陷入指令（如`INT 0x80`）、系统调用指令（如`syscall`） |       通过安全通道请求内核服务       |
|   **调试支持**   |            设置断点指令（如`x86`的`INT3`）            |     触发调试异常（需调试器配合）     |

**硬件实现**：中断的断点和程序状态字PSW保存，将CPU模式改为内核态

|        操作         |         触发场景         |                         说明                         |
| :-----------------: | :----------------------: | :--------------------------------------------------: |
| 中断的断点和PSW保存 |     发生中断/异常时      |        硬件自动保存现场（如`RIP`、`EFLAGS`）         |
| 将CPU模式改为内核态 | 执行系统调用或触发异常时 | 通过预设的异常向量表切换模式（如x86的`SYSCALL`入口） |

#### 用户态和内核态对比

|                 |                    用户态                    |                          内核态                          |
| :-------------: | :------------------------------------------: | :------------------------------------------------------: |
|  **权限级别**   |     **低权限**（受限访问硬件和关键资源）     |       **高权限**（直接访问硬件、内存、设备驱动等）       |
|  **执行环境**   |   运行普通应用程序（如浏览器、文本编辑器）   |  运行操作系统核心代码（如进程调度、内存管理、中断处理）  |
|  **资源访问**   | 只能通过**系统调用（Syscall）**请求内核服务  |          可直接操作CPU、内存、I/O设备等底层资源          |
|   **安全性**    |   **隔离性强**，程序崩溃不会影响系统稳定性   | **风险高**，内核代码错误可能导致系统崩溃（如蓝屏、死机） |
|  **切换方式**   |      **中断/异常/系统调用**切换到内核态      |       通过**特权指令返回**（如`iret`）切换回用户态       |
|  **典型操作**   |   - 调用`printf()` - 打开文件（`fopen()`）   |      - 分配物理内存 - 切换进程上下文 - 处理硬件中断      |
| **CPU指令限制** | 无法执行**特权指令**（如关闭中断、修改页表） |           可执行所有CPU指令，**除了访管指令**            |
|  **内存保护**   |     只能访问**用户空间内存**（虚拟地址）     |            可访问**全部内存**（包括内核空间）            |
|  **性能开销**   |            用户态代码执行**高效**            |  内核态操作**开销大**（需保存/恢复上下文、检查安全性）   |
|  **调试难度**   |              易于调试（如GDB）               |             调试困难（需内核调试工具如KGDB）             |

> **访管指令=系统调用指令，只能由用户态调用**

#### 系统调用

**系统调用**：用户态程序**请求操作系统内核服务**的**唯一合法接口**

**系统调用过程示意图**：

<img src="408.assets/image-20250805164828506.png" alt="image-20250805164828506" style="zoom:80%;" />

**系统调用vs库函数**：

|            | 系统调用           | 库函数   |
| ---------- | ------------------ | -------- |
| **属于**   | **操作系统**       | 应用程序 |
| **运行在** | **内核态**         | 用户态   |
| **速度**   | **慢(上下文切换)** | 块       |

#### 用户态->内核态

**触发条件**：

1. **系统调用**
2. **中断(用户程序通过自陷trap指令进入内核态)**
3. **错误(error)状态**
4. 企图**执行特权指令**

用户态切换到内核态的**唯一途径**是**中断**

> 上述所有触发条件，最后都**必须中断**才能切换到内核态

### 4.操作系统结构

#### 分层法

<img src="408.assets/image-20250811212746140.png" alt="image-20250811212746140" style="zoom:80%;" />

优点：**便于调试**，**易扩展和维护**

缺点：**效率较低**，**不够灵活**

#### 模块化

<img src="408.assets/image-20250811212957568.png" alt="image-20250811212957568" style="zoom:80%;" />

优点：**易维护和理解**，**可靠性低(模块间相互依赖)**

#### 宏内核

**所有主要功能模块都运行在内核态**

缺点：**可靠性低**(一个坏了，整个内核都坏了)，**扩展性低**

**Windows(宏+微)，Android，iOS，macOS，Linux**

#### 微内核

**最基本的操作保留在内核，其它功能移至用户态**

**只有微内核运行在内核态**，**其余模块都运行在用户态**

这样**其它模块故障时，不会像宏内核一样导致整个系统崩溃**

**放入微内核的功能**：

1. **进程管理(名字里带进程，统统放入)**
2. **低级存储器管理**(**逻辑地址->物理地址**的功能)
3. **中断和陷入**

**微内核的特点**：

1. **扩展性**和**灵活性**：当要**修改某些功能或增加新功能**时，只需在相应的服务器中修改或新增功能，或再增加一个专用的服务器，而**无须改动内核代码**
2. **可靠性**和**安全性**
3. **可移植性**
4. **适合分布式**计算
4. **CS模式**
4. **机制与策略分离**

**微内核的缺点**：**性能低，频繁用户态和内核态切换**

#### 外核

**外核**只负责**硬件资源**的分配、回收、保护等；

**进程管理**相关的工作仍然由**内核**负责

### 5.操作系统引导

**BIOS(基本输入/输出系统)**是一组固化在主板的**ROM芯片上的程序**

计算机的启动依赖于**引导程序**，它是一段特殊的程序，负责加载操作系统内核到内存并启动系统。根据存储位置和功能，**引导程序分为两类**：

1. **ROM自举程序（BIOS的一部分）**
	- **位置**：固化在**主板ROM芯片**中
2. **磁盘引导程序（启动管理器）**
	- **位置**：存储在磁盘的**活动分区引导扇区**中

| 步骤 |  关键操作  |                       说明                        |
| :--: | :--------: | :-----------------------------------------------: |
|  1   |  CPU激活   | 从地址FFFF0H获取第一条JMP指令，**跳转至BIOS程序** |
|  2   | BIOS初始化 |   在内存低地址构建**中断向量表**和基础服务程序    |
|  3   |  硬件检测  |  执行POST（**通电自检**），检测**关键硬件**状态   |
|  4   |  系统引导  |    在存储设备中搜索**操作系统内核并加载启动**     |

### 6.虚拟机

虚拟机是指利用虚拟化技术，**将一台物理机器虚拟化为多台虚拟机器**

虚拟机可以**软件实现**，也可以**硬件实现**

|     对比维度     |     第一类VMM（裸机型）      |          第二类VMM（托管型）           |
| :--------------: | :--------------------------: | :------------------------------------: |
|   **运行层级**   |     直接**运行在硬件**上     |       **运行在宿主操作系统**之上       |
| **硬件访问权限** |      可**直接访问硬件**      |       通过宿主OS**间接访问硬件**       |
|   **运行效率**   |   **更高**（无中间层损耗）   |      **较低**（需经过宿主OS转换）      |
|   **特权级别**   | **最高特权级**（**内核态**） |    **用户态**（**与普通应用同级**）    |
|   **典型代表**   |  VMware ESXi、Xen、Hyper-V   | **VirtualBox**、**VMware Workstation** |



## 第2章：进程与线程

### 1.进程

#### 进程的组成

**进程**=**程序段+数据段+PCB(进程控制块)**=**程序的一次执行**

**PCB**：**进程的唯一标识**，内部有PID和UID等

**程序段**：**程序可被多个进程共享**

**数据段**：就是数据

#### 进程的特点

1. **动态性**：**进程是动态的，程序是静态的**
2. **并发性**：多个进程并发执行
3. **独立性**：进程是**执行、资源分配、调度的单位**
4. **异步性**：**并发进程**执行**结果具有不可再现性**

### 2.进程的状态

#### 五种状态

**运行态**：**同一时刻只能有一个进程运行**

**就绪态**：**只差CPU资源**，通常是时间片用完等待分配下一个时间片

> **最多n-1个**处于就绪态

**阻塞态**：**等待某个资源或事件**，等到后进入就绪态

> 可能死锁，**所有进程都阻塞**

**创建态**：正在被创建，**未进入就绪态**

**终止态**：**先切换为终止态，再回收资源**

> 进程的**生命周期不是连续**的，因为可能被**阻塞或抢占**

#### 状态的转换

**运行态->就绪态**：**时间片**用完

**就绪态->运行态**：获得**时间片**

**运行态->阻塞态**：请求某一**资源**，或等待某一**事件**（**进程主动**进行的转换）

**阻塞态->就绪态**：**资源**或**事件**来了

<img src="408.assets/image-20250805212617883.png" alt="image-20250805212617883" style="zoom:80%;" />

#### 进程状态的原语

> **进程创建的原因**：
>
> 1. 用户**登录**
> 2. 高级**调度**
> 3. 系统**处理用户程序的请求**
> 4. 用户程序的**应用请求**
>
> 比如设备分配就不会创建进程

**进程的创建**：

|      |               关键操作                |       资源管理       |                 失败处理                 |
| :--: | :-----------------------------------: | :------------------: | :--------------------------------------: |
|  1   |   分配唯一**PID**，申请**空白PCB**    |     PCB数量有限      |          申请失败则直接创建失败          |
|  2   | **分配资源**（内存/文件/I/O/CPU时间） | 资源可来自OS或父进程 | **资源不足**时进入**创建态**（等待资源） |
|  3   |             **初始化PCB**             |    写入PCB结构体     |                    —                     |
|  4   |           **插入就绪队列**            |     队列容量限制     |             队列满则暂缓插入             |

**进程的终止**：

|      |                           关键操作                           |      资源处理       |               特殊情形                |
| :--: | :----------------------------------------------------------: | :-----------------: | :-----------------------------------: |
|  1   |               **通过PID检索PCB**，读取进程状态               |          —          |           若PCB不存在则报错           |
|  2   |               立即**终止运行态进程，释放CPU**                | CPU转给其他就绪进程 | 非运行态（阻塞/就绪）直接进入回收流程 |
|  3   | 递归终止所有子孙进程（可选，**进程终止，不一定终止其子进程**） |   取决于系统设计    |         部分系统允许孤儿进程          |
|  4   |  **释放资源**： • 内存 • **文件句柄(资源访问符)** • I/O设备  |   归还父进程或OS    |      资源泄漏会导致系统性能下降       |
|  5   |                     从进程队列中删除PCB                      |  **PCB放回空闲池**  |   必须保证原子操作（避免链表断裂）    |

**进程的阻塞**：

|      |               关键操作               |       状态变化       |        资源处理         |
| :--: | :----------------------------------: | :------------------: | :---------------------: |
|  1   |          **通过PID定位PCB**          |          —           |    若PCB不存在则报错    |
|  2   | **保护运行态进程的现场，转为阻塞态** |   运行态 → 阻塞态    |       立即释放CPU       |
|  3   |         **插入事件等待队列**         | 加入特定资源等待队列 | CPU转给就绪队列队首进程 |

**进程的唤醒**：

|      |               关键操作                |    状态变化     |           队列操作           |
| :--: | :-----------------------------------: | :-------------: | :--------------------------: |
|  1   | 在**事件等待队列中定位目标进程的PCB** |        —        |  遍历队列（如I/O完成队列）   |
|  2   |  移出等待队列并**修改状态为就绪态**   | 阻塞态 → 就绪态 |      从等待队列删除节点      |
|  3   |         **插入就绪队列尾部**          |   等待CPU调度   | 维护就绪队列优先级（若适用） |

### 3.进程的高级通信

|     通信方式     |                      实现原理                      |                 特点                 |
| :--------------: | :------------------------------------------------: | :----------------------------------: |
|   **共享存储**   |              映射**同一物理内存区域**              |             速度**最快**             |
|   **消息传递**   | **直接传递**，或通过**信箱(消息队列**)**间接传递** | **发送原语和接收原语**，**间接通信** |
|  **管道(Pipe)**  | 内核缓冲区的**单向**字节流(**生产者-消费者方式**)  |           **管道大小有限**           |
| **信号(Signal)** |       **内核给进程**发，或者**进程给进程**发       |    从**内核态切换到用户态**时检查    |

各**进程的地址空间是私有**的，**不能通过访问对方的地址空间**达成**通信**

> **共享文件可以实现进程间通信**，原理是多个进程读写同一个文件交换数据

### 4.线程

> **引入进程的目的**：**更好的实现多道程序的并发**
>
> **引入线程的目的**：**减少并发过程的开销**

**进程中有很多个线程**，线程是系统**独立调度和分派的基本单位**

进程内的线程都拥有**进程的所有资源**

一个**程序**可由**多个线程同时执行**

#### 线程vs进程

|               |                   线程                   |                进程                 |
| :-----------: | :--------------------------------------: | :---------------------------------: |
|   **开销**    |              切换**开销低**              |        上下文切换**开销大**         |
|  **并发性**   |      **进程内/跨进程**线程均可并发       |          仅**进程间**并发           |
| **资源拥有**  | **栈(线程间不可共享)**，**共享进程资源** | 拥有**独立地址空间**、I/O等全部资源 |
|  **独立性**   |        **同一进程内线程资源共享**        |  进程**不可访问其它进程地址空间**   |
| **多CPU支持** |      **多线程可分配到多个CPU并行**       |    **单线程进程只能在单CPU运行**    |

#### 线程的状态

执行态

就绪态

阻塞态

#### 线程的创建和终止

创建：有一个初始化线程的线程，有一个线程创建函数

**终止**：**子进程不一定在线程终止时被终止**，这取决于子线程的类型；**被终止但未释放资源的线程仍可被调用**

#### 用户级线程和内核级线程

|                        |        用户级线程（ULT）         |       内核级线程（KLT）        |
| :--------------------: | :------------------------------: | :----------------------------: |
|   **操作系统可见性**   |          **对内核透明**          |     **内核直接感知**并管理     |
| **进程内线程切换范围** |            **用户态**            |           **内核态**           |
| **进程间线程切换范围** |            **内核态**            |           **内核态**           |
|    **线程切换速度**    |             **极快**             |            **较慢**            |
|       **并发性**       |   **单线程阻塞则整个进程阻塞**   | 一个线程阻塞**不影响其他线程** |
|      **多核利用**      |         **仅能单核运行**         |         可**多核并行**         |
|      **线程管理**      | 由应用程序在**用户态中全部完成** |  由操作系统在**内核态中完成**  |
|      **实现方式**      |     **用户程序**或**线程库**     |        **操作系统创建**        |
|      **调度单位**      |             **进程**             |            **线程**            |

**用户级线程**由**用户程序**或**函数库**实现，**不依赖于操作系统**的支持，在**不同操作系统上可不经修改直接运行**

#### 多线程模型

|            |        线程映射关系         |                      优点                       |                       缺点                        |           适用场景           |
| :--------: | :-------------------------: | :---------------------------------------------: | :-----------------------------------------------: | :--------------------------: |
| **多对一** | 多个用户线程 → 1个内核线程  |     ✅ **切换快**（用户态完成） ✅ 资源消耗低     | ❌ **无法多核并行** ❌ **单线程阻塞则整个进程阻塞** |   高并发I/O（旧版Python）    |
| **一对一** |  1个用户线程 → 1个内核线程  | ✅ 真并发（多核利用） ✅ **抗阻塞**（内核级调度） | ❌ 切换**开销大**（需内核介入） ❌ 线程数受限于内核 | CPU密集型（C++ std::thread） |
| **多对多** | 多个用户线程 → 多个内核线程 |  ✅ 平衡并发与开销 ✅ 灵活调度（用户/内核协作）   |             ❌ 实现复杂（需两级调度）              |   混合负载（Go goroutine）   |

<img src="408.assets/image-20250806222010332.png" alt="image-20250806222010332" style="zoom:80%;" />

### 5.调度

**调度**：**从就绪队列选一个进程到CPU中执行**

> **为什么要调度**：
>
> 如果当前**进程需要等待IO设备**，**CPU可以执行其它进程**，**而不是在这等待IO设备**

#### 三级调度

|   调度级别   | 作用对象  | 状态变换           |               典型策略                |
| :----------: | :-------: | ------------------ | :-----------------------------------: |
| **高级调度** | 作业/程序 | **创建态->就绪态** | 先来先服务（FCFS）、短作业优先（SJF） |
| **中级调度** |   进程    | **阻塞态->就绪态** |   交换（Swapping）、挂起（Suspend）   |
| **低级调度** | 进程/线程 | **就绪态->运行态** |     时间片轮转（RR）、优先级调度      |

<img src="408.assets/image-20250806222531445.png" alt="image-20250806222531445" style="zoom:80%;" />

#### 调度的时机

|              |       具体场景        |                行为特征                |
| :----------: | :-------------------: | :------------------------------------: |
| **主动触发** |    新**进程创建**     |   父/子进程同时就绪，需选择执行顺序    |
|              | 进程正常/**异常终止** |      释放CPU资源，必须选择新进程       |
|              |   进程主动**阻塞**    |       因I/O、信号量等自愿放弃CPU       |
| **被动触发** |    **I/O中断完成**    |   阻塞进程转为就绪，可能抢占当前进程   |
|              |    **时间片耗尽**     |          时钟中断触发强制调度          |
|              | **高优先级进程**就绪  |    实时任务触发抢占（如SCHED_FIFO）    |
| **特殊情形** |    **系统空闲**时     | 运行闲逛进程（如Linux的`swapper`进程） |

> **不能进行调度的情况**：
>
> 1. **中断处理时**
> 	- 原因：无进程上下文，**操作不可分割**
> 	- 表现：内核直接禁止调度（如Linux的`in_interrupt()`检测）
> 2. **原子操作时**
> 	- 原因：需保持**操作完整性**（如锁/内存屏障）
> 	- 实现：`preempt_disable()`+ 关中断

#### 调度的方式

**非抢占调度方式**

**抢占调度方式**

#### 用户级和内核级线程调度

**用户级线程调度**：

1. **内核不知道用户级线程的存在**
2. 选择一个**进程调度**
3. **进程内部自行决定**线程运行顺序
4. 调度**速度快**

**内核级线程调度**

1. **选择一个**特定内核级**线程**运行
2. 调度**速度慢**

#### 调度的性能指标

1. **CPU利用率**：
	$$
	\text{CPU的利用率}=\frac{\text{CPU有效工作时间}}{\text{CPU有效工作时间}+\text{CPU空闲等待时间}}
	$$

2. 系统吞吐量：单位时间内CPU完成作业的数量

3. **周转时间**：**等待时间+运行时间**

4. **带权周转时间**：
	$$
	\text{带权周转时间}=\frac{\text{作业周转时间}}{\text{作业运行时间}}=\frac{\text{作业等待时间+作业运行时间}}{\text{作业运行时间}}
	$$

5. 等待时间

6. 响应时间：用户请求到系统响应的时间\

#### 作业调度和进程调度

|              |                    作业                     |                进程                |
| :----------: | :-----------------------------------------: | :--------------------------------: |
|   **定义**   | 用户提交的一个完整任务单元（如脚本、命令）  |   操作系统分配资源的基本执行实体   |
| **组成结构** | 可能包含多个进程（如管道命令 `ls \| grep`） |         单个程序的执行实例         |
| **生命周期** |          从提交到完成（用户视角）           |      从创建到终止（内核视角）      |
| **管理层次** |   由Shell或作业调度器管理（如`jobs`命令）   |       由操作系统内核直接管理       |
| **控制方式** |     可挂起（`Ctrl+Z`）、后台运行（`&`）     | 通过信号（如`kill`）或系统调用控制 |
| **典型操作** |             `bg`、`fg`、`jobs`              |    `fork()`、`exec()`、`wait()`    |
| **资源分配** |               用户级逻辑分组                |     实际占用CPU/内存等物理资源     |
| **依赖关系** |     可能包含多个协同进程（如编译任务）      |         独立或通过IPC通信          |

**作业调度**：**作业进入内存**的调度，比如有**两道作业的批处理系统**，用户**提交多个作业**，需要**根据作业调度算法决定谁先进入内存**

**进程调度**：进程**获得CPU资源执行**的调度

### 6.上下文切换

**上下文切换**：**切换CPU到另一个进程**需要**保存当前进程状态**并**恢复另一个进程的状态**

**上下文**：所有运行环境，包括程序计数器，寄存器，用户堆栈

#### 流程

1. **保存现场**：挂起当前进程，将**CPU状态（PC+寄存器）存入PCB**
2. **队列迁移**：根据进程状态**将当前进程的PCB移入对应队列（就绪/阻塞等）**
3. **新进程选择**：调度算法**从就绪队列选取**下一个执行进程
4. **恢复现场**：从新进程PCB**加载CPU上下文**（寄存器等）
5. **执行跳转**：根据恢复的**PC指针**开始执行新进程

#### 特点

1. 上下文切换**只能在内核态**
2. 上下文切换**时间消耗巨大**

#### 模式切换vs上下文切换

|              |               模式切换                |         上下文切换          |
| :----------: | :-----------------------------------: | :-------------------------: |
| **本质区别** | **用户态$\leftrightarrow$内核态**转换 |        **进程切换**         |
| **进程变化** |          **不改变当前进程**           |    **必然改变当前进程**     |
| **发生场景** |        **系统调用/中断/异常**         |     调度器**主动触发**      |
| **执行位置** |          **可在用户态发起**           |    **必须在内核态**完成     |
| **开销级别** |     **较低**（仅寄存器部分保存）      | **较高**（完整PCB保存恢复） |
|  **必要性**  |       **单进程也需要模式切换**        |   **多任务系统必需**特性    |

### 7.调度算法

#### 先来先服务 FCFS

first come first service

#### 短作业优先 SJF

short job first

注意：如果**长任务最先来**，此刻**其它短任务还没提交**，那么**只能先运行长任务**，且**不能被抢占**

**饥饿现象**：**长作业长期不被调度**

#### 高响应比优先

$$
\text{响应比}R_\mathrm{p}=\frac{\text{等待时间}+\text{要求服务时间}}{\text{要求服务时间}}
$$

1. 等待时间增加，响应比增加，**克服饥饿现象**
2. 要求服务时间短，响应比高，**有利于短作业**

> **长作业**，占用CPU的时间长，比如**CPU密集型作业**
>
> **短作业**，占用一小会儿CPU就放弃，比如**IO密集型作业**

#### 优先级调度

非抢占式优先级调度：等当前进程执行完

抢占式优先级调度：当前进程直接暂停

**静态优先级**：**优先级不会变**

**动态优先级**：**优先级会变**

> **常见优先级比较**：
>
> 系统进程$>$用户进程
>
> 前台进程$>$后台进程
>
> **IO型进程$>$CPU计算型进程**

#### 时间片轮转 RR

适用于**分时系统(可人机交互)**

1. **时间片过大，退化为FCFS**
2. **时间片过小，CPU频繁调度的开销过大**

时间片一到就**强行释放CPU**，**绝对可被抢占**

#### 多级队列调度

**多个就绪队列**

**每个就绪队列调度算法不同**

#### 多级反馈队列调度

<img src="408.assets/image-20250807134146384.png" alt="image-20250807134146384" style="zoom:80%;" />

1. **多个就绪队列**
2. **第1级队列优先级最高，依次递减**
3. **优先级高的时间片短**
4. 新进程**先进第1级队列**，**没执行完就进入第2级队列末尾**，直到进入第n级队列
5. 按优先级**抢占式调度**，高优先级进程进入，终止当前进程并放入**本行**末尾

**注意**：每次**只选一个队列**中的进程执行，**多个队列不能并行**

<img src="408.assets/image-20250807134530666.png" alt="image-20250807134530666" style="zoom:80%;" />

### 8.同步和互斥

#### 相关概念

**临界资源**：一次**仅允许一个进程访问**，且能被**若干进程共享**

**临界区**：访问临界资源的那段**代码**

**同步**：协调多个线程/进程按**预定顺序**执行，确保数据一致性和操作有序性的机制

> **为什么要同步**：进程具有**异步性**，每次执行的速度不同，为了保持顺序必须同步

**互斥**：一个进程进入临界区，另一个必须等待

**临界区同步准则**：

1. **空闲让进**
2. **忙则等待**
3. **有限等待**
4. **让权等待**：若**不能进入临界区，则释放CPU资源**

#### 临界区互斥方式

**软件实现方法**：用一些flag变量

**Peterson算法**，特点是**谦让**，**不会出现饥饿**

<img src="408.assets/image-20250813131806490.png" alt="image-20250813131806490" style="zoom:80%;" />

> turn=1，让对方可以进入

---

**硬件实现方法**：

1. **关中断**

2. **原子指令TestAndSet(TS)**，同时执行检查和上锁的操作

	```c
	bool TestAndSet(bool* lock) {
	    bool old;
	    old = *lock;	// 检查
	    *lock = true;	// 上锁
	    return old;
	}
	
	while(TestAndSet(&lock));
	lock = false;
	```

3. **Swap指令**，思路和TestAndSet一致，都是将检查和上锁设置为原子操作

	```c
	bool key = true;
	while(key == true)		// 检查
	    Swap(&lock, &key);	// 上锁
	lock = false;
	```

**缺点**：**`while`会一直占用CPU资源，无法实现`让权等待`**

#### 互斥锁

```c
// 获取锁（忙等待）
acquire() {
    while(!available); 		// 自旋等待
    available = false;      // 成功获得锁
}

// 释放锁
release() {
    available = true;       // 释放锁
}
```

必须为原子操作

**缺点**：**循环调用`acquire`，浪费CPU资源**

### 9.信号量

`wait()=P(), signal()=V()`

P、V是一种**低级进程通信原语**

> **原语**通过**屏蔽中断**方式实现

#### 整型信号量

`S`表示临界资源的数量

```c
// 等待资源（P操作）
wait(S) {
    while(S <= 0);  // 资源不足时循环等待
    S = S - 1;      // 占用一个资源
}

// 释放资源（V操作）
signal(S) {
    S = S + 1;      // 释放一个资源
}
```

**缺点**：**用了`while`，依然占用CPU，依然不是`让权等待`**

#### 记录型信号量

**信号量semaphore结构体**：

```c
typedef struct {
    int value;             // 信号量计数器（资源数量）
    struct process *L;     // 等待队列头指针（阻塞的进程链表）
} semaphore;
```

```c
void wait(semaphore S) {      // 相当于申请资源
    S.value--; 
    if(S.value < 0) {	// 减了之后<0，说明之前<=0，用完了
        add this process to S.L;
        block(S.L);	// 运行态->阻塞态
    }
}

void signal(semaphore S) {    // 相当于释放资源
    S.value++; 
    if(S.value <= 0) {	// 加了后仍然<=0，说明没释放时<0
        remove a process P from S.L;
        wakeup(P);	// 阻塞态->就绪态
    }
}
```

#### 信号量实现互斥

```c
semaphore S = 1;  // 初始化信号量，资源为1

// 进程P1
P1() {
    P(S);         // 获取钥匙（若S=0则阻塞）
    [临界区代码]
    V(S);         // 归还钥匙
}

// 进程P2
P2() {
    P(S);
    [临界区代码]
    V(S);
}
```

**有多少临界资源，就设置多少信号量**

#### 信号量实现同步

前提：P2必须在P1之后执行，控制这个同步序列

```c
semaphore S = 0;  // 初始化同步信号量

// 进程P1（生产者）
P1() {
    x;            // 1. 先执行关键操作（如数据准备）
    V(S);         // 2. 释放信号量（通知P2）
}

// 进程P2（消费者）
P2() {
    P(S);         // 3. 等待P1完成（阻塞直到S>0）
    y;            // 4. 执行后续操作（如处理数据）
}
```

#### 信号量实现前驱关系

<img src="408.assets/image-20250807180203192.png" alt="image-20250807180203192" style="zoom:80%;" />

需要：$\mathrm{al2,al3,a24,a25,a36,a46,a56}$ 这些信号量

```c
// 信号量初始化
semaphore a12 = 0;
semaphore a13 = 0;
semaphore a24 = 0;
semaphore a25 = 0;
semaphore a36 = 0;
semaphore a46 = 0;
semaphore a56 = 0;

// 进程S1
S1() {
    /* S1的代码逻辑 */;
    V(a12);  // 通知S2可以运行
    V(a13);  // 通知S3可以运行
}

// 进程S2
S2() {
    P(a12);  // 检查S1是否完成
    /* S2的代码逻辑 */;
    V(a24);  // 通知S4可以运行
    V(a25);  // 通知S5可以运行
}

// 进程S3
S3() {
    P(a13);  // 检查S1是否完成
    /* S3的代码逻辑 */;
    V(a36);  // 通知S6可以运行
}

// 进程S4
S4() {
    P(a24);  // 检查S2是否完成
    /* S4的代码逻辑 */;
    V(a46);  // 通知S6可以运行
}

// 进程S5
S5() {
    P(a25);  // 检查S2是否完成
    /* S5的代码逻辑 */;
    V(a56)  // 通知S6可以运行
}

// 进程S6
S6() {
    P(a36);      // 检查S3是否已经运行完成
    P(a46);      // 检查S4是否已经运行完成
    P(a56);      // 检查S5是否已经运行完成
    /* S6的代码逻辑 */;
}
```

### 10.经典同步互斥问题

#### 生产者-消费者问题

```c
// 信号量定义
semaphore mutex = 1;    // 临界区互斥信号量（二进制信号量）
semaphore empty = n;    // 空闲缓冲区数量（初始为缓冲区总容量）
semaphore full = 0;     // 已占用缓冲区数量（初始为0）

// 生产者进程
producer() {
    while(1) {
        生产一个产品;
        
        P(empty);  // P(empty)必须在P(mutex)之前，否则可能永远不释放P(mutex)
        P(mutex);
        
        将产品放入缓冲区;
        
        V(mutex);
        V(full);
    }
}

// 消费者进程
consumer() {
    while(1) {
        P(full);  // P(full)必须在P(mutex)之前，否则可能永远不释放P(mutex)
        P(mutex);
        
        从缓冲区中取出一个产品;
        
        V(mutex);
        V(empty);
        
        消费产品;
    }
}
```

**P(empty)必须在P(mutex)之前，否则可能永远不释放P(mutex)**

---

<img src="408.assets/image-20250807211020084.png" alt="image-20250807211020084" style="zoom:80%;" />

```c
// 信号量定义
semaphore plate = 1;  // 盘子互斥访问（初始可放入）
semaphore apple = 0;  // 苹果计数（初始无苹果）
semaphore orange = 0; // 橘子计数（初始无橘子）

// 父亲进程（生产苹果）
dad() {
    while(1) {
        准备一个苹果;
        P(plate);          // 申请盘子使用权
        把苹果放入盘子;
        V(apple);          // 通知可消费苹果
    }
}

// 母亲进程（生产橘子）
mom() {
    while(1) {
        准备一个橘子;
        P(plate);          // 申请盘子使用权
        把橘子放入盘子;
        V(orange);         // 通知可消费橘子
    }
}

// 儿子进程（消费橘子）
son() {
    while(1) {
        P(orange);         // 检查是否有橘子
        从盘子中取出橘子;
        V(plate);          // 释放盘子使用权
        吃掉橘子;
    }
}

// 女儿进程（消费苹果）
daughter() {
    while(1) {
        P(apple);          // 检查是否有苹果
        从盘子中取出苹果;
        V(plate);          // 释放盘子使用权
        吃掉苹果;
    }
}
```

#### 读者-写者问题

**读优先**：**只要还有读者在读取，写者就必须无限等待**

```c
int count = 0;          // 当前正在读文件的人数
semaphore mutex = 1;    // 保护count变量的锁
semaphore rw = 1;       // 控制读写权限的锁

// 写者进程（每次只能有一个写者）
writer() {
    while(1) {
        P(rw);          // 写写和读写互斥
        写文件;
        V(rw);
    }
}

// 读者进程（可以多人同时读）
reader() {
    while(1) {
        P(mutex);		// 不能同时修改mutex，否则可能出现ABA错误
        if(count == 0)	// 读读不互斥
            P(rw);      // 读写互斥
        count++;
        V(mutex);
        
        读文件;
        
        P(mutex);
        count--;
        if(count == 0)
            V(rw);
        V(mutex);
    }
}
```

---

**写优先**：**一旦有写者等待，新读者必须等待现有读者完成**

**新增一个信号量**，**锁住新来的读者**

```c
int count = 0; 		// 用于记录当前的读者数量
semaphore mutex = 1; 	// 用于保护更新count变量时的互斥
semaphore rw = 1; 	// 用于保证读者和写者互斥地访问文件
semaphore w = 1; 		// 用于实现“写优先”

//写者进程
writer() { 		
    while(1) { 
        P(w); 		// 在无写进程请求时进入
        P(rw);
        写文件
            V(rw);
        V(w);
    }
}

//读者进程
reader() { 
    while(1) {
        P(w); 			// 在无写进程请求时进入
        P(mutex);
        if(count == 0)
            P(rw); 		// 阻止写进程写
        count++;
        V(mutex);
        V(w);			// 在此处释放，不阻止其它读者，并允许写进程拿到

        读文件

            P(mutex);
        count--;
        if(count == 0)
            V(rw);
        V(mutex);
    }
}
```

#### 哲学家进餐问题

**一次性取两双筷子，防止所有人都拿到一根筷子**

```c
semaphore chopstick[5] = {1, 1, 1, 1, 1};  // 初始化信号量
semaphore mutex = 1;                       // 设置取筷子的信号量

// i号哲学家的进程
Pi() {                                     
  do {
    P(mutex);                              // 一次性取两双筷子，防止所有人都拿到一根筷子
    P(chopstick[i]);                       // 取左边筷子
    P(chopstick[(i + 1) % 5]);             // 取右边筷子
    V(mutex);
    
    进餐
    
    V(chopstick[i]);                       // 放回左边筷子
    V(chopstick[(i + 1) % 5]);             // 放回右边筷子
    
    思考
  } while (1);
}
```

**限制死锁方式**：**让最多n-1个哲学家进餐**，比如只给他们n-1个座位，n-1个碗，这样就**可以不用`mutex`**

```c
semaphore bowl;          
semaphore chopsticks[n]; 
for(int i=0; i<n; i++)
    chopsticks[i] = 1;   

bowl = min(n-1, m);      // 限制碗的数量（bowl ≤ n-1，避免死锁）

CoBegin
while(TRUE) {          
    思考;               
    P(bowl);             // 申请碗（同步）
    P(chopsticks[i]);   
    P(chopsticks[(i+1)%n]); 
    就餐;                
    V(chopsticks[i]);    
    V(chopsticks[(i+1)%n]); 
    V(bowl);             // 释放碗
}
CoEnd
```

### 11.管程

#### 管程的特点

1. 管程=把控制**并发进程执行的一组操作**封装到**数据结构**
2. 每次**仅允许一个进程进入管程**

#### 条件变量

`x.wait`：阻塞当前进程，**释放管程**

`x.signal`：唤醒**一个**进程

**条件变量没有值**，只能实现排队之类的功能

### 12.死锁

**死锁**：**多个进程互相持有对方所需资源且不释放，导致所有进程无限等待**

#### 死锁vs饥饿

|                  |             死锁             |                饥饿                |
| :--------------: | :--------------------------: | :--------------------------------: |
|     **定义**     | **多个进程互相等待对方资源** |     **某个进程长期得不到资源**     |
|     **原因**     |     循环等待 + 资源互占      | 资源分配策略不公平（如优先级反转） |
|     **状态**     |  所有相关进程 **完全阻塞**   |     受害进程 **可能偶尔推进**      |
|   **解决重点**   | 打破循环等待（如银行家算法） |      公平调度（如时间片轮转）      |
| **是否可自恢复** |        ❌ 必须外力干预        |        ✅ 可能随调度自动缓解        |

#### 死锁产生原因

1. 对**不可剥夺资源的争夺**
2. 进程的**推进顺序有误**

#### 死锁的必要条件

1. **互斥**条件：临界资源
2. **不可剥夺**条件：资源不能被夺走
3. **请求并保存**条件：**阻塞时不释放资源**
4. **循环等待**条件：循环等待链

#### 死锁预防

> **死锁预防、死锁避免、死锁检测和解除**三种方法**从严到宽**

|      破坏      |               破坏方法               |                   具体措施示例                   |
| :------------: | :----------------------------------: | :----------------------------------------------: |
|    **互斥**    |           允许**资源共享**           | 使用只读资源（如常量）、SPOOLing技术（打印机池） |
|  **不可剥夺**  |         允许**强制回收**资源         |      超时机制（如数据库死锁检测后回滚事务）      |
| **请求并保存** | **一次性申请**所有资源(**静态分配**) |           进程启动前预分配全部所需资源           |
|  **循环等待**  |          **按顺序**申请资源          |      全局资源排序（如必须先申请A才能申请B）      |

#### 死锁避免

**安全序列**：按照某一个序列给予资源，并回收资源，可以让所有进程完成

**不安全情况**：**剩下的资源+可以被回收的资源**仍**无法满足**剩余进程的需求

#### 银行家算法

1. 可利用资源向量：所有资源
2. 最大需求矩阵：最大需求
3. 分配矩阵：已分配
4. 需求矩阵：还需的

画出上述矩阵，然后找安全序列

#### 死锁检测和解除

**死锁检测**：**资源分配图**，**死锁定理**

1. **申请边**：**指向资源**的有向边
2. **分配边**：**指向进程**的有向边
3. 矩形框内是资源，圆点表示资源
4. 圆圈表示进程

![image-20250813214936190](408.assets/image-20250813214936190.png)

---

**死锁解除**：

1. **资源剥夺**法
2. **撤销进程**法
3. **进程回退**法：回退到没有死锁的阶段



## 第3章：内存管理

### 1.内存管理的概念

**逻辑地址**=相对地址，程序运行时生成的地址

**物理地址**=绝对地址，内存物理单元的集合

**不同进程可以有相同的逻辑地址**，因为这些**逻辑地址可以映射到内存的不同位置**

---

**静态重定位**：地址转换一次完成

**动态重定位**：相对地址需要**加一个**重定位寄存器

|                     | 静态重定位        | 动态重定位                    |
| ------------------- | ----------------- | ----------------------------- |
| 硬件地址变换机构MMU | 无                | 有                            |
| 重定位寄存器        | 无                | 有                            |
| 分配方式            | **单一+固定分区** | **动态分区+页式+段式+段页式** |
| 时机                | **装入**内存时    | **执行**过程中                |

<img src="408.assets/image-20250808171145195.png" alt="image-20250808171145195" style="zoom:80%;" />

---

**静态链接**：**先链接**再装入

**装入时动态链接**：**边装入边链接**

**运行时动态链接**：**需要用到**目标模块时，才链接

### 2.内存映像

| 节（Section） |                             解释                             |
| :-----------: | :----------------------------------------------------------: |
|  **共享库**   |     **动态链接库**（如 `.so`或 `.dll`），在运行时被加载      |
|   **.init**   | 包含程序的**初始化代码**（如 `_start`入口），在 `main()`函数前执行，由系统调用启动 |
|   **.text**   | 存放程序的**可执行代码**（机器指令），通常是只读的，避免被意外修改 |
|  **.rodata**  | 存储**只读数据**（如**字符串常量、全局常量**），与 `.text`类似但仅包含数据而非指令 |
|   **.data**   |   存储**已初始化的全局变量和静态变量**（如 `int x = 5;`）    |
|   **.bss**    |     存储**未初始化的全局变量和静态变量**（如 `int y;`）      |

<img src="408.assets/image-20250808171925756.png" alt="image-20250808171925756" style="zoom:80%;" />

### 3.内存保护

1. **上下限寄存器**：访问地址时比较，防止越界

2. **重定位寄存器(基址寄存器)+界地址寄存器(限长寄存器)**：

	1. **比较界地址寄存器**中的值与逻辑地址的值来判断**是否越界**
	2. 逻辑地址**加上重定位寄存器**中的值就能得到**物理地址**
	
	<img src="408.assets/image-20250808172431714.png" alt="image-20250808172431714" style="zoom:80%;" />

### 4.内存共享

**只有只读的区域才能共享**

### 5.连续分配管理方式

#### 单一连续分配

**把内存全给一个用户程序**

#### 固定分区分配

分成**多种大小固定的分区**，**每个分区一个程序**

多个小分区，少量大分区

**分区使用表**：

<img src="408.assets/image-20250808175124998.png" alt="image-20250808175124998" style="zoom:80%;" />

**内部碎片**(**分区内部**)：小进程放入大分区

#### 动态分区分配

**作业装入内存时**动态分配分区，使**分区大小刚好等于进程大小**

缺点：**外部碎片较多**

**外部碎片(分区之间)**：几个分区之间的碎片

<img src="408.assets/image-20250808180404757.png" alt="image-20250808180404757" style="zoom:80%;" />

#### 动态分区回收算法

**空闲分区链(表)**

一句话：**回收区周围有其它空闲块，则合并**；否则直接加入空闲分区链(表)

### 6.动态分区分配算法

#### 首次适应法 First Fit

**每次都**从空闲分区链的**头部开始顺序查找**，选择**第一个**能满足请求大小的空闲分区进行分配

> 会产生**大量内部碎片**

#### 邻近适应法 Next Fit

从**上次分配结束的位置**开始顺序查找（**而非从头开始**），选择**第一个**能满足请求大小的空闲分区进行分配

#### 最佳适应法 Best Fit

选择**能满足请求大小的最小空闲分区(一般先从小到大排序)**进行分配，以减少内存浪费

#### 最坏适应法 Worst Fit

选择**能满足请求大小的最大空闲分区(最大分配完，会剩下小的空闲块)**进行分配，以减少小碎片的产生

#### 伙伴系统

所有**分区都是2的幂次**，若需要$2^i$，**$2^i$用完，则到$2^{i+1}$里找，并把其分为两份**，一份用于分配，一份存到$2^i$

**回收**时，把**相邻的伙伴分区**合并为**更大的分区**

### 7.页式存储管理

> **每个进程一个页表，页面驻留在内存中**

逻辑页面：页面

**物理页面：页框**

**页表**：

<img src="408.assets/image-20250808221643294.png" alt="image-20250808221643294" style="zoom:80%;" />

**有内部碎片、无外部碎片**

#### 逻辑地址结构

低12位页内地址(**每页一般4KB**)：

<img src="408.assets/image-20250808221517386.png" alt="image-20250808221517386" style="zoom:80%;" />

#### 地址转换过程

<img src="408.assets/image-20250808221723901.png" alt="image-20250808221723901" style="zoom:80%;" />

**逻辑页号=逻辑地址/页面大小，向下取整**

> **逻辑页号不一定等于物理页号**
>
> <img src="408.assets/image-20250814211650182.png" alt="image-20250814211650182" style="zoom:80%;" />
>
> <img src="408.assets/image-20250814211714056.png" alt="image-20250814211714056" style="zoom:80%;" />

#### 快表

**快表在CPU内部**

|      组件       |       位置       |    速度     |            用途             |
| :-------------: | :--------------: | :---------: | :-------------------------: |
| **TLB（快表）** |     CPU内部      |   1~3周期   |  加速虚拟地址→物理地址转换  |
|  **CPU Cache**  |     CPU内部      |  1~10周期   |      缓存常用数据/指令      |
| **内存（RAM）** | 主板上的独立模块 | 100~300周期 |   存储运行中的程序和数据    |
|    **页表**     |    内存/磁盘     |  100+周期   | 记录完整的虚拟-物理地址映射 |

**不用快表，2次访存**(查页表+访问物理地址)

**用快表，1次访存**(只需访问物理地址)

<img src="408.assets/image-20250808222642866.png" alt="image-20250808222642866" style="zoom:80%;" />

#### 两级页表

> **左边的是一级页表，右边的页表**

<img src="408.assets/image-20250808223549849.png" alt="image-20250808223549849" style="zoom:80%;" />

<img src="408.assets/image-20250808223904133.png" alt="image-20250808223904133" style="zoom:80%;" />

3次访存

**一级页表=页目录表=外层页表**

**页目录基址寄存器**：存放**一级页表**的**起始物理地址**

### 8.段式存储管理

段**大小不等**

段内连续，**段间不用连续**

**有外部碎片、无内部碎片**

> **分段由用户编程决定**，对低级语言程序员和编译器**可见**

#### 逻辑地址结构

<img src="408.assets/image-20250808225517569.png" alt="image-20250808225517569" style="zoom:80%;" />

#### 段表项结构

<img src="408.assets/image-20250808230022075.png" alt="image-20250808230022075" style="zoom:80%;" />

<img src="408.assets/image-20250808230132826.png" alt="image-20250808230132826" style="zoom:80%;" />

**段长的位数**和逻辑地址的**段内偏移量位数**相同

**基址的位数**和**物理地址的位数**相同

#### 地址转换过程

<img src="408.assets/image-20250808230859674.png" alt="image-20250808230859674" style="zoom:80%;" />

#### 段的共享

**共享段表**：

| 段号 | 段长 | 段基址 | 存在位 | 共享进程计数count |
| ---- | ---- | ------ | ------ | ----------------- |

**count=0时，才能回收共享段**

#### 段的保护

**段号<=段表项数**

**段内偏移<=段长**

### 9.段页式存储管理

> **分段管理用户空间，分页表示物理空间**

**逻辑地址**：

<img src="408.assets/image-20250808231628759.png" alt="image-20250808231628759" style="zoom:80%;" />

**内存分为很多段，每一段有很多页，每一段有一个页表**

<img src="408.assets/image-20250808231757262.png" alt="image-20250808231757262" style="zoom:80%;" />

**3次访存**

<img src="408.assets/image-20250808231851126.png" alt="image-20250808231851126" style="zoom:80%;" />

### 10.虚拟内存

**对物理内存逻辑上的扩充**(通过页面交换，让用户感觉自己操纵的空间很大)

**虚拟地址**：**程序访问内存**时使用的地址

使用技术：**请求**页式管理、**请求**段式管理，需要从内存置换，必须用**请求技术**

1. 多次性：页面无法一次装入内存
2. 对换性：页面交换
3. 虚拟性：通过页面交换，让用户感觉自己用了一个很大的存储器

#### 页表项

<img src="408.assets/image-20250809125738936.png" alt="image-20250809125738936" style="zoom:80%;" />

|     名称     |                           作用说明                           |
| :----------: | :----------------------------------------------------------: |
|  **状态位**  |       标记该页**是否已调入内存**（1=在内存，0=在外存）       |
| **访问字段** | 记录**页面被访问次数**或最近未访问时长，供页面置换算法（如**LRU**） |
|  **修改位**  | 标记页面**调入内存后是否被修改**（1=已修改，0=未修改），决定换出时是否需要写回外存 |
|   外存地址   | 记录该页在**外存中的存放地址（如物理块号）**，当需要调入内存时快速定位 |

#### 缺页中断

1. **缺页进程进入阻塞队列**，调页完成后**唤醒，加入就绪队列**
2. 内存有空闲页框，则分配一个
3. 内存没有空闲页框，则页面置换算法

缺页中断是**内部异常**，属于**故障**(Fault)

**缺页中断处理过程**：

1. 查询页表找到该页的物理块
2. 内存未满，调入内存，修改页表
3. 内存已满，页面置换算法，置换页修改位为1，则写回磁盘
4. 修改新页的存在位为1

#### 磁盘交换区/页缓冲队列

被**换下的页面**，**一起写回磁盘**

#### 地址变换过程

**页表项数目=虚拟页数目**，物理页数目可小于虚拟页数目，因为多个虚拟页可映射同一个物理页

<img src="408.assets/image-20250809131729799.png" alt="image-20250809131729799" style="zoom:80%;" />

#### 内存分配策略

|       策略类型       |         物理块分配         |        置换范围        |
| :------------------: | :------------------------: | :--------------------: |
| **固定分配局部置换** |   **固定数量，不可调整**   |   仅限当前进程的页面   |
| **可变分配全局置换** |        **动态增减**        | **全局所有进程**的页面 |
| **可变分配局部置换** | **动态调整**（基于缺页率） |   仅限当前进程的页面   |

**全局置换**意味着一个进程拥有的物理块数量必然会变，因此**不可能与固定分配组合**

#### 内存映射文件

**内存映射文件**：将**文件直接映射到进程虚拟内存**，通过指针访问文件内容，减少系统调用和数据拷贝，提升大文件读写性能

**可读可写**

支持**多个进程映射同一文件**(如下图两个进程映射同一文件)

<img src="408.assets/image-20250809163419807.png" alt="image-20250809163419807" style="zoom:80%;" />

### 11.页面置换算法

**引用串**：引用串由一系列**虚拟页号**构成，表示进程对内存页面的**访问顺序**

比如 `1, 2, 3, 1, 4, 2, 5, 1, 2, 3, 4`

#### 最佳置换 OPT

**淘汰最远的页(最长不使用)**

<img src="408.assets/image-20250809160836555.png" alt="image-20250809160836555" style="zoom:80%;" />

#### 先进先出 FIFO

**抖动**

**Belady**

<img src="408.assets/image-20250809160908175.png" alt="image-20250809160908175" style="zoom:80%;" />

#### LRU

**抖动**

**最近最久未被使用**

<img src="408.assets/image-20250809161000862.png" alt="image-20250809161000862" style="zoom:80%;" />

#### 时钟置换法 CLOCK

**抖动**

页面**装入**和**被访问**，访问位=1

1. **访问位=1，减为0**
2. **访问位=0，移除**

**新页装入，指针指向新页的下一个**

#### 改进型 CLOCK

**抖动**

由于**修改过的页写回代价大**，因此**额外考虑修改位**

| 访问位(A) | 修改位(M) | 淘汰优先级 |              页面状态描述               |
| :-------: | :-------: | :--------: | :-------------------------------------: |
|     0     |     0     |    最高    | 最近未被访问且未修改，置换无额外I/O开销 |
|     0     |     1     |    次高    |    最近未被访问但已修改，需写回磁盘     |
|     1     |     0     |    较低    |   最近被访问但未修改，可能再次被访问    |
|     1     |     1     |    最低    |   最近被访问且已修改，可能再次被访问    |

- **第1轮扫描**：查找 **A=0且M=0（1类）** 的页面，找到立即置换。
- **第2轮扫描**：若未找到1类，查找 **A=0且M=1（2类）**，置换前将脏页写回磁盘。
- **第3轮扫描**：若仍无候选，将扫描到的页面 **A位清零**（降级为1/2类），继续下一轮扫描。

#### 页框缓存算法

在页面置换算法基础上增设**两个链表**：

- **空闲页面链表**：缓存**未修改的换出页框**，**供复用**（**避免重复读盘**）
- **修改页面链表**：暂存**脏页**，**批量写回磁盘**（**减少I/O次数**）

### 12.地址翻译

**非常重要**

<img src="408.assets/image-20250809164728007.png" alt="image-20250809164728007" style="zoom:80%;" />

**地址结构**：

<img src="408.assets/image-20250809164750354.png" alt="image-20250809164750354" style="zoom:80%;" />

> **地址结构计算方法**：
>
> 1. 页面大小64B，需要6位作为页内地址
> 2. TLB有4组，组索引2位，虚拟地址剩余6位作为tag
> 3. Cache数据部分4B，需要2位作为偏移量；16行，4位作为索引，剩余6位作为tag

<img src="408.assets/image-20250809165114320.png" alt="image-20250809165114320" style="zoom:80%;" />

<img src="408.assets/image-20250809165124814.png" alt="image-20250809165124814" style="zoom:80%;" />

可得前两个的物理地址，第三个缺页

<img src="408.assets/image-20250809165246774.png" alt="image-20250809165246774" style="zoom:80%;" />

这两个物理地址Cache中均有缓存，不需要访存



## 第4章：文件管理

### 1.文件的概念

**文件控制块(FCB)**：FCB的集合是**文件目录**，一个FCB就是一个**文件目录项**

每个**目录项**仅由**文件名**和**索引节点号**组成

索引节点里面存FCB的非文件名字段以及一些额外字段(比如访问人数)

### 2.文件的打开

|         项目         |                             说明                             |
| :------------------: | :----------------------------------------------------------: |
| **为什么要打开文件** | **避免每次操作都从磁盘找文件**，**首次打开时把文件信息加载到内存** |
| **文件描述符/句柄**  | 相当于**文件的“临时编号”**，打开后所有操作都用这个编号，**不用反复查文件名**（UNIX叫描述符，Windows叫句柄） |
|   **两级表格管理**   | - **系统级表**：存文件的基础信息（如**存在磁盘哪里、大小**）；- **进程级表**：存进程自己的使用信息（如**读到哪了、权限**） |
|  **多进程共享文件**  | **多个进程打开同一文件，系统表里只存一份信息**，但**每个进程有自己的读写指针和权限** |
|  **关闭文件的作用**  | 删除进程自己的记录，系统表里的**“打开次数”减1**；如果**没人用了，就删除文件** |
|  **文件操作四件套**  | `open()`→拿编号→`read()`/`write()`→`close()`（**全程用文件描述符，不用文件名**） |

**打开文件表**：维护所有打开文件，每一行包括：

1. **读写指针位置**
2. **打开次数**
3. 文件的**磁盘位置**
4. **访问权限**

**文件描述符**：文件在**打开文件表中的索引号**

### 3.文件的逻辑结构

文件的**逻辑结构**是指文件**在文件系统中的存在形式**，是**用户看到的文件形式**

#### 无结构文件

**字符流**组成，流式文件，比如**源程序、可执行文件都属于无结构文件**

#### 有结构文件

> 数据项：字段的值
>
> **记录：一行数据项**，类比于数据库的一行

文件由**一堆记录**组成，**记录可定长或不定长**

**下面的均为有结构文件**

#### 顺序文件

**记录顺序排列**

比如只有顺序文件才能存储**磁带**

#### 索引文件

在顺序文件的基础上，建立索引表，**每个记录一个表项**

**表项**是文件中一个**记录的指针**和**长度**

**索引表**本身是**顺序定长结构**

<img src="408.assets/image-20250809213840923.png" alt="image-20250809213840923" style="zoom:80%;" />

#### 索引顺序文件

一个**文件=很多记录**

把**记录分为几组**

建立**一个索引表**，**每组第一个记录有一个索引表项**

**组与组之间必须有序**

<img src="408.assets/image-20250809214519299.png" alt="image-20250809214519299" style="zoom:80%;" />

查找时**先找记录所在的组，然后组内顺序查找**，**类似于B+树**

#### 散列文件

**key=文件描述符，H(key)=物理地址**

### 4.文件的物理结构

文件的**物理结构**是文件在**磁盘等物理介质**上的存储方式

**文件在磁盘中，按磁盘块分割**

#### 连续分配

文件在**磁盘上占有一组连续的块**

**目录项**是`start`和`length`

<img src="408.assets/image-20250809221802757.png" alt="image-20250809221802757" style="zoom:80%;" />

> 左边的图是文件的物理结构，右边的图是逻辑结构

1. **顺序访问和随机访问**
2. 连续分配产生**外部碎片**
3. 必须事先知道文件长度，文件长度不可动态增加

#### 隐式链接分配

**目录项**是**第一块和最后一块的指针**

<img src="408.assets/image-20250809222052236.png" alt="image-20250809222052236" style="zoom:80%;" />

> 左边的图是文件的物理结构，右边的图是逻辑结构

**只能顺序访问**

#### 簇

将**几个磁盘块组成一个簇**，比如**一簇为4块**

目的：**减少指针数量**，**提高查找速度**

#### 显式链接分配

将隐式链接的**所有指针**存放在一个**FAT(文件分配表)中**

<img src="408.assets/image-20250809223029830.png" alt="image-20250809223029830" style="zoom:80%;" />

> 图中的-2表示空闲块，-1表示文件最后一块

1. **顺序访问**和**随机访问**(访问第i块无需访问其前面的)
2. **FAT在内存中**，可减少磁盘访问次数

#### 单级索引分配

**索引块**中**有文件所有的盘块号**

这样**索引表项**只需**这一个索引块的编号即可**

> **一个文件的所有盘块号放到一个块中**：
>
> <img src="408.assets/image-20250809224841178.png" alt="image-20250809224841178" style="zoom:80%;" />

<img src="408.assets/image-20250809224601918.png" alt="image-20250809224601918" style="zoom:80%;" />

#### 多级索引分配

<img src="408.assets/image-20250809224632567.png" alt="image-20250809224632567" style="zoom:80%;" />

> ![image-20250809224656912](408.assets/image-20250809224656912.png)

#### 混合索引分配

<img src="408.assets/image-20250809225105787.png" alt="image-20250809225105787" style="zoom:80%;" />

**直接块**：4KB

**一级间址**：文件大小=1K(一个盘块装1K个盘块号)\*4KB

更高级的同理

#### 三种分配的比较

<img src="408.assets/image-20250810175218403.png" alt="image-20250810175218403" style="zoom:80%;" />

### 5.逻辑块号->物理块号映射

**逻辑偏移量 → 物理块号转换**：

- **计算逻辑块号**：
	- 假设磁盘块大小为4KB，用户要读取第100~200字节：
		- 逻辑块号 = 逻辑偏移量 / 块大小 = 100 / 4096 = **块0**。
		- 块内偏移 = 100 % 4096 = 100。
- **查找物理块号**：
	- **连续分配**：物理块号 = 起始块号 + 逻辑块号（需文件连续存储）。
	- **链式分配**：遍历FAT表或指针链，找到第N个逻辑块对应的物理块。
	- **索引分配（inode）**：
		- 若逻辑块号 < 12：直接读取inode中的块地址。
		- 若逻辑块号 ≥ 12：通过一级/二级间接块索引查找。

### 6.文件保护

**访问控制表(ACL)**：就是Linux中的`-rwxr-x---`

<img src="408.assets/image-20250809230509296.png" alt="image-20250809230509296" style="zoom:80%;" />

|  权限角色  |                通俗解释                |          典型例子          |
| :--------: | :------------------------------------: | :------------------------: |
| **拥有者** |      "文件的主人"（通常是创建者）      |   你创建的文档，你说了算   |
|   **组**   | "文件主人的同事圈"（共享权限的一群人） | 项目组成员都能修改项目文档 |
| **其他人** | "无关群众"（既不是主人，也不在同事圈） |  其他部门的人只能看不能改  |

### 7.目录结构

目录管理的目的：实现**按名存取**

#### 单级目录结构

整个系统**只有一张目录表**

<img src="408.assets/image-20250810113157209.png" alt="image-20250810113157209" style="zoom:80%;" />

**不适用于多用户系统**

#### 两级目录结构

主文件目录：存用户名

用户文件目录：每个用户的文件

<img src="408.assets/image-20250810113344335.png" alt="image-20250810113344335" style="zoom:80%;" />

#### 树形目录结构

用**路径名标识文件**

<img src="408.assets/image-20250810114527013.png" alt="image-20250810114527013" style="zoom:80%;" />

需要按路径**逐级访问中间节点**，**增加了访盘次数**

**UNIX、Linux、Windows**

#### 无环图目录结构

目录是一个**有向无环图**

一个**文件或目录**可被**多个目录共享**

<img src="408.assets/image-20250810120029166.png" alt="image-20250810120029166" style="zoom:80%;" />

每个共享节点一个**共享计数器**

### 8.文件共享

#### 硬链接

**目录项**里面只有**文件名**和指向**索引节点的指针**

**索引节点**有**链接计数count**，**物理地址指针**

<img src="408.assets/image-20250810121640569.png" alt="image-20250810121640569" style="zoom:80%;" />

此时**用户A不能删除文件，只能使count减1**

**count减为0时才能删除文件**

<img src="408.assets/image-20250810122153789.png" alt="image-20250810122153789" style="zoom:80%;" />

#### 软链接

B要共享F时，系统**创建链接文件L**，L写入B的目录项

**L中只有F的路径**

<img src="408.assets/image-20250810123102639.png" alt="image-20250810123102639" style="zoom:80%;" />

**只有文件主有指向文件F的索引节点**，因此**可以直接删除文件F**；B用户只会访问F失败，而**不会有悬空指针**

**软链接需要多访问一个链接文件**，即**多一次访盘**，因此**速度不如硬链接**

### 9.文件系统

#### 层次结构

<img src="408.assets/image-20250810161320690.png" alt="image-20250810161320690" style="zoom:80%;" />

|     层次结构     |            核心功能            |
| :--------------: | :----------------------------: |
|  **I/O控制层**   |  设备驱动、数据传输、硬件控制  |
| **基本文件系统** |   磁盘命令、缓存管理、块操作   |
| **文件组织模块** |   逻辑/物理块映射、空间分配    |
| **逻辑文件系统** | 元数据管理、目录结构、文件权限 |

#### 磁盘布局

磁盘划分为**多个分区**

<img src="408.assets/image-20250810161856947.png" alt="image-20250810161856947" style="zoom:80%;" />

|     磁盘分区组成元素      |                   核心功能                    |
| :-----------------------: | :-------------------------------------------: |
|   **主引导记录（MBR）**   | 位于**磁盘0扇区**，**读取**活动分区**引导块** |
| **引导块（Boot Block）**  |  **启动**分区操作系统，Windows称分区引导扇区  |
| **超级块（Super Block）** |  存储文件系统关键信息（**块数量、大小**等）   |
|      **空闲块管理**       |   用**位示图**或**指针链接**记录**空闲块**    |
|    **i节点（inode）**     |      存储文件元数据（**权限、位置**等）       |
|        **根目录**         |           文件系统目录树的**起点**            |
|     **其他目录/文件**     |               存储实际数据内容                |

### 10.文件存储空间管理

#### 空闲表法

类似于内存的固定分区分配

一个**空闲分区**由**几个连续空闲盘块**组成

所有空闲区建立一个**空闲表**，每个**表项**代表**一个空闲分区**

<img src="408.assets/image-20250810163518089.png" alt="image-20250810163518089" style="zoom:80%;" />

#### 空闲链表法

**空闲盘块链**：**以盘块为单位**拉成一条链，分配过程简单但是时间长

**空闲盘区链**：**以分区为单位**拉成一条链，分配过程复杂但是时间短

#### 位示图法

**每个盘块一个比特位**表示，0空闲，1已分配

#### 成组链表法

每组的**第一个盘块**记录**下一组的块数和块号**

末组标记：首块号为 **“0”**

**分配**：

1. **从栈顶(栈顶在下面)分配**：
	- 直接取**栈顶盘块号**分配给用户，**栈指针上移，空闲数减1**
2. **栈底处理**（若分配的是索引块）：
	- 将该索引块内容（下一组块号）读入栈，替换原栈内容
	- 原索引块本身被分配出去（如**分配300号块时，先将其内容读入栈再分配该块**）

**回收**：

1. **常规回收**：
	- **新回收块号压入栈顶，空闲数加1**
2. **栈满处理**（空闲数=100）：
	- 将栈中100个块号存入新回收块，并将该块号作为新栈底，空闲数重置为1

<img src="408.assets/image-20250810170112248.png" alt="image-20250810170112248" style="zoom:80%;" />

### 11.虚拟文件系统

**四种对象类型**：

|     对象类型     |              核心作用              |
| :--------------: | :--------------------------------: |
|  **超级块对象**  | 代表一个已挂载(安装)的**文件系统** |
| **索引节点对象** |    代表文件系统中的一个**文件**    |
|  **目录项对象**  |      表示一个特定的**目录项**      |
|   **文件对象**   |  表示一个进程相关的**已打开文件**  |



## 第5章：IO管理

### 1.IO设备

|     分类标准     |   设备类型   |                           核心特征                           |           典型示例           |
| :--------------: | :----------: | :----------------------------------------------------------: | :--------------------------: |
| **信息交换单位** |    块设备    |          以**数据块为单位**传输，传输速率高、可寻址          |        **磁盘、磁带**        |
|                  |   字符设备   | 以**字符为单位**传输，传输速率低、不可寻址，通常采用中断I/O方式 |      终端机、**打印机**      |
|   **传输速率**   |   低速设备   |                     每秒几字节至数百字节                     |        **键盘、鼠标**        |
|                  |   中速设备   |                    每秒数千字节至数万字节                    |          激光打印机          |
|                  |   高速设备   |                   每秒数百千字节至千兆字节                   |        **磁盘、光盘**        |
|   **使用特性**   | 人机交互设备 |                     用于用户与计算机交互                     |     键盘、显示器、打印机     |
|                  |   存储设备   |                         用于数据存储                         |       磁盘、磁带、光盘       |
|                  | 网络通信设备 |                       用于计算机间通信                       |       网卡、调制解调器       |
|   **共享属性**   | **独占设备** |         **同一时刻仅允许一个进程占用**（需独占分配）         |          **打印机**          |
|                  | **共享设备** |             **多进程可同时访问**（通过分时共享）             |           **磁盘**           |
|                  | **虚拟设备** |     通过**SPOOLing技术**将**独占设备虚拟为多个逻辑设备**     | **虚拟打印机**（如打印队列） |

### 2.IO接口

**IO接口=设备控制器**

<img src="408.assets/image-20250810180842902.png" alt="image-20250810180842902" style="zoom:80%;" />

|        组成部分        |          核心功能          |                           关键细节                           |
| :--------------------: | :------------------------: | :----------------------------------------------------------: |
| **CPU与控制器的接口**  |    实现CPU与控制器通信     | - 数据线：传输数据/状态信息 - 地址线：选择寄存器 - 控制线：发送读写信号 |
| **控制器与设备的接口** | 连接物理设备（支持多设备） |             每个接口传输数据、控制、状态三种信号             |
|      **I/O逻辑**       |   译码CPU命令并控制设备    |                 解析地址线信号，启动指定设备                 |

### 3.IO端口

**IO端口**=能被CPU直接访问的**寄存器**

IO端口要想能够被CPU访问，就要**对各个端口进行编址**，**每个端口对应一个端口地址**

**独立编址**：IO端口的地址空间与主存地址空间是**两个独立的地址空间**，它们的范围可以重叠

**统一编址**：主存地址空间分出一部分给I/O端口进行编址，I/O端口和主存单元在同一地址空间的不同分段中

### 4.IO控制方式

#### 程序直接控制方式

**轮询**

<img src="408.assets/image-20250810211031786.png" alt="image-20250810211031786" style="zoom:80%;" />

#### 中断驱动方式

<img src="408.assets/image-20250810211055407.png" alt="image-20250810211055407" style="zoom:80%;" />

1. CPU**发出IO读指令后**，保存IO进程的上下文，然后去**处理其它进程**，此时**CPU和IO设备并行工作**
2. 在**每条指令的中断周期**检查IO设备是否发出IO中断
3. 检测到IO中断，**保存当前进程的上下文**，跳转到**中断处理程序**
4. IO设备通过**数据总线**把**读的数据传到CPU**，**然后才**存入主存(**IO设备的数据无法直接送到主存**)
5. **恢复IO进程的上下文**，**继续运行**IO进程

**优点**：不需要轮询，提高CPU利用率

**缺点**：**IO设备无法直接向主存传输数据**，必须以CPU为中介

> 传输的**单位是字节**，效率低

#### DMA方式

**DMA=Direct Memory Access**，**直接存储器存取**

**目的**：**让IO设备能直接向主存传输数据**

**方式**：在**IO设备和主存之间开辟DMA通道**

> 传输的**单位是数据块**，效率高

1. **DMA请求CPU**，获得**总线控制权**
2. **IO设备**通过DMA通道**直接向主存传输数据**
3. 数据传输**结束后，DMA向CPU发一个中断信号**，将**总线控制权还给CPU**

#### 通道控制方式

IO通道是一种**特殊处理机**

通道方式可以实现**CPU、通道、IO设备三者的并行**工作

**DMA**方式需要**CPU来控制传输的数据块大小、传输的内存位置**

而**通道**方式中这些信息是**由通道控制的**

每个**DMA**控制器对应**一台设备与内存传递数据**，而一个**通道**可以控制**多台设备与内存的数据交换**

### 5.IO软件层次结构

<img src="408.assets/image-20250810214751753.png" alt="image-20250810214751753" style="zoom:80%;" />

#### 用户层软件

**作用**：

- 提供**用户程序与IO设备**的友好**接口**（如**库函数**、**系统调用**封装）
- 实现特定设备的逻辑操作（如格式化输入/输出）
- 例子：C语言的`printf()`、Python的`open()`函数

**实例**：

- 当用户程序调用`fprintf(file, "Hello")`时，该层将数据转换为设备可接受的格式（如添加换行符），并通过系统调用（如`write()`）传递给下层

#### 设备独立性软件（设备无关层）

**作用**：

- 屏蔽不同硬件设备的差异，**提供统一的接口(公共操作接口统一，不同物理设备对公共接口有不同的实现，设备独立性软件通过把逻辑设备映射为物理设备，为公共接口找到对应的实现方法)**（如**文件描述符**、**设备名映射**）
- **不同逻辑设备都可以执行相同的公共操作**，但是每种具体的**物理设备对公共操作有不同的实现**
- 可以把逻辑设备理解为接口，物理设备是实现类，设备独立性软件就是把**逻辑设备映射为物理设备**，**为公共操作选取对应的实现方式**
- 处理错误恢复、缓冲管理、设备分配等通用逻辑

**实例**：

- 程序通过`open("/dev/usb1", O_RDWR)`打开USB设备时，该层解析路径名，**确定实际设备类型(逻辑设备->物理设备)**（如打印机或U盘），并**调用对应的驱动程序**，而用户无需关心具体硬件。

#### 设备驱动程序

**作用**：

- 直接控制硬件设备，实现操作系统与设备间的通信
- 将**上层通用指令转换为设备特定的操作指令**（如寄存器读写）

**实例**：

- 当打印文件时，**打印机驱动程序**将**数据转换为打印机识别的指令**（如PostScript或PCL语言），并发送到设备寄存器，触发打印头移动和喷墨

#### 中断处理程序

**作用**：

- **响应硬件中断信号**（如键盘输入完成、磁盘读取就绪），进行最低层的异步事件处理
- 保存现场后通知上层（如唤醒阻塞的进程）

**实例**：

- 键盘按下时，键盘控制器发送中断信号，CPU暂停当前任务，执行中断处理程序读取按键扫描码，并传递给上层驱动进一步处理（如转换为ASCII码）

### 6.设备独立性软件

**设备独立性软件=设备无关软件**

设备独立性软件负责**抽象硬件细节、提供统一接口**

### 7.高速缓存与缓冲区

#### 高速缓存 Disk Cache

**位于内存**，**缓存磁盘中的盘块**

**Disk Cache $\neq$ Cache，前者位于内存，后者位于CPU内部**

#### 缓冲区 Buffer

**目的**：缓解**CPU与IO设备速度不匹配**的问题

|              |                        通俗解释                         |                         工作方式                          | 工作时间计算（T=传输时间，C=处理时间，M=移动时间） |
| :----------: | :-----------------------------------------------------: | :-------------------------------------------------------: | :------------------------------------------------: |
|  **单缓冲**  |      只有一个“篮子”，CPU和设备轮流用这个篮子装数据      |     设备装满数据→CPU取走处理→设备再装新数据，交替进行     |              **总时间 ≈ Max(C,T)+M**               |
|  **双缓冲**  | 有两个“篮子”，一个装数据时，CPU可以处理另一个篮子的数据 |   设备装篮子1→CPU处理篮子1时，设备同时装篮子2→交替使用    |              **总时间 ≈ Max(C+M,T)**               |
| **循环缓冲** |    多个“篮子”排成圈，设备和CPU按顺序轮流用不同的篮子    |  设备连续装多个篮子，CPU按顺序处理，形成“生产-消费”循环   |                         -                          |
|  **缓冲池**  |       一堆“共享篮子”谁需要谁拿，用完了放回池子里        | 动态分配缓冲区，设备和CPU谁需要就申请空闲缓冲区，用完归还 |                         -                          |

#### 高速缓存和缓冲区区别

<img src="408.assets/image-20250810222617507.png" alt="image-20250810222617507" style="zoom:80%;" />

### 8.SPOOLing技术(假脱机)

|              |                         通俗解释                          |                        现实例子                        |
| :----------: | :-------------------------------------------------------: | :----------------------------------------------------: |
|  **假脱机**  | 让CPU以为外设（如打印机）很快，实际是磁盘在偷偷帮忙干活。 | 你点“打印”，电脑瞬间完成（其实是把任务扔给硬盘排队）。 |
| **排队机制** |  所有任务按顺序存在磁盘里，外设一个一个处理，避免冲突。   | 10个人同时打印，文件在硬盘里排成队列，打印机按顺序打。 |
| **并行工作** |     CPU可以继续干别的，外设和磁盘偷偷配合，互不干扰。     |  你打印时还能看电影，因为打印机和硬盘在后台默默工作。  |
| **适用场景** |  所有“慢吞吞”的外设（打印机、磁带机等）需要和CPU“解耦”。  |      网络打印机、批量数据处理（如银行夜间结算）。      |

### 9.设备驱动程序

1. **命令转换机制**
	- 接收上层抽象的I/O请求（如read/write）
	- 将**逻辑操作转换为物理操作参数**（如将逻辑盘块号映射为磁盘的物理参数：盘面号+磁道号+扇区号）
2. 请求验证机制
	- **检查I/O请求的合法性**（权限验证）
	- **监控设备状态**（如检查设备是否在线/就绪）
	- 配置设备工作模式（如设置打印机分辨率）
3. 任务调度机制
	- 设备空闲时立即启动I/O操作
	- 设备忙时将请求**进程挂入设备等待队列**（通过PCB链表实现）
4. 中断响应机制
	- **接收**设备控制器发来的**中断信号**
	- 根据中断类型调用对应**处理程序**（如完成中断/错误中断）

### 10.IO操作举例

**1. 用户态阶段：C库函数处理**

- **用户缓冲区检查**

	`scanf()`首先检查关联的**用户缓冲区buf**（位于用户空间）：

	- **有数据**：直接从buf读取字符，跳过系统调用
	- **无数据**：触发系统调用`read(fd, buf, count)`，准备**从内核读取数据**
		- **参数说明**：
			- `fd`：文件描述符（如`stdin`对应键盘设备）
			- `buf`：目标用户缓冲区地址。
			- `count`：最大读取字节数（此处为1字符）

**2. 用户态到内核态切换**

- **陷阱指令（trap）**

	`read`调用通过CPU的**自陷trap指令**从**用户态切换到内核态**，传递参数并跳转到内核的**系统调用**服务例程

	<img src="408.assets/image-20250810225659030.png" alt="image-20250810225659030" style="zoom:80%;" />

**3. 内核态阶段：I/O操作执行**

- **内核缓冲区申请**

	内核为本次I/O分配**内核缓冲区**，并通知设备驱动层（如键盘驱动）准备数据

- **阻塞与等待输入**

	1. 进程P因等待I/O被置为**阻塞状态**，CPU调度其他进程运行
	2. **键盘输入**：用户按下按键，字符暂存到键盘接口的**数据端口**
	3. **中断触发**：键盘接口向CPU发送**中断请求**
	4. **中断处理**：
		- CPU暂停当前任务，执行**键盘中断处理程序**
		- 从数据端口读取字符，存入**内核缓冲区**
	5. **唤醒进程**：进程P被标记为就绪状态，重新参与调度

**4. 数据返回用户态**

- **内核到用户复制**

	进程P再次获得CPU后，内核将字符从**内核缓冲区**复制到`scanf`的**用户缓冲区buf**

- **系统调用返回**：内核态切换回用户态，`read`调用结束

**5. 用户态最终处理**

- **字符解析与存储**

	`scanf`从用户缓冲区buf提取字符，解析后存入变量`d`，完成赋值

### 11.磁盘

#### 磁盘概念

**磁头数**=**盘面数**

**磁道数**=**柱面数**

**扇区**=**盘块**，通常为1KB，**内部密，外部疏**，**存储能力取决于最内道密度**

**磁盘地址**：<img src="408.assets/image-20250728175718255.png" alt="image-20250728175718255" style="zoom:80%;" />

<img src="408.assets/image-20250811122110361.png" alt="image-20250811122110361" style="zoom:80%;" />

#### 磁盘管理

**物理格式化**也称为**低级格式化**，是指在**磁盘制造或初始化阶段**，对磁盘的**物理结构(磁道、扇区、柱面)**进行**划分和标记**的过程。这一过程由**磁盘制造商或专用工具**完成，与操作系统无关

**逻辑格式化**也称为高级格式化，是指在**磁盘的分区上创建文件系统**的过程。这一过程由**操作系统或用户**主动触发（如使用`mkfs`、`format`命令）

### 12.磁盘调度算法

#### 磁盘存取时间

$$
存取时间=寻道时间+旋转延迟时间+IO传输时间
$$

寻道时间取**最外到最内时间的一半**

旋转延迟时间取**转半周的时间**

**寻道时间最长**

#### 先来先服务 FCFS

`55,58,39,18,90,160,150,38,184`

<img src="408.assets/image-20250811124759314.png" alt="image-20250811124759314" style="zoom:80%;" />

#### 最短寻道时间优先 SSTF

Shortest Seek Time First

`55,58,39,18,90,160,150,38,184`

<img src="408.assets/image-20250811124909165.png" alt="image-20250811124909165" style="zoom:80%;" />

会出现**饥饿现象**，离得较远的长时间得不到访问

#### 扫描法 SCAN

`55,58,39,18,90,160,150,38,184`

<img src="408.assets/image-20250811125019512.png" alt="image-20250811125019512" style="zoom:80%;" />

**缺点**：**对扫描过的区域不公平**，比如100右侧已被扫描，却**又要折返回来**浪费时间

#### 循环扫描法 C-SCAN

Circular SCAN

`55,58,39,18,90,160,150,38,184`

<img src="408.assets/image-20250811125222638.png" alt="image-20250811125222638" style="zoom:80%;" />

到达一端后，立刻跳转到另一端

#### LOOK

改良的SCAN

`55,58,39,18,90,160,150,38,184`

<img src="408.assets/image-20250811125345324.png" alt="image-20250811125345324" style="zoom:80%;" />

不走到端点，走到最后一个点就折返

#### C-LOOK

改良的C-SCAN

`55,58,39,18,90,160,150,38,184`

<img src="408.assets/image-20250811125422618.png" alt="image-20250811125422618" style="zoom:80%;" />

不走到端点，走到最后一个点就跳转

#### 减少旋转延迟时间

磁头读入一个扇区后，需要经过**短暂的处理时间**，才能开始读入下一个扇区

所以如果**下一个扇区和刚刚读过的扇区相邻**，则会**在等待时间中被跳过**，导致要**多转一圈**

**解决方法**：**交替编号**，让**下一个扇区**物理上**不要和当前扇区相邻**

<img src="408.assets/image-20250811125922838.png" alt="image-20250811125922838" style="zoom:80%;" />

#### 减少IO传输时间

|              方法              |                          原理/操作                           |             典型应用场景             |
| :----------------------------: | :----------------------------------------------------------: | :----------------------------------: |
|      **1. 磁盘高速缓存**       |            在**内存中缓存**频繁访问的**磁盘数据**            |    数据库热点数据、系统频繁读文件    |
|    **2. 调整磁盘请求顺序**     |       使用**调度算法**（如SSTF、SCAN）优化磁头移动顺序       |  高并发磁盘请求（如服务器存储系统）  |
|  **3. 提前读（Read-Ahead）**   |           读取当前块时预加载**相邻块**到内存缓冲区           | 顺序读取大文件（如视频流、日志文件） |
| **4. 延迟写（Delayed Write）** |  写入数据时**先标记缓冲区**，待**其他进程申请时才真正写盘**  |          临时文件、日志缓冲          |
|     **5. 优化物理块分布**      |   **同一文件的块尽量放在相邻磁道**，或按簇（Cluster）分配    | 文件系统初始化（如ext4、NTFS格式化） |
|     **6. 虚拟盘（RAM盘）**     |                用**内存模拟磁盘**存储临时文件                |      临时数据缓存、编译中间文件      |
|    **7. 磁盘阵列（RAID）**     | **多磁盘并行交叉存取**（如RAID 0加速，RAID 1/5兼顾速度与冗余） |         企业级存储、数据中心         |

### 13.固态硬盘 SSD

1. **SSD基于闪存flash**

2. **写入前要擦除**，**寿命有限**

3. **磨损均衡**：

	如果反复写入同一区块，该区块会先报废，导致SSD提前失效

	磨损均衡算法，让**所有区块均匀磨损**

	- **动态磨损均衡**：优先写入**擦除次数少的块**
	- **静态磨损均衡**：数据长期不变，也让老的块承担读任务，新的块准备承担写任务
